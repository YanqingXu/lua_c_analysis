/**
 * @file ltable.h
 * @brief Lua表系统接口：实现高性能的混合数组-哈希表数据结构
 * 
 * 详细说明：
 * 这个头文件定义了Lua表系统的核心接口，Lua表是一种独特的数据结构，
 * 同时具备数组和哈希表的特性。设计采用了混合存储策略：对于连续的
 * 正整数键使用数组存储以获得O(1)的访问性能；对于其他类型的键或
 * 非连续的数值键使用哈希表存储。这种设计使得Lua表既能高效处理
 * 数组操作，又能灵活支持关联数组的需求。
 * 
 * 系统架构定位：
 * - 位于Lua对象系统的核心，是最重要的复合数据类型
 * - 与垃圾收集器(lgc)深度集成，支持增量式内存管理
 * - 与元表系统(ltm)协作，实现强大的面向对象特性
 * - 为Lua虚拟机提供全局变量、局部环境等存储支持
 * 
 * 技术特点：
 * - 混合存储：数组部分和哈希部分的智能分配
 * - 动态调整：根据使用模式自动调整内存布局
 * - 高效访问：数值键和字符串键的优化访问路径
 * - 弱引用支持：支持弱键和弱值的垃圾收集
 * - 元表机制：完整的元编程和操作符重载支持
 * - 迭代器支持：高效的表遍历和next操作
 * 
 * 依赖关系：
 * - lobject.h: Lua对象系统，提供Table、Node、TValue等核心类型
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 指针算术：用于节点数组的操作和优化
 * - 位操作：哈希值计算和掩码操作
 * - 联合体支持：键值对的内存优化存储
 * 
 * 使用示例：
 * @code
 * #include "ltable.h"
 * #include "lua.h"
 * 
 * // 创建新表
 * lua_State *L = luaL_newstate();
 * Table *t = luaH_new(L, 10, 4);  // 10个数组元素，2^4个哈希槽
 * 
 * // 数值键操作
 * TValue val;
 * setnvalue(&val, 42.0);
 * TValue *slot = luaH_setnum(L, t, 1);  // 设置 t[1]
 * setobj(L, slot, &val);
 * 
 * const TValue *result = luaH_getnum(t, 1);  // 获取 t[1]
 * if (result != luaO_nilobject) {
 *     printf("t[1] = %g\n", nvalue(result));
 * }
 * 
 * // 字符串键操作
 * TString *key = luaS_newliteral(L, "name");
 * TValue strval;
 * setsvalue(L, &strval, luaS_newliteral(L, "Lua"));
 * TValue *strslot = luaH_setstr(L, t, key);
 * setobj(L, strslot, &strval);
 * 
 * // 遍历表
 * TValue k, v;
 * setnilvalue(&k);
 * while (luaH_next(L, t, L->top) != 0) {
 *     // 键在 L->top，值在 L->top+1
 *     L->top += 2;  // 为下一次迭代准备
 * }
 * 
 * // 获取表长度
 * int len = luaH_getn(t);
 * printf("表长度: %d\n", len);
 * 
 * lua_close(L);  // 自动清理所有表
 * @endcode
 * 
 * 表存储架构：
 * - 数组部分：索引1到n的连续正整数键
 * - 哈希部分：其他所有类型的键
 * - 动态平衡：根据使用模式自动调整两部分的大小
 * 
 * 性能特征：
 * - 数组访问：O(1)的直接索引访问
 * - 哈希访问：平均O(1)，最坏O(n)的哈希表访问
 * - 动态扩容：摊销O(1)的插入操作
 * - 内存效率：混合存储最小化内存使用
 * 
 * 哈希冲突解决：
 * - 开放寻址法：使用线性探测处理冲突
 * - 主位置优化：尽量保持键在其主哈希位置
 * - 链式连接：冲突节点通过next指针连接
 * 
 * 内存管理：
 * - 延迟分配：按需分配数组和哈希部分
 * - 智能调整：根据插入模式优化内存布局
 * - 垃圾收集：与GC系统集成的自动内存回收
 * 
 * 注意事项：
 * - 表的结构可能在任何插入操作后发生变化
 * - 遍历过程中不应修改表结构
 * - 弱引用表需要特别的垃圾收集处理
 * - 大量数值键的表应优先考虑数组部分
 * 
 * @author Roberto Ierusalimschy
 * @version 2.10.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lobject.h, lgc.h, ltm.h
 */

#ifndef ltable_h
#define ltable_h

#include "lobject.h"

/**
 * @brief 获取节点：访问表中指定索引的哈希节点
 * 
 * 这个宏提供了对表的哈希部分中特定索引位置节点的直接访问。
 * 哈希部分使用节点数组存储键值对，每个节点包含键、值和
 * 链接信息。
 * 
 * @param t Table指针
 * @param i 节点索引（0到表的哈希大小-1）
 * @return 指向对应节点的Node指针
 * 
 * @note 索引i必须在有效范围内，否则行为未定义
 * @warning 直接节点访问主要用于内部实现，外部使用需谨慎
 */
#define gnode(t,i)    (&(t)->node[i])

/**
 * @brief 获取键：从节点中提取键的TKey部分
 * 
 * 返回节点中键的TKey结构体部分，包含键值和类型信息。
 * TKey是键存储的核心结构，包含实际的键值数据和next指针。
 * 
 * @param n Node指针
 * @return 指向键的TKey结构体的指针
 * 
 * @see key2tval() 获取键的TValue表示
 */
#define gkey(n)        (&(n)->i_key.nk)

/**
 * @brief 获取值：从节点中提取值部分
 * 
 * 返回节点中存储的值，所有的值都以TValue形式存储，
 * 可以是任意Lua类型（数字、字符串、表、函数等）。
 * 
 * @param n Node指针
 * @return 指向值的TValue指针
 * 
 * @note 返回的TValue指针可以直接用于读取或修改值
 */
#define gval(n)        (&(n)->i_val)

/**
 * @brief 获取下一个：访问冲突链中的下一个节点索引
 * 
 * 在开放寻址的哈希表中，发生冲突的键通过next指针链接。
 * 这个宏返回链表中下一个节点的索引，用于遍历冲突链。
 * 
 * @param n Node指针
 * @return 下一个节点的索引，0表示链表结束
 * 
 * @note next值0表示没有下一个节点（链表结束）
 * @see luaH_mainposition() 获取键的主位置
 */
#define gnext(n)    ((n)->i_key.nk.next)

/**
 * @brief 键转TValue：将节点的键转换为TValue表示
 * 
 * 这个宏提供了访问键的TValue表示的便利方法，使得键可以
 * 像普通的Lua值一样被处理和操作。
 * 
 * @param n Node指针
 * @return 指向键的TValue表示的指针
 * 
 * @note 这是gkey()的TValue版本，提供统一的值接口
 */
#define key2tval(n)    (&(n)->i_key.tvk)

/**
 * @brief 数值键查找：在表中查找指定的数值键
 * 
 * 详细说明：
 * 这个函数实现了对数值键的高效查找。对于正整数键，会首先
 * 检查数组部分；对于其他数值键，则在哈希部分中查找。这种
 * 分层查找策略保证了常见操作的最优性能。
 * 
 * 查找策略：
 * 1. 如果key是正整数且在数组范围内，直接索引数组部分
 * 2. 否则计算哈希值，在哈希部分中查找
 * 3. 处理哈希冲突和链式查找
 * 
 * 性能特征：
 * - 数组部分查找：O(1)直接访问
 * - 哈希部分查找：平均O(1)，最坏O(链长度)
 * - 特殊值处理：NaN和负零等特殊情况
 * 
 * @param t 目标表的指针
 * @param key 要查找的数值键
 * @return 找到则返回指向对应值的TValue指针，否则返回luaO_nilobject
 * 
 * @note 返回luaO_nilobject表示键不存在
 * @warning 返回的指针在表结构改变后可能失效
 * @see luaH_setnum(), luaH_get()
 */
LUAI_FUNC const TValue *luaH_getnum(Table *t, int key);

/**
 * @brief 数值键设置：设置或创建指定数值键的值槽
 * 
 * 详细说明：
 * 这个函数为指定的数值键分配或定位值存储位置。如果键不存在，
 * 会在合适的位置（数组部分或哈希部分）创建新的槽位。这个函数
 * 是修改表内容的核心，会根据需要触发表的重新哈希或数组扩展。
 * 
 * 分配策略：
 * 1. 正整数键优先分配到数组部分
 * 2. 数组空间不足时可能触发表重构
 * 3. 其他键分配到哈希部分
 * 4. 必要时扩展哈希表大小
 * 
 * 表重构触发条件：
 * - 数组部分使用率过低
 * - 哈希部分负载因子过高
 * - 大量数值键可以优化为数组存储
 * 
 * 性能影响：
 * - 常规情况：O(1)的槽位分配
 * - 重构时：O(n)的一次性开销
 * - 摊销复杂度：O(1)的插入性能
 * 
 * @param L Lua状态机指针，用于内存分配和错误处理
 * @param t 目标表的指针
 * @param key 要设置的数值键
 * @return 指向值槽的TValue指针，可以直接设置值
 * 
 * @note 返回的指针可以直接用于设置值，无需额外的赋值操作
 * @warning 可能触发垃圾收集，调用后其他指针可能失效
 * @see luaH_getnum(), luaH_resizearray()
 */
LUAI_FUNC TValue *luaH_setnum(lua_State *L, Table *t, int key);

/**
 * @brief 字符串键查找：在表中查找指定的字符串键
 * 
 * 详细说明：
 * 专门针对字符串键优化的查找函数。由于字符串在Lua中是内部化的
 * （相同内容的字符串共享同一个对象），字符串比较可以直接通过
 * 指针比较完成，这大大提高了字符串键查找的效率。
 * 
 * 优化特点：
 * - 字符串指针比较：O(1)的键比较
 * - 预计算哈希：利用字符串对象的缓存哈希值
 * - 快速路径：常见字符串键的优化处理
 * 
 * 查找过程：
 * 1. 使用字符串的预计算哈希值定位主位置
 * 2. 通过指针比较快速匹配键
 * 3. 沿冲突链查找直到找到或确认不存在
 * 
 * 应用场景：
 * - 对象属性访问（obj.name）
 * - 全局变量查找
 * - 模块和命名空间操作
 * - 元表方法查找
 * 
 * @param t 目标表的指针
 * @param key 要查找的字符串键（TString对象）
 * @return 找到则返回指向对应值的TValue指针，否则返回luaO_nilobject
 * 
 * @note key必须是有效的TString对象指针
 * @see luaH_setstr(), luaH_get()
 */
LUAI_FUNC const TValue *luaH_getstr(Table *t, TString *key);

/**
 * @brief 字符串键设置：设置或创建指定字符串键的值槽
 * 
 * 详细说明：
 * 专门针对字符串键优化的设置函数。利用字符串内部化的特性，
 * 实现高效的字符串键插入和更新。这个函数在处理对象属性、
 * 全局变量等场景时具有重要的性能意义。
 * 
 * 优化策略：
 * - 预计算哈希：复用字符串对象的哈希值
 * - 指针比较：避免昂贵的字符串内容比较
 * - 位置优化：尽量将键放置在主哈希位置
 * 
 * 处理流程：
 * 1. 检查字符串键是否已存在
 * 2. 如果不存在，在哈希部分分配新槽位
 * 3. 必要时触发哈希表扩展
 * 4. 返回可写的值槽指针
 * 
 * 内存管理：
 * - 字符串键的生命周期由GC管理
 * - 表扩展时可能触发垃圾收集
 * - 字符串对象自动内部化和共享
 * 
 * @param L Lua状态机指针，用于内存分配和GC
 * @param t 目标表的指针
 * @param key 要设置的字符串键（TString对象）
 * @return 指向值槽的TValue指针，可以直接设置值
 * 
 * @note key必须是有效的TString对象，通常通过luaS_new*函数创建
 * @warning 可能触发垃圾收集，调用后其他指针可能失效
 * @see luaH_getstr(), luaH_set()
 */
LUAI_FUNC TValue *luaH_setstr(lua_State *L, Table *t, TString *key);

/**
 * @brief 通用键查找：在表中查找任意类型的键
 * 
 * 详细说明：
 * 这是最通用的表查找函数，可以处理任意类型的键，包括数字、
 * 字符串、表、函数、用户数据等。函数内部会根据键的类型选择
 * 最优的查找策略，确保各种键类型都能获得良好的性能。
 * 
 * 类型分发：
 * - 数值键：委托给luaH_getnum()进行优化处理
 * - 字符串键：委托给luaH_getstr()进行优化处理
 * - 其他类型：使用通用哈希算法处理
 * 
 * 支持的键类型：
 * - LUA_TNUMBER：数值键，包括整数和浮点数
 * - LUA_TSTRING：字符串键，利用内部化优化
 * - LUA_TTABLE：表作为键，使用对象指针
 * - LUA_TFUNCTION：函数作为键
 * - LUA_TUSERDATA：用户数据作为键
 * - LUA_TTHREAD：线程作为键
 * - LUA_TBOOLEAN：布尔值作为键
 * 
 * 特殊情况处理：
 * - nil键：总是返回nil（键不能为nil）
 * - NaN：特殊的数值处理
 * - 负零：与正零区分处理
 * 
 * 哈希算法：
 * - 数值：基于IEEE 754表示的哈希
 * - 字符串：预计算的哈希值
 * - 对象：基于指针地址的哈希
 * - 布尔：简单的值映射
 * 
 * @param t 目标表的指针
 * @param key 要查找的键（任意类型的TValue）
 * @return 找到则返回指向对应值的TValue指针，否则返回luaO_nilobject
 * 
 * @note nil键会直接返回luaO_nilobject
 * @warning 对于复杂对象作为键，需要注意生命周期管理
 * @see luaH_set(), luaH_getnum(), luaH_getstr()
 */
LUAI_FUNC const TValue *luaH_get(Table *t, const TValue *key);

/**
 * @brief 通用键设置：设置或创建任意类型键的值槽
 * 
 * 详细说明：
 * 最通用的表设置函数，能够处理所有类型的键。这个函数是Lua
 * 表操作的核心，所有的表赋值操作最终都会通过这个函数完成。
 * 函数会根据键类型选择最优的处理策略，并在必要时重构表结构。
 * 
 * 处理策略：
 * - 数值键：优先考虑数组部分存储
 * - 字符串键：利用内部化进行优化
 * - 对象键：使用指针哈希
 * - 布尔键：简单映射处理
 * 
 * 表重构逻辑：
 * 当插入新键时，函数会评估当前表的使用模式：
 * 1. 如果大量正整数键可以优化为数组存储，触发数组扩展
 * 2. 如果哈希部分负载过高，触发哈希表扩展
 * 3. 如果数组部分利用率过低，可能缩减数组大小
 * 
 * 性能考虑：
 * - 大多数操作：O(1)的摊销复杂度
 * - 表重构：O(n)的一次性开销
 * - 内存分配：可能触发垃圾收集
 * 
 * 错误处理：
 * - nil键：抛出错误（表的键不能为nil）
 * - 内存不足：通过Lua错误机制处理
 * - 类型错误：在类型检查层面处理
 * 
 * @param L Lua状态机指针，用于内存分配和错误处理
 * @param t 目标表的指针
 * @param key 要设置的键（任意类型的TValue）
 * @return 指向值槽的TValue指针，可以直接设置值
 * 
 * @note key为nil时会抛出错误
 * @warning 可能触发表重构和垃圾收集
 * @see luaH_get(), luaH_setnum(), luaH_setstr()
 */
LUAI_FUNC TValue *luaH_set(lua_State *L, Table *t, const TValue *key);

/**
 * @brief 创建新表：分配并初始化一个新的Lua表
 * 
 * 详细说明：
 * 这个函数创建一个新的Lua表，并根据提供的大小提示预分配
 * 数组部分和哈希部分的空间。合理的大小提示可以避免后续的
 * 多次重分配，提高性能并减少内存碎片。
 * 
 * 分配策略：
 * - 数组部分：直接分配narray个TValue槽位
 * - 哈希部分：分配2^lnhash个Node节点
 * - 内存对齐：确保缓存友好的内存布局
 * 
 * 初始化过程：
 * 1. 分配Table结构体
 * 2. 初始化数组部分（如果narray > 0）
 * 3. 初始化哈希部分（如果lnhash > 0）
 * 4. 设置表的元表为nil
 * 5. 初始化GC标记和链接
 * 
 * 大小计算：
 * - narray：直接指定数组部分大小
 * - lnhash：哈希部分大小为2^lnhash
 * - 0值表示不预分配对应部分
 * 
 * 性能优化：
 * - 预分配避免了初期的频繁扩展
 * - 2的幂次大小优化哈希计算
 * - 延迟分配节省不必要的内存
 * 
 * 内存管理：
 * - 新表自动注册到垃圾收集器
 * - 内存分配失败时抛出内存错误
 * - 支持增量垃圾收集
 * 
 * 使用建议：
 * - 已知数组大小时提供narray提示
 * - 已知键数量时提供合理的lnhash
 * - 不确定时使用0，让表自动增长
 * 
 * @param L Lua状态机指针，用于内存分配和GC注册
 * @param narray 数组部分的初始大小（0表示不预分配）
 * @param lnhash 哈希部分大小的对数（实际大小为2^lnhash）
 * @return 新创建的表的指针
 * 
 * @note 返回的表已经初始化并注册到垃圾收集器
 * @warning 内存分配失败时会通过Lua错误机制抛出异常
 * @see luaH_free(), luaH_resizearray()
 */
LUAI_FUNC Table *luaH_new(lua_State *L, int narray, int lnhash);

/**
 * @brief 调整数组大小：重新调整表的数组部分大小
 * 
 * 详细说明：
 * 这个函数专门用于调整表的数组部分大小，是表优化的重要工具。
 * 当发现大量连续的正整数键时，将它们从哈希部分迁移到数组部分
 * 可以显著提高访问性能并减少内存使用。
 * 
 * 调整过程：
 * 1. 分析当前表中的键分布
 * 2. 确定optimal数组大小
 * 3. 分配新的数组空间
 * 4. 迁移数据从哈希部分到数组部分
 * 5. 更新表的内部结构
 * 
 * 迁移策略：
 * - 键1到nasize的整数键迁移到数组部分
 * - 超出范围的数值键保留在哈希部分
 * - 非数值键不受影响
 * 
 * 性能影响：
 * - 短期：O(n)的迁移开销
 * - 长期：显著提高数组访问性能
 * - 内存：可能减少总内存使用
 * 
 * 触发条件：
 * - 发现大量连续正整数键
 * - 数组部分利用率过低需要压缩
 * - 外部显式调用进行优化
 * 
 * 安全保证：
 * - 操作是原子的，不会出现中间状态
 * - 保持所有键值对的完整性
 * - 不影响表的语义行为
 * 
 * @param L Lua状态机指针，用于内存分配
 * @param t 要调整的表的指针
 * @param nasize 新的数组大小
 * 
 * @note 调整过程可能触发垃圾收集
 * @warning 调整后表内指针可能发生变化
 * @see luaH_new(), luaH_set()
 */
LUAI_FUNC void luaH_resizearray(lua_State *L, Table *t, int nasize);

/**
 * @brief 释放表：释放表及其所有相关资源
 * 
 * 详细说明：
 * 这个函数负责完全释放一个表的所有资源，包括数组部分、哈希部分
 * 和表结构本身。通常由垃圾收集器调用，确保内存得到正确回收。
 * 
 * 释放过程：
 * 1. 释放数组部分内存（如果存在）
 * 2. 释放哈希节点数组（如果存在）
 * 3. 清理表的元表引用
 * 4. 释放表结构体本身
 * 
 * 内存回收：
 * - 所有分配的内存都会返回给内存分配器
 * - 遵循Lua的内存分配策略
 * - 支持自定义内存分配器
 * 
 * 安全考虑：
 * - 不检查表是否仍在使用中
 * - 调用者需确保表已无引用
 * - 释放后表指针无效
 * 
 * GC集成：
 * - 通常由垃圾收集器自动调用
 * - 支持增量垃圾收集模式
 * - 正确处理循环引用
 * 
 * @param L Lua状态机指针，用于内存释放
 * @param t 要释放的表的指针
 * 
 * @note 调用后t指针将无效，不能再使用
 * @warning 必须确保表没有其他引用
 * @see luaH_new(), 垃圾收集器
 */
LUAI_FUNC void luaH_free(lua_State *L, Table *t);

/**
 * @brief 表迭代：获取表中指定键的下一个键值对
 * 
 * 详细说明：
 * 这个函数实现了Lua表的迭代功能，是pairs()函数和next()函数的
 * 基础。它按照内部存储顺序遍历表中的所有键值对，首先遍历数组
 * 部分，然后遍历哈希部分。
 * 
 * 迭代顺序：
 * 1. 数组部分：按索引1, 2, 3, ...顺序
 * 2. 哈希部分：按节点数组的存储顺序
 * 3. 跳过nil值，只返回有效的键值对
 * 
 * 使用方式：
 * - 初始调用：key为nil，返回第一个键值对
 * - 后续调用：传入上次返回的键，获取下一个
 * - 结束标志：返回0表示遍历完成
 * 
 * 栈操作：
 * - key参数：L->top-1位置的键
 * - 返回时：L->top-1为键，L->top为值
 * - 失败时：栈状态不变
 * 
 * 安全性：
 * - 迭代过程中不能修改表结构
 * - 键必须是表中实际存在的键
 * - 无效键会导致未定义行为
 * 
 * 性能特征：
 * - 每次调用：O(1)平均复杂度
 * - 完整遍历：O(n)总体复杂度
 * - 内存访问：缓存友好的顺序访问
 * 
 * 典型用法：
 * @code
 * lua_pushnil(L);  // 第一个键
 * while (luaH_next(L, t, L->top-1) != 0) {
 *     // 使用 L->top-1 (键) 和 L->top (值)
 *     lua_pop(L, 1);  // 保留键用于下次迭代
 * }
 * @endcode
 * 
 * @param L Lua状态机指针，用于栈操作
 * @param t 要遍历的表的指针
 * @param key 当前键的栈索引
 * @return 找到下一个键值对返回1，遍历结束返回0
 * 
 * @note 迭代过程中修改表可能导致未定义行为
 * @warning 传入的key必须是表中实际存在的键
 * @see lua_next(), pairs()
 */
LUAI_FUNC int luaH_next(lua_State *L, Table *t, StkId key);

/**
 * @brief 获取表长度：计算表的"长度"（最大连续正整数键）
 * 
 * 详细说明：
 * 这个函数计算表的"长度"，按照Lua的定义，表的长度是最大的正整数
 * 索引n，使得t[n]不为nil且t[n+1]为nil。这个定义适用于数组风格
 * 的表，但对于稀疏表或纯哈希表，结果可能不符合直觉。
 * 
 * 计算算法：
 * 1. 首先检查数组部分的有效长度
 * 2. 然后在哈希部分查找更大的正整数键
 * 3. 使用二分查找优化性能
 * 4. 返回满足条件的最大索引
 * 
 * 数组部分处理：
 * - 从后向前扫描数组部分
 * - 找到最后一个非nil值的位置
 * - 这是数组部分的贡献长度
 * 
 * 哈希部分处理：
 * - 扫描哈希部分中的所有正整数键
 * - 找出大于数组部分长度的键
 * - 通过二分查找确定真正的长度边界
 * 
 * 边界情况：
 * - 空表：返回0
 * - 纯数组：返回数组的实际长度
 * - 稀疏数组：可能返回意外的结果
 * - 非数值键：不影响长度计算
 * 
 * 性能特征：
 * - 数组部分：O(log n)的二分查找
 * - 哈希部分：O(m)的线性扫描（m为哈希大小）
 * - 缓存友好：顺序访问数组部分
 * 
 * 使用场景：
 * - #操作符的实现
 * - table.insert()的位置确定
 * - 数组风格表的大小查询
 * - ipairs()的边界确定
 * 
 * 注意事项：
 * - 对于稀疏表，结果可能不是预期的"元素个数"
 * - 哈希键的存在可能影响结果
 * - 性能开销相对较大，避免频繁调用
 * 
 * @param t 要计算长度的表的指针
 * @return 表的长度（最大连续正整数键）
 * 
 * @note 对于稀疏表，结果可能不符合直觉
 * @warning 性能开销较大，应避免在循环中频繁调用
 * @see lua_objlen(), #操作符
 */
LUAI_FUNC int luaH_getn(Table *t);

/* 调试支持函数 - 仅在LUA_DEBUG模式下可用 */
#if defined(LUA_DEBUG)

/**
 * @brief 主位置：获取键在哈希表中的主要位置
 * 
 * 详细说明：
 * 这个调试函数返回指定键在哈希表中的主要位置（没有冲突时应该
 * 存储的位置）。这对于调试哈希表性能和分析冲突分布很有用。
 * 
 * 主位置计算：
 * - 根据键的类型选择合适的哈希函数
 * - 计算哈希值并映射到表的大小范围内
 * - 返回对应的节点指针
 * 
 * 调试用途：
 * - 分析哈希冲突的分布情况
 * - 验证哈希函数的质量
 * - 调试表性能问题
 * - 理解表的内部布局
 * 
 * @param t 目标表的指针
 * @param key 要查找主位置的键
 * @return 指向主位置节点的指针
 * 
 * @note 仅在调试模式下可用
 * @see gnext(), 哈希冲突处理
 */
LUAI_FUNC Node *luaH_mainposition(const Table *t, const TValue *key);

/**
 * @brief 虚拟节点检查：检查节点是否为虚拟节点
 * 
 * 详细说明：
 * 这个调试函数检查给定的节点是否为虚拟节点。虚拟节点是表中
 * 特殊的占位节点，用于优化某些内部操作。
 * 
 * 虚拟节点特征：
 * - 不包含有效的键值对
 * - 用于表重构时的临时状态
 * - 在某些内部算法中作为标记
 * 
 * 调试用途：
 * - 验证表结构的完整性
 * - 调试表重构算法
 * - 分析内存布局
 * 
 * @param n 要检查的节点指针
 * @return 非零值表示是虚拟节点，0表示是正常节点
 * 
 * @note 仅在调试模式下可用
 * @see luaH_resizearray(), 表重构
 */
LUAI_FUNC int luaH_isdummy(Node *n);

#endif

#endif
