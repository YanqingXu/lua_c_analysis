/*
** ====================================================================
** Lua 表（哈希表）实现头文件 (ltable.h)
** ====================================================================
**
** 版本信息: $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
** 版权声明: 参见 lua.h 中的版权信息
**
** 模块职责:
** 本文件定义了 Lua 表的核心数据结构访问接口和操作函数。
** Lua 表是语言的核心数据结构，同时支持数组和哈希表功能。
**
** 主要功能:
** 1. [访问接口] 表节点和键值对的快速访问宏
** 2. [数值索引] 整数键的优化访问接口
** 3. [字符串索引] 字符串键的专用访问接口  
** 4. [通用访问] 任意类型键的统一访问接口
** 5. [表管理] 表的创建、调整和销毁
** 6. [迭代遍历] 表内容的顺序遍历支持
** 7. [长度计算] 数组部分长度的高效计算
**
** 设计特点:
** - 混合存储：数组部分 + 哈希部分的混合设计
** - 性能优化：整数和字符串键的特殊优化
** - 动态调整：根据使用模式自动调整存储结构
** - 内存高效：紧凑的节点表示和智能内存管理
**
** 实现策略:
** - 开放寻址哈希：使用链表解决冲突
** - 弱引用支持：配合垃圾收集器的弱表实现
** - 增量调整：避免大表调整时的性能抖动
** - 缓存友好：优化内存布局提高访问效率
**
** 重要说明:
** 表是 Lua 中唯一的数据结构化类型，承担了数组、字典、对象、
** 模块等多种角色，其性能直接影响整个 Lua 程序的执行效率。
*/

#ifndef ltable_h
#define ltable_h

#include "lobject.h"


/*
** ====================================================================
** [核心] 表节点访问宏 - 高性能哈希表操作
** ====================================================================
**
** 以下宏提供了对表哈希部分的高效访问接口，这些操作是表实现的核心，
** 直接影响 Lua 程序的执行性能。
*/

/*
** [核心] 获取表节点指针宏
**
** 功能：获取表中指定索引的节点指针
** @param t: Table* 表指针
** @param i: int 节点索引
** @return: Node* 节点指针
**
** 实现原理：
** 直接通过数组索引访问哈希部分的节点数组，避免函数调用开销。
** 
** 性能特点：
** - 内联展开，零开销抽象
** - 直接内存访问，cache友好
** - 类型安全的指针运算
**
** 使用场景：
** - 哈希表内部遍历
** - 冲突链表操作
** - 节点状态检查
*/
#define gnode(t,i)	(&(t)->node[i])

/*
** [核心] 获取节点键指针宏
**
** 功能：获取节点中键的指针（TKey类型）
** @param n: Node* 节点指针
** @return: TKey* 键指针
**
** 实现说明：
** 访问节点的i_key.nk字段，这是键的实际存储位置。
** TKey结构同时包含键值和next指针，实现了内联链表。
**
** 用途：
** - 键值比较
** - 哈希值计算
** - 链表遍历
*/
#define gkey(n)		(&(n)->i_key.nk)

/*
** [核心] 获取节点值指针宏
**
** 功能：获取节点中值的指针（TValue类型）
** @param n: Node* 节点指针  
** @return: TValue* 值指针
**
** 实现说明：
** 直接访问节点的i_val字段，这是值的存储位置。
**
** 用途：
** - 读取表中的值
** - 修改表中的值
** - 值类型检查
*/
#define gval(n)		(&(n)->i_val)

/*
** [核心] 获取下一个节点索引宏
**
** 功能：获取冲突链表中下一个节点的索引
** @param n: Node* 当前节点指针
** @return: int 下一个节点索引，0表示链表结束
**
** 实现原理：
** 哈希冲突通过链表解决，next字段存储链表中下一个节点的索引。
** 使用索引而非指针可以在表调整大小时保持链表结构的正确性。
**
** 冲突解决：
** - 开放寻址 + 链表法
** - 新节点插入到链表头部
** - 零索引表示链表结束
*/
#define gnext(n)	((n)->i_key.nk.next)

/*
** [实用] 键转值宏
**
** 功能：将节点的键部分作为TValue访问
** @param n: Node* 节点指针
** @return: TValue* 键的值表示
**
** 设计原因：
** 在某些操作中，需要将键作为普通的Lua值处理，
** 比如在遍历时将键返回给Lua代码。
**
** 实现细节：
** 访问i_key.tvk字段，这是键的TValue表示形式。
** 与gkey()不同，这里返回的是标准的TValue结构。
**
** 应用场景：
** - next()函数的实现
** - 表遍历操作
** - 调试和诊断
*/
#define key2tval(n)	(&(n)->i_key.tvk)


/*
** ====================================================================
** [优化] 数值索引访问接口 - 整数键的高性能操作
** ====================================================================
*/

/*
** [优化] 数值键获取函数
**
** 功能：从表中获取整数键对应的值
** @param t: Table* 目标表
** @param key: int 整数键
** @return: const TValue* 值指针，如果键不存在返回luaO_nilobject
**
** 优化策略：
** 1. 首先检查数组部分（如果键在范围内）
** 2. 再检查哈希部分（如果数组部分没有）
** 3. 整数键使用特殊的哈希算法
**
** 性能特点：
** - 数组访问：O(1)时间复杂度
** - 哈希访问：平均O(1)，最坏O(n)
** - 无内存分配
** - 返回const指针，防止意外修改
**
** 使用场景：
** - 数组风格的表访问 t[1], t[2], ...
** - 稀疏数组的读取
** - for循环中的索引访问
*/
LUAI_FUNC const TValue *luaH_getnum (Table *t, int key);

/*
** [优化] 数值键设置函数
**
** 功能：设置表中整数键对应的值
** @param L: lua_State* Lua状态机
** @param t: Table* 目标表
** @param key: int 整数键
** @return: TValue* 值存储位置的指针
**
** 智能分配：
** 1. 如果键在数组范围内，直接使用数组部分
** 2. 如果键超出数组范围但接近，可能扩展数组部分
** 3. 否则在哈希部分创建新节点
**
** 内存管理：
** - 可能触发表的重新哈希
** - 可能触发垃圾收集
** - 返回的指针在下次GC前有效
**
** 特殊行为：
** - 如果值设置为nil，可能从表中删除该键
** - 新键的插入可能改变表的内部结构
*/
LUAI_FUNC TValue *luaH_setnum (lua_State *L, Table *t, int key);

/*
** ====================================================================
** [优化] 字符串索引访问接口 - 字符串键的专用优化
** ====================================================================
*/

/*
** [优化] 字符串键获取函数
**
** 功能：从表中获取字符串键对应的值
** @param t: Table* 目标表
** @param key: TString* 字符串键
** @return: const TValue* 值指针，如果键不存在返回luaO_nilobject
**
** 字符串优化：
** - 利用字符串的预计算哈希值
** - 字符串比较使用指针比较（内部化字符串）
** - 短字符串和长字符串的不同处理策略
**
** 哈希策略：
** - 短字符串：完全哈希，快速比较
** - 长字符串：采样哈希，节省计算
** - 利用字符串对象的缓存哈希值
**
** 性能优势：
** - 避免重复的哈希计算
** - 字符串指针比较替代内容比较
** - 专门的冲突解决策略
*/
LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);

/*
** [优化] 字符串键设置函数
**
** 功能：设置表中字符串键对应的值
** @param L: lua_State* Lua状态机
** @param t: Table* 目标表
** @param key: TString* 字符串键
** @return: TValue* 值存储位置的指针
**
** 字符串处理：
** - 自动处理字符串的内部化
** - 利用字符串对象的元数据
** - 优化的字符串哈希函数
**
** 应用场景：
** - 对象属性访问 obj.name = value
** - 字典操作 dict["key"] = value  
** - 模块和命名空间管理
*/
LUAI_FUNC TValue *luaH_setstr (lua_State *L, Table *t, TString *key);
/*
** ====================================================================
** [核心] 通用访问接口 - 支持任意类型键的统一接口
** ====================================================================
*/

/*
** [核心] 通用键获取函数
**
** 功能：从表中获取任意类型键对应的值
** @param t: Table* 目标表
** @param key: const TValue* 键值（任意Lua类型）
** @return: const TValue* 值指针，如果键不存在返回luaO_nilobject
**
** 支持的键类型：
** - 数字：整数和浮点数
** - 字符串：短字符串和长字符串
** - 布尔值：true和false
** - 用户数据：lightuserdata和userdata
** - 其他对象：函数、线程等（作为指针哈希）
**
** 类型分发：
** 根据键的类型选择最优的查找策略：
** 1. 数字键 -> 委托给luaH_getnum
** 2. 字符串键 -> 委托给luaH_getstr  
** 3. 其他类型 -> 通用哈希查找
**
** 特殊处理：
** - nil键总是返回nil（不能用nil作为键）
** - NaN浮点数作为键会导致特殊行为
** - 负零和正零被视为相同的键
*/
LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);

/*
** [核心] 通用键设置函数
**
** 功能：设置表中任意类型键对应的值
** @param L: lua_State* Lua状态机
** @param t: Table* 目标表
** @param key: const TValue* 键值（任意Lua类型）
** @return: TValue* 值存储位置的指针
**
** 智能路由：
** 根据键类型选择最优的设置策略，与luaH_get保持一致。
**
** 内存分配：
** - 新键可能导致哈希表扩容
** - 可能触发垃圾收集
** - 自动处理哈希冲突
**
** 错误处理：
** - nil键会抛出运行时错误
** - 内存不足时会传播内存错误
** - NaN键的行为是未定义的
**
** 元表支持：
** 此函数是原始设置，不触发__newindex元方法，
** 元方法的处理在更高层的接口中完成。
*/
LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);

/*
** ====================================================================
** [管理] 表生命周期管理接口
** ====================================================================
*/

/*
** [管理] 表创建函数
**
** 功能：创建一个新的Lua表
** @param L: lua_State* Lua状态机
** @param narray: int 数组部分的初始大小提示
** @param lnhash: int 哈希部分大小的对数提示（实际大小=2^lnhash）
** @return: Table* 新创建的表指针
**
** 预分配策略：
** - narray > 0：预分配数组部分，避免频繁扩容
** - lnhash > 0：预分配哈希部分，减少冲突
** - 合理的初始大小可以显著提升性能
**
** 内存管理：
** - 通过Lua的内存管理器分配
** - 新表自动注册到垃圾收集器
** - 初始化所有字段为合法状态
**
** 使用场景：
** - 表构造器 {} 的底层实现
** - C API中的表创建
** - 模块和命名空间的初始化
*/
LUAI_FUNC Table *luaH_new (lua_State *L, int narray, int lnhash);

/*
** [管理] 数组部分调整函数
**
** 功能：调整表的数组部分大小
** @param L: lua_State* Lua状态机
** @param t: Table* 目标表
** @param nasize: int 新的数组部分大小
**
** 调整策略：
** - 扩容：分配新的更大数组，复制现有元素
** - 缩容：将超出范围的元素移到哈希部分
** - 零大小：完全删除数组部分
**
** 性能考虑：
** - 大表的调整可能很耗时
** - 操作过程中可能触发垃圾收集
** - 自动处理数组和哈希部分的平衡
**
** 使用时机：
** - 检测到数组使用模式变化时
** - 表构造完成后的优化
** - 显式的table.resize调用
*/
LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);

/*
** [管理] 表销毁函数
**
** 功能：释放表占用的所有内存
** @param L: lua_State* Lua状态机
** @param t: Table* 要销毁的表
**
** 清理过程：
** 1. 释放数组部分内存
** 2. 释放哈希部分节点数组
** 3. 清理弱引用相关数据
** 4. 释放表结构本身
**
** 垃圾收集：
** - 由垃圾收集器自动调用
** - 处理循环引用和弱引用
** - 确保内存完全释放
**
** 注意事项：
** - 函数假设表已从所有引用中断开
** - 不处理元表和上值的清理
** - 调用前表应该已经不可达
*/
LUAI_FUNC void luaH_free (lua_State *L, Table *t);
/*
** ====================================================================
** [迭代] 表遍历和查询接口
** ====================================================================
*/

/*
** [迭代] 表遍历函数
**
** 功能：实现表的顺序遍历，支持next()函数和泛型for循环
** @param L: lua_State* Lua状态机
** @param t: Table* 目标表
** @param key: StkId 栈上的键位置
** @return: int 1表示找到下一个键值对，0表示遍历结束
**
** 遍历策略：
** 1. 首先遍历数组部分（按索引1,2,3...顺序）
** 2. 然后遍历哈希部分（按内部存储顺序）
** 3. 跳过值为nil的条目
**
** 状态管理：
** - 输入：key指向当前键（nil表示开始遍历）
** - 输出：key和key+1分别设置为下一个键和值
** - 遍历顺序在表结构不变时保持一致
**
** 重要特性：
** - 遍历过程中修改表可能导致未定义行为
** - 添加新元素可能改变遍历顺序
** - 删除当前元素通常是安全的
**
** 使用场景：
** - next(t, k) 函数的实现
** - pairs(t) 迭代器的基础
** - 表复制和序列化操作
**
** 性能考虑：
** - 大表的完整遍历可能很耗时
** - 哈希部分的遍历顺序不可预测
** - 避免在遍历中进行大量表修改
*/
LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);

/*
** [查询] 表长度计算函数
**
** 功能：计算表的"长度"（数组部分的有效长度）
** @param t: Table* 目标表
** @return: int 表的长度
**
** 长度定义：
** 根据Lua语言规范，表的长度是满足以下条件的最大整数n：
** - t[n] 不是nil
** - t[n+1] 是nil（或不存在）
**
** 计算策略：
** 1. 首先检查数组部分的边界
** 2. 使用二分搜索定位准确的长度
** 3. 考虑哈希部分的数值键
**
** 复杂性：
** - 对于紧密数组：O(1)或O(log n)
** - 对于稀疏数组：可能需要O(n)时间
** - 空洞（nil值）会影响长度计算
**
** 使用场景：
** - # 操作符的实现
** - table.getn() 函数
** - 数组风格操作的边界检查
**
** 注意事项：
** - 稀疏数组的长度可能不符合直觉
** - 哈希部分的数值键会影响结果
** - 频繁的长度查询可能影响性能
**
** 优化：
** - 表结构变化时可能缓存长度信息
** - 连续数组的长度计算被高度优化
** - 避免在紧凑循环中重复计算长度
*/
LUAI_FUNC int luaH_getn (Table *t);


/*
** ====================================================================
** [调试] 调试和诊断接口
** ====================================================================
**
** 以下函数仅在调试模式下可用，用于表实现的调试和诊断。
** 这些接口帮助开发者理解表的内部结构和哈希机制。
*/

#if defined(LUA_DEBUG)

/*
** [调试] 主位置计算函数
**
** 功能：计算给定键在哈希表中的主位置（理想位置）
** @param t: const Table* 目标表
** @param key: const TValue* 键值
** @return: Node* 主位置的节点指针
**
** 哈希机制：
** - 计算键的哈希值
** - 将哈希值映射到哈希表的槽位
** - 返回该键应该存储的理想位置
**
** 调试用途：
** - 分析哈希冲突情况
** - 验证哈希函数的分布性
** - 优化表的性能特征
** - 理解查找路径的长度
**
** 实现细节：
** - 不同类型的键使用不同的哈希算法
** - 哈希值需要模运算映射到表大小
** - 主位置不一定是键的实际存储位置
**
** 分析价值：
** - 主位置命中率反映哈希质量
** - 冲突链长度影响查找性能
** - 可以指导表大小的调整策略
*/
LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);

/*
** [调试] 虚拟节点检测函数
**
** 功能：检测节点是否为虚拟节点（dummy node）
** @param n: Node* 要检测的节点
** @return: int 非零表示是虚拟节点
**
** 虚拟节点概念：
** - 虚拟节点是哈希表中的特殊节点
** - 不包含有效的键值对数据
** - 用于维护哈希表的结构完整性
** - 在表调整过程中作为占位符
**
** 检测方法：
** - 检查节点的键是否为特殊标记
** - 验证节点在冲突链中的位置
** - 分析节点的初始化状态
**
** 调试应用：
** - 验证表结构的正确性
** - 分析内存使用效率
** - 检测表操作的边界情况
** - 确保垃圾收集的正确性
**
** 内部使用：
** - 表遍历时跳过虚拟节点
** - 内存回收时正确处理虚拟节点
** - 表调整时识别可重用的节点
*/
LUAI_FUNC int luaH_isdummy (Node *n);

#endif

#endif
