/*
** ====================================================================
** Lua 字符串表系统 (String Table System)
** ====================================================================
** 
** 文件作用：
** 本文件定义了 Lua 字符串内部化系统，负责管理所有由 Lua 处理的字符串。
** 字符串内部化是 Lua 的核心优化机制，确保相同内容的字符串在内存中只存储一份。
**
** 核心功能：
** 1. [内部化] 字符串去重和内部化管理
** 2. [哈希表] 全局字符串哈希表维护  
** 3. [内存] 字符串对象的内存分配和释放
** 4. [用户数据] 用户数据对象的创建和管理
** 5. [垃圾回收] 与 GC 系统的集成和标记
** 6. [优化] 字符串比较和查找的优化
**
** 设计特点：
** - 字符串内部化确保唯一性和快速比较
** - 全局哈希表统一管理所有字符串
** - 与垃圾回收系统紧密集成
** - 支持不同长度字符串的优化存储
** - 用户数据的统一内存管理
** - 字符串常量的编译时优化
**
** 依赖关系：
** - lgc.h: 垃圾回收系统，提供 GC 标记和管理
** - lobject.h: 基础对象系统，定义字符串和用户数据结构
** - lstate.h: 全局状态管理，维护字符串哈希表
*/

#ifndef lstring_h
#define lstring_h

#include "lgc.h"
#include "lobject.h"
#include "lstate.h"

/*
** ====================================================================
** [宏定义] 对象大小计算宏
** ====================================================================
*/

/*
** [计算] 字符串对象总大小宏
**
** 功能：计算 TString 对象在内存中的总大小
** @param s: TString* 字符串对象指针
** @return: size_t 字符串对象的总字节数
**
** 计算公式：
** - 基础结构大小：sizeof(union TString)
** - 字符数据大小：(s->len + 1) * sizeof(char)
** - +1 是为了存储字符串结尾的 '\0'
**
** 内存布局：
** [TString Header][字符数据]['\0']
** 
** 使用场景：
** - 内存分配时确定所需空间
** - 垃圾回收时计算对象大小
** - 内存统计和调试
** - 对象复制和移动操作
**
** 优化考虑：
** - 宏展开避免函数调用开销
** - 编译时如果长度已知可以优化
** - 字节对齐考虑在分配器中处理
*/
#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))

/*
** [计算] 用户数据对象总大小宏
**
** 功能：计算 Udata 对象在内存中的总大小
** @param u: Udata* 用户数据对象指针
** @return: size_t 用户数据对象的总字节数
**
** 计算公式：
** - 基础结构大小：sizeof(union Udata)
** - 用户数据大小：u->len
**
** 内存布局：
** [Udata Header][用户数据]
** 
** 使用场景：
** - 用户数据分配时确定空间
** - GC 时计算对象内存使用
** - 用户数据的序列化和传输
** - 内存碎片分析和优化
**
** 特点：
** - 用户数据长度任意，由用户指定
** - 不包含额外的终止符
** - 支持二进制数据存储
*/
#define sizeudata(u)	(sizeof(union Udata)+(u)->len)

/*
** ====================================================================
** [宏定义] 字符串创建便利宏
** ====================================================================
*/

/*
** [便利] C 字符串转 Lua 字符串宏
**
** 功能：将 C 风格的 null 终止字符串转换为 Lua 字符串
** @param L: lua_State* Lua 状态机指针
** @param s: const char* C 字符串指针
** @return: TString* 新创建的 Lua 字符串对象
**
** 实现原理：
** - 使用 strlen() 计算字符串长度
** - 调用 luaS_newlstr() 创建字符串对象
** - 自动处理长度计算和内存分配
**
** 使用场景：
** - C API 中字符串参数的转换
** - 字符串常量的快速创建
** - 与 C 库函数的交互
** - 动态字符串的构建
**
** 性能考虑：
** - strlen() 需要遍历整个字符串
** - 对于已知长度的字符串，直接使用 luaS_newlstr 更高效
** - 字符串内部化会检查重复，避免内存浪费
*/
#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))

/*
** [便利] 字符串字面量创建宏
**
** 功能：将编译时字符串字面量转换为 Lua 字符串
** @param L: lua_State* Lua 状态机指针
** @param s: 字符串字面量（如 "hello"）
** @return: TString* 新创建的 Lua 字符串对象
**
** 实现技巧：
** - "" s 连接字符串，确保 s 是字符串字面量
** - sizeof(s)/sizeof(char)-1 编译时计算长度
** - 减 1 是因为 sizeof 包含了 '\0'
**
** 编译时优化：
** - 字符串长度在编译时确定
** - 避免运行时 strlen() 调用
** - 编译器可以进行进一步优化
**
** 使用场景：
** - 字符串常量的高效创建
** - 库函数中的固定字符串
** - 错误消息和调试信息
** - 保留字和操作符名称
**
** 注意事项：
** - 只能用于字符串字面量，不能用于变量
** - 编译时必须能确定字符串内容
** - 字符串中不能包含 '\0' 字符
*/
#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
                                 (sizeof(s)/sizeof(char))-1))

/*
** ====================================================================
** [宏定义] 字符串固定标记宏
** ====================================================================
*/

/*
** [标记] 字符串固定化宏
**
** 功能：将字符串标记为固定，防止被垃圾回收器回收
** @param s: TString* 要标记的字符串对象
**
** 实现机制：
** - 设置字符串的 FIXEDBIT 标记位
** - 使用 l_setbit 宏进行位操作
** - 标记后的字符串不会被 GC 回收
**
** 固定化原因：
** - 系统关键字符串（如保留字）
** - 长期存在的字符串常量
** - C API 返回的字符串引用
** - 避免重要字符串的意外回收
**
** 使用场景：
** - Lua 初始化时固定保留字
** - 重要的全局字符串常量
** - 与 C 代码长期交互的字符串
** - 性能关键路径上的字符串
**
** 注意事项：
** - 固定的字符串会一直占用内存
** - 应该谨慎使用，避免内存泄漏
** - 通常在系统初始化时使用
** - 固定状态通常不可逆转
*/
#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)

/*
** ====================================================================
** [函数] 字符串表管理函数
** ====================================================================
*/

/*
** [管理] 字符串表大小调整函数
**
** 功能：调整全局字符串哈希表的大小
** @param L: lua_State* Lua 状态机指针
** @param newsize: int 新的哈希表大小
**
** 调整过程：
** 1. [分配] 分配新的哈希表数组
** 2. [重哈希] 将现有字符串重新分布到新表中
** 3. [释放] 释放旧的哈希表内存
** 4. [更新] 更新全局状态中的表引用
**
** 调整时机：
** - 字符串数量显著增加时
** - 哈希冲突过多导致性能下降
** - 内存压力需要缩小表大小
** - 垃圾回收后的表优化
**
** 性能影响：
** - 重哈希过程需要遍历所有字符串
** - 临时需要额外内存空间
** - 调整后查找性能会改善
** - 应该避免频繁调整
**
** 大小选择：
** - 通常使用质数作为哈希表大小
** - 负载因子控制在合理范围内
** - 考虑内存使用和查找效率的平衡
*/
LUAI_FUNC void luaS_resize (lua_State *L, int newsize);

/*
** [创建] 用户数据对象创建函数
**
** 功能：创建新的用户数据对象
** @param L: lua_State* Lua 状态机指针
** @param s: size_t 用户数据的字节大小
** @param e: Table* 环境表（可以为 NULL）
** @return: Udata* 新创建的用户数据对象
**
** 创建过程：
** 1. [分配] 分配足够的内存空间
** 2. [初始化] 设置用户数据头部信息
** 3. [链接] 将对象链接到 GC 系统
** 4. [环境] 设置用户数据的环境表
**
** 内存布局：
** [Udata Header][用户数据空间]
** - Header 包含 GC 信息、长度、环境表等
** - 用户数据空间由调用者使用
**
** 环境表作用：
** - 为用户数据提供方法和元表
** - 支持面向对象的用户数据
** - 可以为 NULL 表示无环境
** - 影响用户数据的行为和访问
**
** 使用场景：
** - C API 中创建用户数据
** - 封装 C 对象到 Lua 中
** - 存储任意二进制数据
** - 实现用户自定义类型
**
** GC 管理：
** - 自动链接到垃圾回收系统
** - 支持 __gc 元方法的终结器
** - 参与标记和清除过程
** - 内存由 GC 自动管理
*/
LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);

/*
** [创建] 指定长度字符串创建函数
**
** 功能：创建指定长度的 Lua 字符串对象
** @param L: lua_State* Lua 状态机指针
** @param str: const char* 源字符串数据
** @param l: size_t 字符串长度
** @return: TString* 新创建或已存在的字符串对象
**
** 创建过程：
** 1. [哈希] 计算字符串的哈希值
** 2. [查找] 在字符串表中查找是否已存在
** 3. [复用] 如果存在则直接返回现有对象
** 4. [创建] 如果不存在则创建新的字符串对象
** 5. [插入] 将新字符串插入到字符串表中
**
** 内部化机制：
** - 相同内容的字符串在内存中只存储一份
** - 字符串比较可以直接比较指针
** - 大幅减少内存使用和提高性能
** - 哈希表确保快速查找和插入
**
** 长度处理：
** - 支持包含 '\0' 的字符串
** - 长度参数明确指定字符串边界
** - 不依赖 C 字符串的 null 终止
** - 支持二进制数据的字符串存储
**
** 性能优化：
** - 哈希值缓存避免重复计算
** - 内部化避免重复存储
** - 字符串表的动态调整
** - 快速指针比较替代字符比较
**
** 使用场景：
** - 词法分析器创建标识符
** - 字符串字面量的处理
** - 动态字符串的构建
** - 与 C API 的字符串交互
**
** 内存管理：
** - 字符串对象由 GC 管理生命周期
** - 自动处理内存分配和释放
** - 支持字符串的垃圾回收
** - 与其他 Lua 对象统一管理
*/
LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);


#endif
