/**
 * @file lstring.h
 * @brief Lua字符串管理器接口：实现高效的字符串内部化和用户数据管理
 * 
 * 详细说明：
 * 这个头文件定义了Lua解释器的字符串管理系统核心接口，实现了字符串内部化
 * (string interning)机制。在Lua中，所有相同内容的字符串都共享同一个对象，
 * 这不仅节省了内存，还使得字符串比较可以通过指针比较来完成，大大提高了
 * 字符串操作的性能。此外，该模块还管理用户数据对象的创建和生命周期。
 * 
 * 系统架构定位：
 * - 位于Lua解释器的核心层，为所有字符串操作提供基础服务
 * - 与垃圾收集器(lgc)紧密集成，管理字符串对象的生命周期
 * - 与对象系统(lobject)协作，提供字符串类型的具体实现
 * - 与状态管理(lstate)配合，维护全局字符串表
 * 
 * 技术特点：
 * - 字符串内部化：所有字符串全局唯一，相同内容共享对象
 * - 哈希表管理：使用哈希表快速查找和存储字符串
 * - 动态调整：根据负载因子自动调整哈希表大小
 * - 垃圾收集集成：字符串作为GC对象统一管理
 * - 用户数据支持：提供用户自定义数据类型的内存管理
 * - 高效比较：字符串比较只需要比较指针地址
 * 
 * 依赖关系：
 * - lgc.h: 垃圾收集器接口，提供GC对象管理功能
 * - lobject.h: Lua对象系统，定义TString和Udata结构
 * - lstate.h: Lua状态管理，提供全局字符串表访问
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 联合体支持：依赖union TString和union Udata定义
 * - 哈希函数：需要高质量的字符串哈希算法
 * 
 * 使用示例：
 * @code
 * #include "lstring.h"
 * #include "lua.h"
 * 
 * // 创建新的字符串对象
 * const char *text = "Hello, Lua!";
 * TString *str = luaS_new(L, text);
 * 
 * // 创建指定长度的字符串
 * char buffer[100];
 * snprintf(buffer, sizeof(buffer), "Number: %d", 42);
 * TString *numstr = luaS_newlstr(L, buffer, strlen(buffer));
 * 
 * // 创建字符串字面量（编译时已知长度）
 * TString *literal = luaS_newliteral(L, "Fixed string");
 * 
 * // 创建用户数据
 * size_t size = sizeof(MyStruct);
 * Udata *udata = luaS_newudata(L, size, NULL);
 * MyStruct *data = (MyStruct*)udata->uv.data;
 * 
 * // 固定字符串（防止被GC回收）
 * luaS_fix(str);
 * @endcode
 * 
 * 字符串内部化机制：
 * - 全局唯一性：相同内容的字符串在内存中只有一份拷贝
 * - 哈希查找：通过哈希表快速查找已存在的字符串
 * - 自动创建：如果字符串不存在，自动创建新的字符串对象
 * - 引用共享：多个地方使用相同字符串时共享同一个对象
 * 
 * 性能特征：
 * - 字符串比较：O(1)时间复杂度的指针比较
 * - 内存效率：消除重复字符串，节省内存空间
 * - 哈希查找：平均O(1)的字符串查找时间
 * - 动态调整：自适应哈希表大小，保持高效性能
 * 
 * 线程安全性：
 * - 单线程设计：每个lua_State维护独立的字符串表
 * - 不可变性：字符串对象创建后内容不可修改
 * - GC安全：与垃圾收集器协调，安全管理对象生命周期
 * 
 * 注意事项：
 * - 字符串对象一旦创建就不可修改，保证内部化的正确性
 * - 大量不同的字符串可能导致哈希表增长，影响内存使用
 * - 字符串的生命周期由垃圾收集器管理，需要适当保护引用
 * - 用户数据的内存布局和对齐需要与平台相关的考虑
 * 
 * @author Roberto Ierusalimschy
 * @version 1.43.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lgc.h, lobject.h, lstate.h
 */

#ifndef lstring_h
#define lstring_h

#include "lgc.h"
#include "lobject.h"
#include "lstate.h"

/**
 * @brief 计算字符串对象大小：包含TString结构和字符串内容的总大小
 * 
 * 详细说明：
 * 这个宏计算一个完整字符串对象所需的内存大小，包括TString结构体本身
 * 和字符串内容所占用的空间。计算结果用于内存分配和垃圾收集统计。
 * 
 * 内存布局：
 * - union TString：字符串对象的头部结构
 * - 字符串内容：实际的字符数据
 * - 空字符终止符：C风格字符串的结尾标记
 * 
 * 大小计算：
 * - 基础大小：sizeof(union TString)
 * - 内容大小：(s->len + 1) * sizeof(char)
 * - +1用于容纳字符串终止符'\0'
 * 
 * 内存对齐：
 * - 编译器会自动处理结构体的内存对齐
 * - 实际分配的内存可能略大于计算值
 * - 对齐保证了高效的内存访问
 * 
 * 性能考虑：
 * - 编译时宏展开，零运行时开销
 * - 用于快速计算内存分配大小
 * - 支持垃圾收集器的精确内存统计
 * 
 * @param s 指向TString对象的指针
 * @return 字符串对象的总内存大小（字节数）
 * 
 * @note 返回值包括结构体头部和字符串内容的完整大小
 * @see luaS_newlstr(), luaM_realloc_()
 */
#define sizestring(s)    (sizeof(union TString) + ((s)->len + 1) * sizeof(char))

/**
 * @brief 计算用户数据对象大小：包含Udata结构和用户数据内容的总大小
 * 
 * 详细说明：
 * 这个宏计算一个完整用户数据对象所需的内存大小，包括Udata结构体
 * 和用户自定义数据的存储空间。用户数据是Lua提供给C扩展的机制，
 * 允许在Lua中存储任意的C数据结构。
 * 
 * 内存布局：
 * - union Udata：用户数据对象的头部结构
 * - 用户数据内容：实际的用户定义数据
 * - 可选的环境表指针
 * 
 * 大小计算：
 * - 基础大小：sizeof(union Udata)
 * - 用户数据大小：(u)->len字节
 * - 不包括额外的对齐填充
 * 
 * 用户数据特点：
 * - 可以存储任意C数据结构
 * - 支持元表和环境表
 * - 由垃圾收集器自动管理
 * - 可以设置终结器(__gc元方法)
 * 
 * 对齐考虑：
 * - 用户数据起始地址保证适当对齐
 * - 支持存储指针和复杂数据结构
 * - 编译器处理结构体内部对齐
 * 
 * @param u 指向Udata对象的指针
 * @return 用户数据对象的总内存大小（字节数）
 * 
 * @note 返回值不包括环境表等额外引用对象的大小
 * @see luaS_newudata(), lua_newuserdata()
 */
#define sizeudata(u)     (sizeof(union Udata) + (u)->len)

/**
 * @brief 创建新字符串：从C字符串创建Lua字符串对象的便利宏
 * 
 * 详细说明：
 * 这个宏提供了从标准C字符串创建Lua字符串对象的便利接口。它自动
 * 计算字符串长度，然后调用底层的字符串创建函数。这是最常用的
 * 字符串创建方式。
 * 
 * 工作流程：
 * 1. 使用strlen()计算字符串长度
 * 2. 调用luaS_newlstr()创建字符串对象
 * 3. 执行字符串内部化检查
 * 4. 返回字符串对象或已存在的对象
 * 
 * 内部化过程：
 * - 计算字符串的哈希值
 * - 在字符串表中查找相同内容的字符串
 * - 如果存在，返回已有对象
 * - 如果不存在，创建新的字符串对象
 * 
 * 性能特点：
 * - strlen()的时间复杂度为O(n)
 * - 哈希查找平均为O(1)
 * - 内存共享提高整体效率
 * 
 * 使用场景：
 * - 从C API向Lua传递字符串
 * - 处理配置文件和文本数据
 * - 创建错误消息和调试信息
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param s 指向C字符串的指针，必须以'\0'结尾
 * @return 指向TString对象的指针，如果已存在则返回共享对象
 * 
 * @note 输入字符串必须是有效的C字符串（以'\0'结尾）
 * @warning 字符串内容会被复制，原始指针可以安全释放
 * @see luaS_newlstr(), luaS_newliteral()
 */
#define luaS_new(L, s)    (luaS_newlstr(L, s, strlen(s)))

/**
 * @brief 创建字符串字面量：从编译时已知的字符串字面量创建Lua字符串
 * 
 * 详细说明：
 * 这个宏专门用于处理编译时已知的字符串字面量，它可以在编译时
 * 计算字符串长度，避免运行时的strlen()调用，提供更高的性能。
 * 
 * 编译时优化：
 * - 字符串长度在编译时计算
 * - 避免运行时的字符串扫描开销
 * - 利用编译器的常量折叠优化
 * 
 * 宏展开技巧：
 * - 使用""s的字符串连接特性
 * - 通过sizeof(s)/sizeof(char)-1计算长度
 * - -1是为了排除字符串终止符
 * 
 * 性能优势：
 * - 零运行时长度计算开销
 * - 编译器可以进行进一步优化
 * - 特别适用于常量字符串
 * 
 * 使用场景：
 * - 创建固定的错误消息
 * - 定义内置函数和操作符名称
 * - 处理关键字和保留字
 * - 初始化预定义字符串
 * 
 * 限制条件：
 * - 只能用于字符串字面量
 * - 不能用于运行时变量
 * - 字符串内容必须在编译时确定
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param s 字符串字面量，必须是编译时常量
 * @return 指向TString对象的指针
 * 
 * @note s必须是字符串字面量，不能是变量
 * @warning 不正确使用可能导致编译错误或运行时错误
 * @see luaS_newlstr(), luaS_new()
 */
#define luaS_newliteral(L, s)    (luaS_newlstr(L, "" s, \
                                 (sizeof(s) / sizeof(char)) - 1))

/**
 * @brief 固定字符串：将字符串标记为固定，防止被垃圾收集器回收
 * 
 * 详细说明：
 * 这个宏将指定的字符串对象标记为"固定"状态，这意味着垃圾收集器
 * 永远不会回收这个字符串。这主要用于系统级的字符串，如关键字、
 * 内置函数名等，这些字符串需要在整个Lua状态的生命周期内保持可用。
 * 
 * 固定机制：
 * - 设置字符串对象的FIXEDBIT标志位
 * - 垃圾收集器会跳过固定的对象
 * - 固定状态一旦设置就不能撤销
 * - 固定对象在lua_close时才被释放
 * 
 * 使用场景：
 * - Lua关键字（if、then、else等）
 * - 内置函数名（print、require等）
 * - 元方法名称（__index、__newindex等）
 * - 系统常量字符串
 * - 长期存在的配置字符串
 * 
 * 性能影响：
 * - 减少GC扫描开销
 * - 避免重要字符串的意外回收
 * - 可能增加内存使用（无法回收）
 * 
 * 内存考虑：
 * - 固定的字符串永远不会被释放
 * - 应该谨慎使用，避免内存泄漏
 * - 主要用于系统级别的字符串
 * 
 * 实现细节：
 * - 通过设置marked字段的FIXEDBIT实现
 * - 与垃圾收集器的标记算法集成
 * - 在字符串创建后任何时候都可以调用
 * 
 * @param s 指向要固定的TString对象的指针
 * 
 * @note 固定操作是不可逆的，字符串将永久保留在内存中
 * @warning 不要对大量字符串或大字符串使用此操作
 * @see FIXEDBIT, l_setbit(), lgc.h
 */
#define luaS_fix(s)      l_setbit((s)->tsv.marked, FIXEDBIT)

/**
 * @brief 调整字符串表大小：动态调整全局字符串哈希表的容量
 * 
 * 详细说明：
 * 这个函数负责调整Lua全局字符串表的大小，以保持哈希表的高效性能。
 * 当字符串数量增加或减少时，适时调整表大小可以保持较低的哈希冲突率，
 * 确保字符串查找和创建操作的高效性。
 * 
 * 调整策略：
 * - 负载因子过高时扩展表大小
 * - 负载因子过低时收缩表大小
 * - 保持2的幂次大小以优化哈希计算
 * - 重新哈希所有现有字符串
 * 
 * 触发条件：
 * - 字符串数量超过当前容量的阈值
 * - 垃圾收集后发现大量空闲槽位
 * - 手动调用collectgarbage("collect")
 * 
 * 调整过程：
 * 1. 分配新的哈希表数组
 * 2. 重新计算所有字符串的哈希位置
 * 3. 迁移字符串到新的位置
 * 4. 释放旧的哈希表数组
 * 5. 更新全局状态中的表大小信息
 * 
 * 性能影响：
 * - 调整过程需要O(n)时间，n为字符串数量
 * - 调整后可以改善后续操作的性能
 * - 可能触发垃圾收集
 * 
 * 内存管理：
 * - 临时需要额外内存存储新表
 * - 调整完成后释放旧表内存
 * - 与垃圾收集器协调内存分配
 * 
 * 并发考虑：
 * - 调整过程中字符串表处于不一致状态
 * - 需要适当的同步机制保护
 * - 避免在调整过程中创建新字符串
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param newsize 新的哈希表大小，通常是2的幂次
 * 
 * @note 调整操作可能耗时较长，应避免频繁调用
 * @warning 调整过程中可能分配大量内存，需要考虑内存限制
 * @see luaS_newlstr(), luaC_fullgc()
 */
LUAI_FUNC void luaS_resize(lua_State *L, int newsize);

/**
 * @brief 创建新用户数据：分配并初始化用户自定义数据对象
 * 
 * 详细说明：
 * 这个函数创建一个新的用户数据对象，用于在Lua中存储C程序的自定义数据。
 * 用户数据是Lua提供的扩展机制，允许C代码向Lua传递复杂的数据结构，
 * 并通过元表机制提供面向对象的接口。
 * 
 * 创建过程：
 * 1. 计算所需的内存大小
 * 2. 分配内存并初始化Udata结构
 * 3. 设置用户数据的长度和类型
 * 4. 链接到垃圾收集器管理
 * 5. 设置环境表（如果提供）
 * 
 * 内存布局：
 * - Udata头部：包含GC信息和数据长度
 * - 用户数据区：s字节的用户自定义数据空间
 * - 环境表指针：可选的环境表引用
 * 
 * 数据对齐：
 * - 用户数据区域保证适当的内存对齐
 * - 支持存储指针、结构体等复杂数据
 * - 对齐方式与平台的最大对齐要求一致
 * 
 * 垃圾收集：
 * - 用户数据对象由GC自动管理
 * - 可以设置__gc元方法作为终结器
 * - 支持弱引用和循环引用检测
 * 
 * 环境表：
 * - 可选的环境表提供额外的命名空间
 * - 用于实现面向对象的方法查找
 * - 环境表本身也是GC对象
 * 
 * 元表支持：
 * - 用户数据可以设置元表
 * - 通过元方法实现操作符重载
 * - 支持索引、算术、比较等操作
 * 
 * 使用场景：
 * - 封装C数据结构供Lua使用
 * - 实现面向对象的C扩展
 * - 管理系统资源（文件、网络连接等）
 * - 提供高性能的数据处理接口
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param s 用户数据的大小（字节数），不包括Udata头部
 * @param e 可选的环境表指针，可以为NULL
 * @return 指向新创建的Udata对象的指针
 * 
 * @note 返回的用户数据内容未初始化，调用者需要设置初始值
 * @warning 用户数据的生命周期由垃圾收集器管理
 * @see lua_newuserdata(), luaL_checkudata()
 */
LUAI_FUNC Udata *luaS_newudata(lua_State *L, size_t s, Table *e);

/**
 * @brief 创建新字符串：根据指定内容和长度创建Lua字符串对象
 * 
 * 详细说明：
 * 这是Lua字符串创建系统的核心函数，负责实现字符串内部化机制。
 * 它根据提供的字符内容和长度创建新的字符串对象，或者返回已存在的
 * 相同内容的字符串对象，确保系统中相同内容的字符串只有一份拷贝。
 * 
 * 内部化算法：
 * 1. 计算字符串内容的哈希值
 * 2. 在全局字符串表中查找相同哈希的字符串
 * 3. 逐个比较内容，查找完全匹配的字符串
 * 4. 如果找到，返回已存在的字符串对象
 * 5. 如果没找到，创建新的字符串对象并加入表中
 * 
 * 哈希计算：
 * - 使用高质量的字符串哈希算法
 * - 考虑字符串长度和内容
 * - 分布均匀，减少哈希冲突
 * 
 * 内存管理：
 * - 分配足够内存存储TString结构和字符内容
 * - 复制字符串内容到新分配的内存
 * - 添加字符串终止符保证C兼容性
 * - 链接到垃圾收集器进行生命周期管理
 * 
 * 字符串表管理：
 * - 将新字符串加入全局哈希表
 * - 更新字符串计数和负载因子
 * - 必要时触发哈希表调整
 * 
 * 性能优化：
 * - 短字符串和长字符串使用不同策略
 * - 缓存常用字符串的哈希值
 * - 优化内存分配和复制操作
 * 
 * 特殊处理：
 * - 空字符串的特殊处理
 * - 超长字符串的内存限制检查
 * - 字符串长度的溢出保护
 * 
 * 线程安全：
 * - 每个lua_State有独立的字符串表
 * - 字符串对象创建后不可修改
 * - GC期间的并发访问保护
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param str 指向字符数据的指针，不需要以'\0'结尾
 * @param l 字符串的长度（字节数），可以包含'\0'字符
 * @return 指向TString对象的指针，可能是新创建的或已存在的
 * 
 * @note 字符串内容会被复制，原始数据可以安全释放
 * @note 字符串长度l可以为0，表示空字符串
 * @warning 字符串长度不能超过系统限制
 * @see luaS_new(), luaS_newliteral(), sizestring()
 */
LUAI_FUNC TString *luaS_newlstr(lua_State *L, const char *str, size_t l);

#endif
