/**
 * @file ltm.h
 * @brief Lua标签方法系统接口：实现强大的元编程和操作符重载机制
 * 
 * 详细说明：
 * 这个头文件定义了Lua的标签方法（Tag Methods）系统，也称为元方法
 * （Metamethods）系统。标签方法是Lua实现元编程的核心机制，允许
 * 用户自定义表和用户数据的行为，包括算术运算、比较操作、索引访问、
 * 垃圾收集等。通过元表（metatable）和标签方法的结合，Lua提供了
 * 强大而灵活的面向对象编程支持和自定义类型行为定义。
 * 
 * 系统架构定位：
 * - 位于Lua对象系统的高层，为所有对象提供可定制的行为
 * - 与表系统(ltable)紧密集成，元表本身就是特殊的表
 * - 与虚拟机(lvm)协作，在运行时触发相应的元方法调用
 * - 为垃圾收集器(lgc)提供对象终结(__gc)的支持
 * 
 * 技术特点：
 * - 完整的操作符重载：支持所有算术、比较、逻辑操作
 * - 索引控制：__index和__newindex提供灵活的属性访问
 * - 快速访问优化：常用元方法的缓存和快速查找
 * - 类型无关设计：表和用户数据都支持元方法
 * - 递归保护：防止元方法调用中的无限递归
 * - 性能优化：标志位快速判断元方法是否存在
 * 
 * 依赖关系：
 * - lobject.h: Lua对象系统，提供Table、TValue等核心类型
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 枚举支持：用于标签方法类型的定义
 * - 位操作：用于快速标签方法的标志位处理
 * - 函数指针：支持元方法的动态调用
 * 
 * 使用示例：
 * @code
 * #include "ltm.h"
 * #include "lua.h"
 * 
 * // 创建一个带元表的表
 * lua_State *L = luaL_newstate();
 * 
 * // 创建主表
 * lua_newtable(L);  // 主表在栈顶
 * 
 * // 创建元表
 * lua_newtable(L);  // 元表在栈顶
 * 
 * // 设置 __index 元方法
 * lua_pushstring(L, "__index");
 * lua_pushcfunction(L, my_index_function);
 * lua_settable(L, -3);  // 设置到元表中
 * 
 * // 设置 __add 元方法
 * lua_pushstring(L, "__add");
 * lua_pushcfunction(L, my_add_function);
 * lua_settable(L, -3);
 * 
 * // 将元表设置给主表
 * lua_setmetatable(L, -2);
 * 
 * // 现在主表支持自定义的索引和加法操作
 * 
 * // 检查元方法是否存在
 * Table *t = hvalue(L->top - 1);
 * Table *mt = t->metatable;
 * if (mt != NULL) {
 *     const TValue *tm = luaT_gettm(mt, TM_ADD, G(L)->tmname[TM_ADD]);
 *     if (tm != NULL && !ttisnil(tm)) {
 *         printf("表支持 __add 元方法\n");
 *     }
 * }
 * 
 * lua_close(L);
 * @endcode
 * 
 * 元方法系统架构：
 * - 17种标准元方法：覆盖所有可重载的操作
 * - 元表机制：通过特殊表存储元方法
 * - 快速访问：常用元方法的优化查找
 * - 类型支持：表和用户数据的统一处理
 * 
 * 性能特征：
 * - 快速元方法：O(1)的缓存访问
 * - 标志位优化：快速判断元方法是否存在
 * - 递归检测：避免无限元方法调用
 * - 内存效率：元表共享减少内存使用
 * 
 * 标签方法分类：
 * - 算术运算：__add, __sub, __mul, __div, __mod, __pow, __unm
 * - 比较操作：__eq, __lt, __le
 * - 索引访问：__index, __newindex
 * - 其他操作：__concat, __len, __call
 * - 特殊方法：__gc, __mode
 * 
 * 快速访问机制：
 * - 标志位缓存：每个元表维护标志位指示元方法是否存在
 * - 避免重复查找：已知不存在的元方法直接返回NULL
 * - 性能关键路径：算术和比较操作的优化
 * 
 * 注意事项：
 * - 元方法调用可能递归，需要栈深度控制
 * - 元表的修改会影响快速访问缓存
 * - 某些元方法有特殊的调用语义
 * - __gc元方法与垃圾收集紧密相关
 * 
 * @author Roberto Ierusalimschy
 * @version 2.6.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lobject.h, lvm.h, lgc.h
 */

#ifndef ltm_h
#define ltm_h

#include "lobject.h"

/**
 * @brief 标签方法枚举：定义所有支持的元方法类型
 * 
 * 详细说明：
 * 这个枚举定义了Lua中所有支持的标签方法（元方法）类型。每个
 * 枚举值对应一个特定的操作或事件，当该操作在没有直接实现的
 * 对象上执行时，Lua会查找并调用相应的元方法。
 * 
 * 枚举顺序重要性：
 * - 前5个（TM_INDEX到TM_EQ）是"快速"元方法，有特殊优化
 * - 算术操作元方法集中在一起，便于批量处理
 * - 顺序变更需要搜索"ORDER TM"注释并更新相关代码
 * 
 * 元方法分组：
 * 1. 索引控制组：TM_INDEX, TM_NEWINDEX
 * 2. 特殊操作组：TM_GC, TM_MODE, TM_EQ
 * 3. 算术运算组：TM_ADD到TM_UNM
 * 4. 其他操作组：TM_LEN到TM_CALL
 * 
 * 性能考虑：
 * - 前5个元方法有快速访问路径
 * - 常用操作（如TM_INDEX）放在前面
 * - 枚举值直接用作数组索引
 * 
 * @warning 修改此枚举的顺序需要更新所有相关代码
 * @note 搜索"ORDER TM"可以找到所有依赖顺序的代码
 */
typedef enum {
    /**
     * @brief __index元方法：控制表的索引访问行为
     * 
     * 当访问表中不存在的键时触发。元方法可以是：
     * - 函数：调用function(table, key)，返回值作为访问结果
     * - 表：在该表中查找键，实现继承效果
     * 
     * 应用场景：
     * - 面向对象编程中的继承
     * - 属性的动态计算
     * - 代理表和转发机制
     * - 默认值的提供
     */
    TM_INDEX,

    /**
     * @brief __newindex元方法：控制表的索引赋值行为
     * 
     * 当给表中不存在的键赋值时触发。元方法通常是：
     * - 函数：调用function(table, key, value)进行自定义赋值
     * - 表：在该表中设置键值对
     * 
     * 应用场景：
     * - 只读表的实现
     * - 属性赋值的拦截和验证
     * - 代理对象的写操作
     * - 表修改的监控和日志
     */
    TM_NEWINDEX,

    /**
     * @brief __gc元方法：对象的垃圾收集终结器
     * 
     * 当对象被垃圾收集器回收时调用。元方法是：
     * - 函数：调用function(object)进行清理操作
     * 
     * 特殊性质：
     * - 只能设置给用户数据和表
     * - 在对象回收前的最后机会执行清理
     * - 可以"复活"对象（虽然不推荐）
     * 
     * 应用场景：
     * - 资源清理（文件句柄、网络连接等）
     * - 内存管理和缓存清理
     * - 对象销毁的通知机制
     */
    TM_GC,

    /**
     * @brief __mode元方法：控制表的弱引用模式
     * 
     * 不是真正的元方法，而是元表中的特殊字段。值为字符串：
     * - "k"：键为弱引用
     * - "v"：值为弱引用  
     * - "kv"：键和值都为弱引用
     * 
     * 弱引用特性：
     * - 不阻止垃圾收集器回收引用的对象
     * - 对象被回收后，相应的表项自动清理
     * - 用于实现缓存和临时对象管理
     * 
     * 应用场景：
     * - 对象缓存的实现
     * - 防止内存泄漏
     * - 临时对象的自动清理
     */
    TM_MODE,

    /**
     * @brief __eq元方法：控制相等比较操作
     * 
     * 当使用==或~=比较两个对象时触发。元方法是：
     * - 函数：调用function(op1, op2)，返回布尔值
     * 
     * 特殊规则：
     * - 只有两个操作数都有相同的__eq元方法时才会调用
     * - 这是最后一个"快速访问"元方法
     * 
     * 应用场景：
     * - 自定义对象的相等性定义
     * - 复杂数据结构的比较
     * - 对象身份vs内容相等的区分
     */
    TM_EQ,  /* 最后一个具有'快速'访问的标签方法 */

    /**
     * @brief __add元方法：加法运算符重载
     * 
     * 当使用+操作符时触发。支持：
     * - 数字+对象：调用对象的__add
     * - 对象+数字：调用对象的__add
     * - 对象+对象：优先使用左操作数的__add
     */
    TM_ADD,

    /**
     * @brief __sub元方法：减法运算符重载
     * 
     * 当使用-操作符时触发。处理逻辑类似__add。
     */
    TM_SUB,

    /**
     * @brief __mul元方法：乘法运算符重载
     * 
     * 当使用*操作符时触发。处理逻辑类似__add。
     */
    TM_MUL,

    /**
     * @brief __div元方法：除法运算符重载
     * 
     * 当使用/操作符时触发。处理逻辑类似__add。
     */
    TM_DIV,

    /**
     * @brief __mod元方法：取模运算符重载
     * 
     * 当使用%操作符时触发。处理逻辑类似__add。
     */
    TM_MOD,

    /**
     * @brief __pow元方法：幂运算符重载
     * 
     * 当使用^操作符时触发。处理逻辑类似__add。
     */
    TM_POW,

    /**
     * @brief __unm元方法：一元减号运算符重载
     * 
     * 当使用一元-操作符时触发。元方法是：
     * - 函数：调用function(operand)，返回结果值
     * 
     * 应用场景：
     * - 向量的取反操作
     * - 自定义数值类型的符号反转
     * - 复数等数学对象的负值计算
     */
    TM_UNM,

    /**
     * @brief __len元方法：长度运算符重载
     * 
     * 当使用#操作符时触发。元方法是：
     * - 函数：调用function(object)，返回长度值
     * 
     * 应用场景：
     * - 自定义容器的大小计算
     * - 字符串的字符数统计
     * - 复杂对象的"长度"语义定义
     */
    TM_LEN,

    /**
     * @brief __lt元方法：小于比较运算符重载
     * 
     * 当使用<操作符时触发。元方法是：
     * - 函数：调用function(op1, op2)，返回布尔值
     * 
     * 转换规则：
     * - a > b 转换为 b < a
     * - 只需要实现<，>会自动转换
     */
    TM_LT,

    /**
     * @brief __le元方法：小于等于比较运算符重载
     * 
     * 当使用<=操作符时触发。元方法是：
     * - 函数：调用function(op1, op2)，返回布尔值
     * 
     * 转换规则：
     * - a >= b 转换为 b <= a
     * - 如果没有__le，会尝试使用not (b < a)
     */
    TM_LE,

    /**
     * @brief __concat元方法：字符串连接运算符重载
     * 
     * 当使用..操作符时触发。元方法是：
     * - 函数：调用function(op1, op2)，返回连接结果
     * 
     * 应用场景：
     * - 自定义对象的字符串表示
     * - 复杂数据结构的连接操作
     * - 格式化输出的定制
     */
    TM_CONCAT,

    /**
     * @brief __call元方法：函数调用运算符重载
     * 
     * 当对象作为函数调用时触发。元方法是：
     * - 函数：调用function(object, ...)，传递所有参数
     * 
     * 应用场景：
     * - 可调用对象的实现
     * - 函数对象和闭包的模拟
     * - 面向对象中的函数式接口
     */
    TM_CALL,

    /**
     * @brief 元方法总数：枚举中元素的数量
     * 
     * 这个值表示枚举中定义的元方法总数，用于：
     * - 数组大小的定义
     * - 循环边界的确定
     * - 内存分配的计算
     * 
     * @note 必须保持在枚举的最后位置
     */
    TM_N
} TMS;

/**
 * @brief 全局快速标签方法访问：高性能的元方法查找宏
 * 
 * 详细说明：
 * 这个宏实现了元方法的快速查找机制，通过标志位快速判断元方法
 * 是否存在，避免不必要的表查找操作。这是性能关键路径的重要
 * 优化，特别是对于算术运算和比较操作。
 * 
 * 工作原理：
 * 1. 首先检查元表是否为NULL
 * 2. 检查元表的flags字段中对应的标志位
 * 3. 如果标志位表示元方法不存在，直接返回NULL
 * 4. 否则调用luaT_gettm进行实际查找
 * 
 * 标志位机制：
 * - 每个元表维护一个flags字段
 * - 每个标志位对应一个元方法类型
 * - 设置标志位表示该元方法不存在
 * - 这是一种"负缓存"机制
 * 
 * 性能优化：
 * - 避免重复的表查找操作
 * - 对于不存在的元方法，O(1)时间复杂度
 * - 减少字符串比较和哈希计算
 * 
 * 使用场景：
 * - 虚拟机中的运算操作
 * - 频繁的元方法检查
 * - 性能敏感的代码路径
 * 
 * @param g 全局状态指针，包含元方法名称数组
 * @param et 元表指针，可能为NULL
 * @param e 元方法类型（TMS枚举值）
 * @return 找到的元方法TValue指针，或NULL表示不存在
 * 
 * @note 这是性能关键的宏，使用了多层条件判断优化
 * @warning et参数可能为NULL，宏内部有安全检查
 * @see fasttm(), luaT_gettm()
 */
#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))

/**
 * @brief 快速标签方法访问：基于Lua状态的元方法查找宏
 * 
 * 详细说明：
 * 这是gfasttm宏的便利版本，自动从Lua状态中提取全局状态，
 * 简化了调用接口。在大多数情况下，这是首选的快速元方法
 * 访问方式。
 * 
 * 简化优势：
 * - 自动获取全局状态：不需要手动传递g参数
 * - 代码更简洁：减少参数传递的复杂性
 * - 类型安全：利用Lua状态的类型检查
 * 
 * 使用场景：
 * - 在有lua_State上下文的函数中
 * - 虚拟机指令的执行
 * - 标准库函数的实现
 * 
 * @param l lua_State指针，用于获取全局状态
 * @param et 元表指针，可能为NULL
 * @param e 元方法类型（TMS枚举值）
 * @return 找到的元方法TValue指针，或NULL表示不存在
 * 
 * @note 这是最常用的快速元方法访问宏
 * @see gfasttm(), G()宏
 */
#define fasttm(l,et,e)    gfasttm(G(l), et, e)

/**
 * @brief 类型名称表：所有Lua类型的字符串名称数组
 * 
 * 详细说明：
 * 这个全局常量数组包含了所有Lua基本类型的字符串表示，按照
 * 类型标签的顺序排列。主要用于错误消息、调试输出和类型
 * 检查函数的实现。
 * 
 * 数组内容：
 * - 索引对应lua.h中定义的类型常量
 * - 包含"nil", "boolean", "number", "string"等
 * - 也包含"table", "function", "userdata", "thread"
 * 
 * 使用场景：
 * - type()函数的实现
 * - 错误消息中的类型显示
 * - 调试和日志输出
 * - 类型检查和验证
 * 
 * @note 这是一个外部定义的常量数组
 * @see lua.h中的类型常量定义
 */
LUAI_DATA const char *const luaT_typenames[];

/**
 * @brief 获取标签方法：从元表中查找指定的元方法
 * 
 * 详细说明：
 * 这个函数在指定的元表中查找特定的标签方法。它是元方法系统
 * 的核心查找函数，被各种快速访问宏和虚拟机指令使用。
 * 
 * 查找过程：
 * 1. 在events表中查找ename对应的值
 * 2. 检查找到的值是否为有效的元方法
 * 3. 返回找到的元方法或NULL
 * 
 * 元方法有效性：
 * - 不能是nil值
 * - 通常是函数，但__index和__newindex可以是表
 * - __mode是特殊的字符串值
 * 
 * 性能考虑：
 * - 这是相对重的操作，因此有快速访问宏
 * - 涉及字符串比较和表查找
 * - 结果通常会被缓存以提高性能
 * 
 * 错误处理：
 * - 不存在的元方法返回NULL
 * - 无效的元表参数返回NULL
 * - 不抛出异常，调用者负责检查返回值
 * 
 * @param events 元表指针，包含元方法定义
 * @param event 要查找的元方法类型
 * @param ename 元方法的字符串名称（如"__add"）
 * @return 找到的元方法TValue指针，或NULL表示不存在
 * 
 * @note 这是底层的元方法查找函数
 * @warning events可能为NULL，函数内部有安全检查
 * @see fasttm(), luaT_gettmbyobj()
 */
LUAI_FUNC const TValue *luaT_gettm(Table *events, TMS event, TString *ename);

/**
 * @brief 按对象获取标签方法：根据对象类型查找元方法
 * 
 * 详细说明：
 * 这个函数根据给定对象的类型，在相应的元表中查找指定的标签
 * 方法。它自动处理不同对象类型的元表获取逻辑，提供了统一
 * 的元方法访问接口。
 * 
 * 支持的对象类型：
 * - 表：使用对象自身的元表
 * - 用户数据：使用对象自身的元表
 * - 基本类型：使用全局状态中的基本类型元表
 * 
 * 基本类型元表：
 * - 数字、字符串、布尔值可以有全局元表
 * - 存储在global_State的mt数组中
 * - 所有同类型值共享相同元表
 * 
 * 查找流程：
 * 1. 确定对象的类型
 * 2. 获取对应的元表
 * 3. 在元表中查找指定的元方法
 * 4. 返回找到的元方法或NULL
 * 
 * 错误处理：
 * - 不支持的对象类型返回NULL
 * - 没有元表的对象返回NULL
 * - 元表中不存在指定元方法返回NULL
 * 
 * 性能考虑：
 * - 涉及类型判断和元表访问
 * - 对于基本类型，需要全局状态访问
 * - 结果适合缓存以提高性能
 * 
 * @param L Lua状态机指针，用于访问全局状态
 * @param o 要查找元方法的对象
 * @param event 要查找的元方法类型
 * @return 找到的元方法TValue指针，或NULL表示不存在
 * 
 * @note 这是高层的元方法查找函数
 * @see luaT_gettm(), getmetatable()
 */
LUAI_FUNC const TValue *luaT_gettmbyobj(lua_State *L, const TValue *o, TMS event);

/**
 * @brief 初始化标签方法系统：设置元方法名称和基本类型元表
 * 
 * 详细说明：
 * 这个函数在Lua状态机初始化时被调用，负责设置标签方法系统
 * 的基础数据结构。主要包括元方法名称字符串的创建和基本类型
 * 元表的初始化。
 * 
 * 初始化内容：
 * 1. 创建所有元方法名称的字符串对象
 * 2. 将元方法名称存储到全局状态的tmname数组
 * 3. 初始化基本类型的元表为nil
 * 4. 设置必要的内部标志和状态
 * 
 * 元方法名称：
 * - "__index", "__newindex", "__gc"等
 * - 创建为内部化字符串，提高查找效率
 * - 存储在固定的数组位置，便于快速访问
 * 
 * 基本类型元表：
 * - 数字、字符串、布尔值、nil的元表
 * - 初始为nil，可以通过setmetatable设置
 * - 全局共享，影响所有同类型的值
 * 
 * 内存管理：
 * - 元方法名称字符串会被垃圾收集器管理
 * - 基本类型元表是GC根对象
 * - 初始化失败可能抛出内存错误
 * 
 * 调用时机：
 * - 在lua_newstate()中被调用
 * - 只在状态机创建时调用一次
 * - 必须在其他组件使用元方法之前完成
 * 
 * @param L 要初始化的Lua状态机指针
 * 
 * @note 这个函数只应该在状态机初始化时调用一次
 * @warning 初始化失败可能导致状态机不可用
 * @see lua_newstate(), luaL_newstate()
 */
LUAI_FUNC void luaT_init(lua_State *L);

#endif
