/*
** ====================================================================
** Lua 垃圾回收器模块头文件 (lgc.h)
** ====================================================================
** 
** 文件标识: $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
** 功能描述: Lua 垃圾回收器的核心定义和接口
** 版权信息: 参见 lua.h 中的版权声明
** 
** 模块概述:
** 本头文件定义了 Lua 垃圾回收器的完整实现框架，包括三色标记算法、
** 增量回收机制、写屏障系统和终结器处理。垃圾回收器是 Lua 内存
** 管理的核心，确保自动回收不再使用的对象并处理循环引用。
** 
** 主要功能领域:
** 1. 回收状态管理 - GC 状态机的定义和转换
** 2. 对象标记系统 - 三色标记算法的位操作
** 3. 写屏障机制 - 增量回收的一致性保证
** 4. 弱引用支持 - 弱表和临时引用的处理
** 5. 终结器系统 - 用户数据的资源清理
** 6. 内存阈值控制 - 回收触发和性能调优
** 
** 核心算法:
** - 三色标记清除：白色(未访问)、灰色(待处理)、黑色(已处理)
** - 增量回收：将回收工作分散到多个执行周期
** - 写屏障：维护增量回收过程中的对象图一致性
** - 弱引用：支持缓存和临时数据结构
** - 终结器：确保外部资源的正确清理
** 
** 设计目标:
** - 提供低延迟的增量垃圾回收
** - 支持大型程序的高效内存管理
** - 实现精确的循环引用检测和回收
** - 为用户数据提供可靠的资源管理
** - 提供可调节的性能和内存使用平衡
** 
** 依赖关系:
** - lobject.h: Lua 对象系统和 GCObject 定义
** - lstate.h: 全局状态和 GC 参数管理（间接依赖）
** - lmem.h: 内存分配和释放接口（间接依赖）
** 
** 注意事项:
** - GC 操作可能在任何时候触发，需要考虑重入性
** - 写屏障的正确使用对增量回收的正确性至关重要
** - 终结器可能访问正在回收的对象，需要特殊处理
** - GC 参数的调整会显著影响程序性能特征
** ====================================================================
*/

/*
** ====================================================================
** [预处理] 头文件保护和依赖包含
** ====================================================================
*/

#ifndef lgc_h
#define lgc_h

/*
** ====================================================================
** [依赖] 核心依赖模块包含
** ====================================================================
*/

/*
** [核心依赖] Lua 对象系统
** 
** 包含 lobject.h 以获取：
** - GCObject 联合体定义（垃圾回收对象）
** - GCheader 结构体定义（GC 对象头部）
** - TValue 结构体定义（Lua 值表示）
** - Table、Proto、Closure 等具体对象类型
** - 对象类型标识和类型检查宏
** - 对象转换和访问的辅助宏
*/
#include "lobject.h"


/*
** ====================================================================
** [状态] 垃圾回收器状态常量定义
** ====================================================================
*/

/*
** [状态] 垃圾回收器的可能状态
**
** GC 状态机描述了增量垃圾回收的执行阶段，每个状态代表回收过程中
** 的一个特定阶段，状态间的转换确保了回收工作的有序进行。
*/

/*
** [状态] 暂停状态
**
** 含义：垃圾回收器处于非活动状态
** 
** 状态特征：
** - 不进行任何回收操作
** - 等待回收触发条件
** - 内存分配正常进行
** - 对象创建和修改不受限制
**
** 触发条件：
** - 内存使用量达到回收阈值
** - 手动调用 collectgarbage()
** - 系统内存压力触发回收
**
** 下一状态：GCSpropagate（标记传播阶段）
*/
#define GCSpause	0

/*
** [状态] 标记传播状态
**
** 含义：执行三色标记算法的传播阶段
** 
** 状态特征：
** - 从根对象开始标记可达对象
** - 将灰色对象逐步变为黑色
** - 处理对象间的引用关系
** - 识别循环引用结构
**
** 工作内容：
** - 遍历灰色对象列表
** - 标记直接引用的子对象
** - 维护三色不变性
** - 处理弱引用表的特殊逻辑
**
** 完成条件：灰色对象列表为空
** 下一状态：GCSsweepstring（字符串清除阶段）
*/
#define GCSpropagate	1

/*
** [状态] 字符串清除状态
**
** 含义：清除未标记的字符串对象
** 
** 状态特征：
** - 专门处理字符串对象的回收
** - 字符串有独立的哈希表管理
** - 清理字符串内部化表
** - 释放未引用的字符串内存
**
** 特殊处理：
** - 字符串对象的特殊存储结构
** - 字符串内部化的哈希表清理
** - 字符串缓存的更新
** - 字符串常量池的维护
**
** 完成条件：所有字符串表处理完毕
** 下一状态：GCSsweep（对象清除阶段）
*/
#define GCSsweepstring	2

/*
** [状态] 对象清除状态
**
** 含义：清除其他类型的未标记对象
** 
** 状态特征：
** - 遍历所有非字符串的 GC 对象
** - 释放白色（未标记）对象
** - 调用对象的析构函数
** - 更新对象链表和引用
**
** 处理对象类型：
** - 表（Table）对象
** - 函数（Closure）对象
** - 协程（Thread）对象
** - 用户数据（Userdata）对象
**
** 完成条件：所有对象列表处理完毕
** 下一状态：GCSfinalize（终结器阶段）
*/
#define GCSsweep	3

/*
** [状态] 终结器执行状态
**
** 含义：执行用户数据对象的终结器
** 
** 状态特征：
** - 调用需要终结的用户数据的元方法
** - 处理 __gc 元方法的执行
** - 管理终结器的执行顺序
** - 处理终结器中的异常
**
** 终结器特点：
** - 可能复活被回收的对象
** - 可能创建新的对象和引用
** - 需要多轮回收才能完全清理
** - 可能引发新的回收周期
**
** 完成条件：所有待终结对象处理完毕
** 下一状态：GCSpause（返回暂停状态）
*/
#define GCSfinalize	4


/*
** ====================================================================
** [实用] 位操作工具宏定义
** ====================================================================
*/

/*
** [实用] 有用的位操作技巧
**
** 这些宏提供了高效的位操作接口，用于 GC 标记位的管理。
** 位操作是垃圾回收器性能的关键，需要最大化的执行效率。
*/

/*
** [实用] 位清除操作
**
** 功能：清除指定的位掩码
** @param x: 要操作的值
** @param m: 位掩码
** @return: 清除指定位后的值
**
** 实现：使用按位与操作和掩码取反
** 用途：清除对象的 GC 标记位
*/
#define resetbits(x,m)	((x) &= cast(lu_byte, ~(m)))

/*
** [实用] 位设置操作
**
** 功能：设置指定的位掩码
** @param x: 要操作的值
** @param m: 位掩码
** @return: 设置指定位后的值
**
** 实现：使用按位或操作
** 用途：设置对象的 GC 标记位
*/
#define setbits(x,m)	((x) |= (m))

/*
** [实用] 位测试操作
**
** 功能：测试指定的位掩码
** @param x: 要测试的值
** @param m: 位掩码
** @return: 测试结果（非零表示位被设置）
**
** 实现：使用按位与操作
** 用途：检查对象的 GC 标记状态
*/
#define testbits(x,m)	((x) & (m))

/*
** [实用] 单位掩码生成
**
** 功能：生成指定位的掩码
** @param b: 位位置（0-7）
** @return: 对应位的掩码
**
** 实现：左移操作生成单位掩码
** 用途：为单个位操作生成掩码
*/
#define bitmask(b)	(1<<(b))

/*
** [实用] 双位掩码生成
**
** 功能：生成两个位的组合掩码
** @param b1: 第一个位位置
** @param b2: 第二个位位置
** @return: 两个位的组合掩码
**
** 实现：将两个单位掩码进行按位或
** 用途：为双位操作生成掩码（如白色位）
*/
#define bit2mask(b1,b2)	(bitmask(b1) | bitmask(b2))

/*
** [实用] 单位设置操作
**
** 功能：设置指定位
** @param x: 要操作的值
** @param b: 位位置
**
** 实现：结合 setbits 和 bitmask
** 用途：设置单个 GC 标记位
*/
#define l_setbit(x,b)	setbits(x, bitmask(b))

/*
** [实用] 单位清除操作
**
** 功能：清除指定位
** @param x: 要操作的值
** @param b: 位位置
**
** 实现：结合 resetbits 和 bitmask
** 用途：清除单个 GC 标记位
*/
#define resetbit(x,b)	resetbits(x, bitmask(b))

/*
** [实用] 单位测试操作
**
** 功能：测试指定位
** @param x: 要测试的值
** @param b: 位位置
** @return: 测试结果
**
** 实现：结合 testbits 和 bitmask
** 用途：检查单个 GC 标记位
*/
#define testbit(x,b)	testbits(x, bitmask(b))

/*
** [实用] 双位设置操作
**
** 功能：同时设置两个位
** @param x: 要操作的值
** @param b1: 第一个位位置
** @param b2: 第二个位位置
**
** 实现：结合 setbits 和 bit2mask
** 用途：设置白色标记的两个位
*/
#define set2bits(x,b1,b2)	setbits(x, (bit2mask(b1, b2)))

/*
** [实用] 双位清除操作
**
** 功能：同时清除两个位
** @param x: 要操作的值
** @param b1: 第一个位位置
** @param b2: 第二个位位置
**
** 实现：结合 resetbits 和 bit2mask
** 用途：清除白色标记的两个位
*/
#define reset2bits(x,b1,b2)	resetbits(x, (bit2mask(b1, b2)))

/*
** [实用] 双位测试操作
**
** 功能：测试两个位的状态
** @param x: 要测试的值
** @param b1: 第一个位位置
** @param b2: 第二个位位置
** @return: 测试结果
**
** 实现：结合 testbits 和 bit2mask
** 用途：检查白色标记的状态
*/
#define test2bits(x,b1,b2)	testbits(x, (bit2mask(b1, b2)))



/*
** ====================================================================
** [标记] GC 标记位布局和定义
** ====================================================================
*/

/*
** [标记] marked 字段中的位使用布局：
**
** 位 0 - 对象是白色（类型 0）
** 位 1 - 对象是白色（类型 1）  
** 位 2 - 对象是黑色
** 位 3 - 用户数据：已经终结 / 表：有弱键
** 位 4 - 表：有弱值
** 位 5 - 对象是固定的（不应被回收）
** 位 6 - 对象是"超级"固定的（仅主线程）
**
** 三色标记算法：
** - 白色：未访问或不可达的对象，将被回收
** - 灰色：已发现但未完全处理的对象
** - 黑色：已完全处理的对象，不会被回收
**
** 双白色机制：
** - 使用两种白色类型实现增量回收
** - 在回收周期间切换当前白色类型
** - 新分配对象使用当前白色标记
** - 上一周期的白色对象将被回收
*/

/*
** [标记] 白色类型 0 位定义
** 用于双白色机制的第一种白色类型
*/
#define WHITE0BIT	0

/*
** [标记] 白色类型 1 位定义
** 用于双白色机制的第二种白色类型
*/
#define WHITE1BIT	1

/*
** [标记] 黑色标记位定义
** 表示对象已完全标记，不会被回收
*/
#define BLACKBIT	2

/*
** [标记] 终结标记位定义（用户数据）
** 表示用户数据对象已经执行过终结器
** 与 KEYWEAKBIT 共享同一位置，但用于不同对象类型
*/
#define FINALIZEDBIT	3

/*
** [标记] 弱键标记位定义（表对象）
** 表示表对象具有弱引用的键
** 与 FINALIZEDBIT 共享同一位置，但用于不同对象类型
*/
#define KEYWEAKBIT	3

/*
** [标记] 弱值标记位定义（表对象）
** 表示表对象具有弱引用的值
*/
#define VALUEWEAKBIT	4

/*
** [标记] 固定对象标记位定义
** 表示对象不应被垃圾回收器回收
** 用于重要的系统对象和用户指定的固定对象
*/
#define FIXEDBIT	5

/*
** [标记] 超级固定对象标记位定义
** 表示对象绝对不能被回收（如主线程）
** 具有比 FIXEDBIT 更高的固定优先级
*/
#define SFIXEDBIT	6

/*
** [标记] 白色位组合掩码
** 用于同时操作两个白色标记位
** 支持双白色机制的实现
*/
#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)


/*
** ====================================================================
** [检测] 对象颜色检测宏定义
** ====================================================================
*/

/*
** [检测] 白色对象检测宏
**
** 功能：检测对象是否为白色（任一种白色类型）
** @param x: GCObject* 要检测的垃圾回收对象
** @return: 非零值表示对象为白色
**
** 实现原理：
** - 测试对象的两个白色标记位
** - 任一白色位被设置即认为是白色
** - 白色对象是未标记或将被回收的对象
**
** 使用场景：
** - 确定对象是否需要标记
** - 回收阶段识别可回收对象
** - 写屏障中的颜色检查
*/
#define iswhite(x)      test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)

/*
** [检测] 黑色对象检测宏
**
** 功能：检测对象是否为黑色
** @param x: GCObject* 要检测的垃圾回收对象
** @return: 非零值表示对象为黑色
**
** 实现原理：
** - 测试对象的黑色标记位
** - 黑色对象是已完全标记的对象
** - 黑色对象不会被回收
**
** 使用场景：
** - 写屏障中检查对象状态
** - 标记阶段跳过已处理对象
** - 确定对象的可达性状态
*/
#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)

/*
** [检测] 灰色对象检测宏
**
** 功能：检测对象是否为灰色
** @param x: GCObject* 要检测的垃圾回收对象
** @return: 非零值表示对象为灰色
**
** 实现原理：
** - 既不是黑色也不是白色的对象
** - 灰色对象是已发现但未完全标记的对象
** - 灰色对象在待处理队列中
**
** 使用场景：
** - 标记传播阶段的对象处理
** - 确定标记工作的进度
** - 写屏障中的状态检查
*/
#define isgray(x)	(!isblack(x) && !iswhite(x))

/*
** ====================================================================
** [管理] 白色类型管理和死对象检测
** ====================================================================
*/

/*
** [管理] 另一种白色类型获取宏
**
** 功能：获取与当前白色相对的另一种白色类型
** @param g: global_State* 全局状态指针
** @return: 另一种白色类型的标记
**
** 实现原理：
** - 使用异或操作切换白色类型
** - 双白色机制的核心操作
** - 支持增量回收的白色切换
**
** 用途：
** - 回收周期间的白色类型切换
** - 识别上一周期的白色对象
** - 新对象的白色类型设置
*/
#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)

/*
** [管理] 死对象检测宏
**
** 功能：检测对象是否为死对象（将被回收）
** @param g: global_State* 全局状态指针
** @param v: GCObject* 要检测的对象
** @return: 非零值表示对象已死
**
** 实现原理：
** - 检查对象是否标记为另一种白色类型
** - 另一种白色类型的对象是上一周期的白色
** - 这些对象将在当前回收周期被清除
**
** 使用场景：
** - 清除阶段识别可回收对象
** - 弱引用表的清理
** - 对象生命周期管理
*/
#define isdead(g,v)	((v)->gch.marked & otherwhite(g) & WHITEBITS)

/*
** ====================================================================
** [操作] 对象标记状态修改宏
** ====================================================================
*/

/*
** [操作] 白色类型切换宏
**
** 功能：切换对象的白色类型
** @param x: GCObject* 要操作的对象
**
** 实现原理：
** - 使用异或操作翻转白色标记位
** - 将白色类型 0 变为类型 1，反之亦然
** - 保持对象的白色状态不变
**
** 使用场景：
** - 回收周期开始时更新白色类型
** - 对象复活时的标记更新
** - 白色类型的标准化处理
*/
#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)

/*
** [操作] 灰色转黑色宏
**
** 功能：将灰色对象标记为黑色
** @param x: GCObject* 要操作的对象
**
** 实现原理：
** - 设置对象的黑色标记位
** - 表示对象已完全标记
** - 标记传播过程的核心操作
**
** 使用场景：
** - 标记传播阶段完成对象处理
** - 对象从灰色列表移到黑色状态
** - 标记算法的进度推进
*/
#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)

/*
** ====================================================================
** [检测] 值和全局状态检测宏
** ====================================================================
*/

/*
** [检测] 值白色检测宏
**
** 功能：检测 TValue 中的对象是否为白色
** @param x: TValue* 要检测的 Lua 值
** @return: 非零值表示值为白色可回收对象
**
** 实现原理：
** - 首先检查值是否为可回收类型
** - 然后检查对应 GC 对象是否为白色
** - 组合检查确保安全性
**
** 使用场景：
** - 写屏障中检查引用的目标
** - 确定是否需要触发屏障操作
** - 值赋值时的 GC 安全检查
*/
#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))

/*
** [检测] 全局白色类型获取宏
**
** 功能：获取当前全局状态的白色类型
** @param g: global_State* 全局状态指针
** @return: 当前白色类型的标记
**
** 实现原理：
** - 提取当前白色类型的标记位
** - 用于新对象的白色标记设置
** - 保持白色类型的一致性
**
** 使用场景：
** - 新对象创建时的初始标记
** - 白色类型的标准化处理
** - GC 状态的查询接口
*/
#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)


/*
** ====================================================================
** [宏定义] GC 检查和写屏障宏
** ====================================================================
*/

/*
** [检查] GC 触发检查宏
**
** 功能：检查是否需要触发垃圾回收
** @param L: lua_State* Lua 状态机指针
**
** 实现机制：
** - 条件性地重新分配栈空间（用于测试）
** - 检查总内存字节数是否达到 GC 阈值
** - 达到阈值时执行一步 GC 操作
**
** 触发条件：
** - 内存分配导致总使用量超过阈值
** - 手动内存检查调用
** - 关键操作前的安全检查
**
** 优化考虑：
** - 轻量级检查，最小化性能影响
** - 增量执行，避免长时间暂停
** - 条件编译支持测试模式
*/
#define luaC_checkGC(L) { \
  condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); \
  if (G(L)->totalbytes >= G(L)->GCthreshold) \
	luaC_step(L); }

/*
** ====================================================================
** [屏障] 写屏障宏定义系列
** ====================================================================
*/

/*
** [屏障] 通用写屏障宏
**
** 功能：在对象赋值时维护 GC 一致性
** @param L: lua_State* Lua 状态机指针
** @param p: 父对象指针（被赋值的对象）
** @param v: TValue* 新值（可能包含 GC 对象）
**
** 触发条件：
** - 新值是白色的可回收对象
** - 父对象是黑色的（已标记）
**
** 屏障动作：
** - 调用前向屏障函数
** - 确保引用关系的正确标记
** - 维护三色不变性
**
** 使用场景：
** - 变量赋值操作
** - 对象字段设置
** - 数组元素赋值
*/
#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
	luaC_barrierf(L,obj2gco(p),gcvalue(v)); }

/*
** [屏障] 表专用写屏障宏
**
** 功能：表对象修改时的写屏障
** @param L: lua_State* Lua 状态机指针
** @param t: Table* 表对象指针
** @param v: TValue* 新值
**
** 特殊处理：
** - 针对表对象的优化实现
** - 使用反向屏障策略
** - 将黑色表变回灰色状态
**
** 反向屏障优势：
** - 减少屏障操作的频率
** - 更适合表的修改模式
** - 避免深度标记传播
**
** 适用场景：
** - 表键值对设置
** - 表结构修改操作
** - 表的批量更新
*/
#define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t)))  \
	luaC_barrierback(L,t); }

/*
** [屏障] 对象间引用写屏障宏
**
** 功能：处理对象间直接引用的写屏障
** @param L: lua_State* Lua 状态机指针
** @param p: 父对象指针（引用源）
** @param o: 子对象指针（引用目标）
**
** 触发条件：
** - 子对象是白色的
** - 父对象是黑色的
**
** 屏障策略：
** - 使用前向屏障
** - 标记目标对象
** - 确保引用的可达性
**
** 使用场景：
** - 对象引用赋值
** - 数据结构链接
** - 对象关系建立
*/
#define luaC_objbarrier(L,p,o)  \
	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
		luaC_barrierf(L,obj2gco(p),obj2gco(o)); }

/*
** [屏障] 表对象引用写屏障宏
**
** 功能：表对象引用其他对象时的写屏障
** @param L: lua_State* Lua 状态机指针
** @param t: Table* 表对象指针
** @param o: 被引用对象指针
**
** 特殊处理：
** - 结合表的特性使用反向屏障
** - 将表对象变回灰色
** - 重新加入标记队列
**
** 优化原理：
** - 表对象通常有多个引用
** - 反向屏障减少重复操作
** - 批量处理表的所有引用
**
** 适用场景：
** - 表作为容器引用对象
** - 复杂数据结构的构建
** - 对象关系网络的建立
*/
#define luaC_objbarriert(L,t,o)  \
   { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }

/*
** ====================================================================
** [函数] GC 核心函数声明
** ====================================================================
*/

/*
** [管理] 用户数据分离函数
**
** 功能：分离需要终结的用户数据对象
** @param L: lua_State* Lua 状态机指针
** @param all: int 是否处理所有用户数据（0=仅待终结的，1=全部）
** @return: size_t 分离的用户数据数量
**
** 分离过程：
** - 扫描用户数据对象列表
** - 识别有 __gc 元方法的对象
** - 将这些对象移到待终结列表
** - 准备终结器的执行环境
**
** 调用时机：
** - GC 清除阶段开始时
** - 强制垃圾回收时
** - 系统关闭清理时
*/
LUAI_FUNC size_t luaC_separateudata (lua_State *L, int all);

/*
** [管理] GC 终结器调用函数
**
** 功能：执行对象的垃圾回收终结器
** @param L: lua_State* Lua 状态机指针
**
** 执行过程：
** - 遍历待终结对象列表
** - 安全调用每个对象的 __gc 元方法
** - 处理终结器执行中的异常
** - 管理对象的复活和重新标记
**
** 安全机制：
** - 终结器异常不影响 GC 进程
** - 防止终结器的无限递归
** - 保护 GC 状态的一致性
*/
LUAI_FUNC void luaC_callGCTM (lua_State *L);

/*
** [管理] 完全内存释放函数
**
** 功能：释放所有 GC 管理的对象和内存
** @param L: lua_State* Lua 状态机指针
**
** 释放过程：
** - 强制执行所有待定的终结器
** - 释放所有 GC 对象的内存
** - 清理所有内部数据结构
** - 重置 GC 状态到初始状态
**
** 使用场景：
** - Lua 状态机关闭时
** - 严重错误后的内存清理
** - 内存调试和测试
*/
LUAI_FUNC void luaC_freeall (lua_State *L);

/*
** [核心] GC 步进执行函数
**
** 功能：执行一步增量垃圾回收
** @param L: lua_State* Lua 状态机指针
**
** 执行特点：
** - 根据当前 GC 状态执行相应操作
** - 控制每步执行的工作量
** - 在各 GC 阶段间进行状态转换
** - 平衡回收效率和程序响应性
**
** 状态转换：
** - 根据工作完成情况决定下一状态
** - 处理各阶段的特殊逻辑
** - 管理 GC 的整体进度
*/
LUAI_FUNC void luaC_step (lua_State *L);

/*
** [管理] 完整 GC 周期函数
**
** 功能：执行一次完整的垃圾回收周期
** @param L: lua_State* Lua 状态机指针
**
** 完整周期：
** - 从当前状态开始执行
** - 依次通过所有 GC 阶段
** - 直到回到暂停状态
** - 清理所有可回收对象
**
** 使用场景：
** - 显式 collectgarbage() 调用
** - 内存压力时的强制回收
** - 性能敏感操作前的清理
*/
LUAI_FUNC void luaC_fullgc (lua_State *L);

/*
** [管理] 对象链接到 GC 函数
**
** 功能：将新创建的对象链接到 GC 管理链表
** @param L: lua_State* Lua 状态机指针
** @param o: GCObject* 要链接的对象
** @param tt: lu_byte 对象类型标识
**
** 链接过程：
** - 将对象添加到相应的 GC 链表
** - 设置对象的初始 GC 标记
** - 建立对象与 GC 系统的管理关系
** - 更新 GC 统计信息
**
** 调用时机：
** - 所有 GC 对象创建时
** - 对象类型转换时
** - 对象重新初始化时
*/
LUAI_FUNC void luaC_link (lua_State *L, GCObject *o, lu_byte tt);

/*
** [管理] UpValue 对象链接函数
**
** 功能：将 UpValue 对象链接到 GC 系统
** @param L: lua_State* Lua 状态机指针
** @param uv: UpVal* 要链接的 UpValue 对象
**
** 特殊处理：
** - UpValue 有特殊的生命周期管理
** - 需要处理闭包的引用关系
** - 管理 UpValue 的开放/关闭状态
** - 设置适当的写屏障保护
**
** UpValue 特点：
** - 可能在多个闭包间共享
** - 有复杂的引用和生命周期
** - 需要特殊的 GC 处理逻辑
*/
LUAI_FUNC void luaC_linkupval (lua_State *L, UpVal *uv);

/*
** [屏障] 前向写屏障函数
**
** 功能：执行前向写屏障操作
** @param L: lua_State* Lua 状态机指针
** @param o: GCObject* 引用源对象
** @param v: GCObject* 引用目标对象
**
** 前向屏障策略：
** - 标记目标对象为灰色
** - 将目标对象加入标记队列
** - 确保引用的可达性传播
** - 维护三色标记不变性
**
** 使用场景：
** - 一般对象的引用赋值
** - 数据结构的构建
** - 对象关系的建立
*/
LUAI_FUNC void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);

/*
** [屏障] 反向写屏障函数
**
** 功能：执行反向写屏障操作
** @param L: lua_State* Lua 状态机指针
** @param t: Table* 表对象指针
**
** 反向屏障策略：
** - 将黑色表对象变回灰色
** - 重新加入标记传播队列
** - 延迟标记表的所有引用
** - 优化表的修改性能
**
** 适用场景：
** - 表对象的频繁修改
** - 批量数据插入操作
** - 复杂表结构的构建
*/
LUAI_FUNC void luaC_barrierback (lua_State *L, Table *t);


#endif
