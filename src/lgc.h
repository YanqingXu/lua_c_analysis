/**
 * @file lgc.h
 * @brief Lua垃圾收集器接口：实现高效的三色标记增量垃圾收集算法
 * 
 * 详细说明：
 * 这个头文件定义了Lua解释器的垃圾收集器核心接口，实现了基于三色标记的
 * 增量垃圾收集算法。它负责自动管理Lua对象的生命周期，包括字符串、表、
 * 函数、线程、用户数据等所有可收集的对象，确保内存的高效利用和及时回收。
 * 
 * 系统架构定位：
 * - 位于Lua解释器的核心层，与内存管理器(lmem)紧密配合
 * - 为所有Lua对象提供统一的生命周期管理服务
 * - 与Lua虚拟机状态(lstate)集成，支持多线程环境下的GC
 * - 与对象系统(lobject)协作，管理所有可收集对象的标记状态
 * 
 * 技术特点：
 * - 三色标记算法：白色(未访问)、灰色(已访问未扫描)、黑色(已扫描)
 * - 增量垃圾收集：分阶段执行，减少GC停顿时间
 * - 写屏障机制：维护增量GC的正确性，防止对象丢失
 * - 弱引用支持：支持弱键表和弱值表，避免循环引用
 * - 终结器管理：自动调用用户数据的析构函数
 * - 高效位操作：使用位掩码和位运算优化性能
 * 
 * 依赖关系：
 * - lobject.h: Lua对象系统，定义GCObject和对象类型
 * - lua.h: Lua核心接口，定义lua_State和基础类型
 * - lstate.h: Lua状态管理，提供全局状态和GC参数
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 位操作支持：依赖标准的位运算操作符
 * - 类型转换：需要cast宏进行安全的类型转换
 * 
 * 使用示例：
 * @code
 * #include "lgc.h"
 * #include "lua.h"
 * 
 * // 创建新对象并链接到GC链表
 * MyObject *obj = luaM_new(L, MyObject);
 * luaC_link(L, obj2gco(obj), LUA_TUSERDATA);
 * 
 * // 检查是否需要触发GC
 * luaC_checkGC(L);
 * 
 * // 设置写屏障（当黑色对象引用白色对象时）
 * if (valiswhite(value) && isblack(obj2gco(container))) {
 *     luaC_barrier(L, container, value);
 * }
 * 
 * // 手动触发完整的垃圾收集
 * luaC_fullgc(L);
 * @endcode
 * 
 * 垃圾收集算法：
 * - 标记阶段：从根对象开始，标记所有可达对象
 * - 传播阶段：扫描灰色对象，将其引用的白色对象标记为灰色
 * - 清扫阶段：回收所有白色对象的内存
 * - 终结阶段：调用用户数据的终结器函数
 * 
 * 性能特征：
 * - 增量收集：分多个步骤执行，每步耗时可控
 * - 低停顿时间：避免长时间的GC停顿
 * - 内存效率：及时回收不可达对象，减少内存峰值
 * - 自适应调整：根据内存分配速度调整GC频率
 * 
 * 线程安全性：
 * - 单线程设计：每个lua_State独立进行垃圾收集
 * - 多线程环境：不同线程的lua_State之间GC互不影响
 * - 协程支持：正确处理协程的栈和局部变量
 * 
 * 注意事项：
 * - GC可能在任何内存分配时触发，C函数需要保护临时对象
 * - 写屏障是性能关键，必须在对象关系建立时正确设置
 * - 弱引用表的行为依赖于GC时机，需要注意语义差异
 * - 终结器的执行顺序不确定，不应依赖特定的调用顺序
 * 
 * @author Roberto Ierusalimschy
 * @version 2.15.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lobject.h, lmem.h, lstate.h
 */

#ifndef lgc_h
#define lgc_h

#include "lobject.h"

/**
 * @brief 垃圾收集器状态定义：描述GC算法的各个执行阶段
 * 
 * 详细说明：
 * Lua的垃圾收集器采用增量收集策略，将收集过程分为多个阶段。
 * 每个阶段执行特定的任务，通过状态机模式控制整个收集流程。
 * 这种设计可以将GC工作分散到多个时间片中，减少单次停顿时间。
 * 
 * 阶段转换流程：
 * GCSpause → GCSpropagate → GCSsweepstring → GCSsweep → GCSfinalize → GCSpause
 * 
 * 性能考虑：
 * - 每个阶段的工作量可以独立控制
 * - 支持根据可用时间动态调整每阶段的工作量
 * - 在关键路径上最小化GC对程序执行的影响
 */

/**
 * @brief GC暂停状态：垃圾收集器处于非活动状态
 * 
 * 在此状态下，垃圾收集器不执行任何收集工作，只是等待下一次
 * 收集周期的开始。当内存分配达到阈值时，会从此状态转入传播阶段。
 */
#define GCSpause        0

/**
 * @brief GC传播状态：标记阶段，遍历对象引用关系
 * 
 * 在此状态下，垃圾收集器从根对象开始，沿着引用链标记所有可达对象。
 * 这是三色标记算法的核心阶段，将白色对象标记为灰色，灰色对象标记为黑色。
 */
#define GCSpropagate    1

/**
 * @brief GC字符串清扫状态：回收不可达的字符串对象
 * 
 * 字符串在Lua中有特殊的管理方式，使用哈希表进行全局唯一化。
 * 此阶段专门清理字符串哈希表中的不可达字符串，释放其占用的内存。
 */
#define GCSsweepstring  2

/**
 * @brief GC对象清扫状态：回收所有其他类型的不可达对象
 * 
 * 在此状态下，遍历所有对象链表，回收标记为白色的不可达对象。
 * 这包括表、函数、用户数据、线程等除字符串外的所有对象类型。
 */
#define GCSsweep        3

/**
 * @brief GC终结状态：执行用户数据的终结器函数
 * 
 * 对于有终结器的用户数据，在回收前需要调用其__gc元方法。
 * 此阶段负责调用这些终结器，确保资源的正确清理。
 */
#define GCSfinalize     4

/**
 * @brief 位操作工具宏集合：提供高效的位掩码操作功能
 * 
 * 详细说明：
 * 这些宏提供了一套完整的位操作工具，用于管理对象的标记位。
 * 垃圾收集器大量使用位运算来存储对象状态，这些宏确保了
 * 位操作的正确性和代码的可读性。
 * 
 * 设计理念：
 * - 类型安全：使用cast确保类型转换的安全性
 * - 性能优化：编译时展开，零运行时开销
 * - 代码复用：提供基础操作，由高级宏组合使用
 * 
 * 位操作模式：
 * - 原子操作：每个宏执行单一的位操作任务
 * - 组合操作：支持多位同时操作，提高效率
 * - 掩码操作：使用位掩码进行批量位操作
 */

/**
 * @brief 重置指定位：将目标位设置为0
 * 
 * 使用按位与和按位非操作来清除指定的位。这是位操作的基础操作之一，
 * 用于清除对象标记中的特定状态位。
 * 
 * @param x 目标变量，其位将被修改
 * @param m 位掩码，指定要清除的位
 */
#define resetbits(x, m)    ((x) &= cast(lu_byte, ~(m)))

/**
 * @brief 设置指定位：将目标位设置为1
 * 
 * 使用按位或操作来设置指定的位。这是设置对象状态的基础操作，
 * 用于标记对象的特定属性或状态。
 * 
 * @param x 目标变量，其位将被修改
 * @param m 位掩码，指定要设置的位
 */
#define setbits(x, m)      ((x) |= (m))

/**
 * @brief 测试指定位：检查目标位是否为1
 * 
 * 使用按位与操作来测试指定的位。返回非零值表示位已设置，
 * 零值表示位未设置。这是查询对象状态的基础操作。
 * 
 * @param x 目标变量
 * @param m 位掩码，指定要测试的位
 * @return 非零值表示位已设置，0表示位未设置
 */
#define testbits(x, m)     ((x) & (m))

/**
 * @brief 生成单位掩码：创建只有指定位为1的掩码
 * 
 * 通过左移操作生成单一位的掩码。这是构建复杂位掩码的基础工具，
 * 确保位索引的正确转换。
 * 
 * @param b 位索引（0-7）
 * @return 只有第b位为1的掩码
 */
#define bitmask(b)         (1 << (b))

/**
 * @brief 生成双位掩码：创建两个指定位都为1的掩码
 * 
 * 通过组合两个单位掩码生成双位掩码。这在处理需要同时操作
 * 两个相关位的场景中非常有用，如白色位的管理。
 * 
 * @param b1 第一个位索引
 * @param b2 第二个位索引
 * @return 第b1位和第b2位都为1的掩码
 */
#define bit2mask(b1, b2)   (bitmask(b1) | bitmask(b2))

/**
 * @brief 设置单个位：设置指定索引的位为1
 * 
 * 结合bitmask和setbits的功能，直接通过位索引设置位。
 * 这提供了更直观的位设置接口。
 * 
 * @param x 目标变量
 * @param b 要设置的位索引
 */
#define l_setbit(x, b)     setbits(x, bitmask(b))

/**
 * @brief 重置单个位：清除指定索引的位
 * 
 * 结合bitmask和resetbits的功能，直接通过位索引清除位。
 * 这提供了更直观的位清除接口。
 * 
 * @param x 目标变量
 * @param b 要清除的位索引
 */
#define resetbit(x, b)     resetbits(x, bitmask(b))

/**
 * @brief 测试单个位：检查指定索引的位状态
 * 
 * 结合bitmask和testbits的功能，直接通过位索引测试位。
 * 这提供了更直观的位测试接口。
 * 
 * @param x 目标变量
 * @param b 要测试的位索引
 * @return 非零值表示位已设置，0表示位未设置
 */
#define testbit(x, b)      testbits(x, bitmask(b))

/**
 * @brief 设置两个位：同时设置两个指定位为1
 * 
 * 使用双位掩码同时设置两个位，这在需要原子性设置
 * 相关状态位时非常有用。
 * 
 * @param x 目标变量
 * @param b1 第一个位索引
 * @param b2 第二个位索引
 */
#define set2bits(x, b1, b2)    setbits(x, (bit2mask(b1, b2)))

/**
 * @brief 重置两个位：同时清除两个指定位
 * 
 * 使用双位掩码同时清除两个位，确保相关状态位的
 * 原子性更新。
 * 
 * @param x 目标变量
 * @param b1 第一个位索引
 * @param b2 第二个位索引
 */
#define reset2bits(x, b1, b2)  resetbits(x, (bit2mask(b1, b2)))

/**
 * @brief 测试两个位：检查两个位是否都已设置
 * 
 * 使用双位掩码测试两个位的状态，只有当两个位都设置时
 * 才返回真值。这用于检查复合状态。
 * 
 * @param x 目标变量
 * @param b1 第一个位索引
 * @param b2 第二个位索引
 * @return 两个位都设置时返回非零值，否则返回0
 */
#define test2bits(x, b1, b2)   testbits(x, (bit2mask(b1, b2)))

/**
 * @brief 对象标记位布局：定义marked字段中各位的含义和用途
 * 
 * 详细说明：
 * Lua对象的marked字段是一个字节，其中每一位都有特定的含义。
 * 这种紧凑的设计最大化了空间利用率，同时提供了丰富的状态信息。
 * 
 * 三色标记算法：
 * - 白色对象：未被访问的对象，有两种类型以支持增量收集
 * - 灰色对象：已被访问但尚未扫描其引用的对象
 * - 黑色对象：已被访问且已扫描其所有引用的对象
 * 
 * 特殊标记：
 * - 终结标记：用于用户数据，表示已调用过终结器
 * - 弱引用标记：用于表，表示键或值是弱引用
 * - 固定标记：表示对象不应被收集（如预定义对象）
 * 
 * 位布局设计原则：
 * - 位0-1：白色类型，支持两种白色以实现增量收集
 * - 位2：黑色标记，与白色位互斥
 * - 位3：多用途位，根据对象类型有不同含义
 * - 位4：表的弱值标记
 * - 位5-6：固定位，防止重要对象被误收集
 * 
 * 位使用策略：
 * - bit 0：对象是白色（类型0） - 当前收集周期的白色
 * - bit 1：对象是白色（类型1） - 下一收集周期的白色
 * - bit 2：对象是黑色 - 已完成扫描的对象
 * - bit 3：用户数据-已终结 / 表-弱键标记
 * - bit 4：表的弱值标记
 * - bit 5：对象固定（不应被收集）
 * - bit 6：对象超级固定（仅主线程使用）
 */

/**
 * @brief 白色类型0位索引：第一种白色标记
 */
#define WHITE0BIT       0

/**
 * @brief 白色类型1位索引：第二种白色标记
 */
#define WHITE1BIT       1

/**
 * @brief 黑色位索引：已扫描对象的标记
 */
#define BLACKBIT        2

/**
 * @brief 终结位索引：用户数据的终结状态标记
 */
#define FINALIZEDBIT    3

/**
 * @brief 弱键位索引：表的弱键引用标记
 */
#define KEYWEAKBIT      3

/**
 * @brief 弱值位索引：表的弱值引用标记
 */
#define VALUEWEAKBIT    4

/**
 * @brief 固定位索引：防止对象被收集的标记
 */
#define FIXEDBIT        5

/**
 * @brief 超级固定位索引：主线程专用的固定标记
 */
#define SFIXEDBIT       6

/**
 * @brief 白色位掩码：包含两种白色类型的组合掩码
 */
#define WHITEBITS       bit2mask(WHITE0BIT, WHITE1BIT)

/**
 * @brief 对象颜色检测宏集合：实现三色标记算法的颜色判断
 * 
 * 详细说明：
 * 这些宏实现了三色标记算法中的颜色检测逻辑。通过检查对象的
 * marked字段中的特定位，可以快速判断对象的当前状态。
 * 
 * 三色语义：
 * - 白色：未访问或不可达的对象，将被回收
 * - 灰色：已访问但未完全扫描的对象，需要进一步处理
 * - 黑色：已完全扫描的对象，其所有引用都已处理
 * 
 * 增量收集支持：
 * - 使用两种白色类型支持增量收集
 * - 在收集过程中可以区分新分配和旧对象
 * - 避免增量收集过程中的对象丢失
 */

/**
 * @brief 检查对象是否为白色：未访问或不可达状态
 * 
 * 白色对象是垃圾收集的候选对象。如果在标记阶段结束后
 * 对象仍为白色，说明它不可达，应该被回收。
 * 
 * @param x 指向GCObject的指针
 * @return 非零值表示对象为白色，0表示不是白色
 */
#define iswhite(x)      test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)

/**
 * @brief 检查对象是否为黑色：已完全扫描状态
 * 
 * 黑色对象是已经完成扫描的对象，其所有引用都已被处理。
 * 黑色对象不会再被扫描，直到下一个收集周期。
 * 
 * @param x 指向GCObject的指针
 * @return 非零值表示对象为黑色，0表示不是黑色
 */
#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)

/**
 * @brief 检查对象是否为灰色：已访问但未完全扫描状态
 * 
 * 灰色对象是标记过程中的中间状态，表示对象已被访问但
 * 其引用的对象尚未全部处理。灰色对象需要进一步扫描。
 * 
 * 灰色的定义：既不是黑色也不是白色的对象
 * 
 * @param x 指向GCObject的指针
 * @return 非零值表示对象为灰色，0表示不是灰色
 */
#define isgray(x)       (!isblack(x) && !iswhite(x))

/**
 * @brief 获取另一种白色：用于双白色增量收集算法
 * 
 * 在增量收集中，使用两种白色来区分不同收集周期的对象。
 * 这个宏返回与当前白色不同的另一种白色类型。
 * 
 * @param g 指向global_State的指针
 * @return 另一种白色的位模式
 */
#define otherwhite(g)   (g->currentwhite ^ WHITEBITS)

/**
 * @brief 检查对象是否死亡：对象是否应该被回收
 * 
 * 死亡对象是标记为"另一种白色"的对象，即在当前收集周期中
 * 没有被访问到的对象。这些对象将在清扫阶段被回收。
 * 
 * @param g 指向global_State的指针
 * @param v 指向要检查的对象
 * @return 非零值表示对象已死亡，0表示对象仍存活
 */
#define isdead(g, v)    ((v)->gch.marked & otherwhite(g) & WHITEBITS)

/**
 * @brief 改变对象的白色类型：在两种白色之间切换
 * 
 * 这个宏通过异或操作在两种白色类型之间切换，用于
 * 处理增量收集过程中的对象状态转换。
 * 
 * @param x 指向GCObject的指针
 */
#define changewhite(x)  ((x)->gch.marked ^= WHITEBITS)

/**
 * @brief 将灰色对象标记为黑色：完成对象扫描
 * 
 * 当一个灰色对象的所有引用都已处理完毕时，将其标记为黑色。
 * 这表示该对象已完全扫描，不需要进一步处理。
 * 
 * @param x 指向GCObject的指针
 */
#define gray2black(x)   l_setbit((x)->gch.marked, BLACKBIT)

/**
 * @brief 检查值是否为白色：用于值类型的白色检测
 * 
 * 这个宏专门用于检查TValue中的值是否为白色。只有可收集的
 * 值才能是白色，这个宏同时检查可收集性和白色状态。
 * 
 * @param x 指向TValue的指针
 * @return 非零值表示值为白色且可收集，0表示不满足条件
 */
#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))

/**
 * @brief 获取当前白色：返回当前收集周期使用的白色类型
 * 
 * 这个宏返回当前垃圾收集周期使用的白色位模式。新分配的
 * 对象会被标记为这种白色。
 * 
 * @param g 指向global_State的指针
 * @return 当前白色的位模式，转换为lu_byte类型
 */
#define luaC_white(g)   cast(lu_byte, (g)->currentwhite & WHITEBITS)

/**
 * @brief GC触发检查宏：自动检测并触发垃圾收集
 * 
 * 详细说明：
 * 这个宏实现了Lua的自动垃圾收集触发机制。它在每次可能分配内存的
 * 操作后被调用，检查当前内存使用量是否超过了GC阈值。如果超过，
 * 则自动触发一步增量垃圾收集。
 * 
 * 触发条件：
 * - 总分配字节数 >= GC阈值
 * - 考虑栈空间的硬性测试（调试模式）
 * - 确保有足够的栈空间进行GC操作
 * 
 * 性能优化：
 * - 增量执行：每次只执行一步GC，避免长时间停顿
 * - 自适应阈值：根据分配速度动态调整触发点
 * - 栈安全检查：确保有足够栈空间执行GC
 * 
 * 使用场景：
 * - 内存分配函数的末尾
 * - 对象创建操作之后
 * - 可能导致内存增长的操作后
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * 
 * @note 这是一个宏，会展开为复合语句
 * @warning GC执行可能会移动对象，调用者需要刷新对象指针
 */
#define luaC_checkGC(L) { \
  condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); \
  if (G(L)->totalbytes >= G(L)->GCthreshold) \
    luaC_step(L); }

/**
 * @brief 写屏障宏：维护增量GC的三色不变性
 * 
 * 详细说明：
 * 写屏障是增量垃圾收集算法的核心机制，用于维护三色标记的不变性。
 * 当一个黑色对象（已扫描）指向一个白色对象（未访问）时，必须设置
 * 写屏障以防止白色对象被错误回收。
 * 
 * 三色不变性：
 * - 黑色对象不能直接指向白色对象
 * - 如果出现这种情况，必须采取补救措施
 * - 通常的解决方案是将黑色对象标记为灰色（后向屏障）
 * 
 * 触发条件：
 * - 值v是白色且可收集的
 * - 容器对象p是黑色的
 * - p即将建立对v的引用
 * 
 * 屏障策略：
 * - 前向屏障：将白色对象标记为灰色
 * - 后向屏障：将黑色对象标记为灰色
 * - 选择策略取决于对象类型和性能考虑
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param p 容器对象指针，将引用值v的对象
 * @param v 被引用的值，可能是白色对象
 * 
 * @note 只有在必要时才会调用实际的屏障函数
 * @see luaC_barrierf()
 */
#define luaC_barrier(L, p, v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
    luaC_barrierf(L, obj2gco(p), gcvalue(v)); }

/**
 * @brief 表专用写屏障：针对表对象优化的写屏障
 * 
 * 详细说明：
 * 这个宏是专门为表对象设计的写屏障。由于表的特殊性（可能有大量的
 * 键值对），使用后向屏障策略更加高效。当表引用白色对象时，将表
 * 本身标记为灰色，而不是将被引用的对象标记为灰色。
 * 
 * 表的写屏障策略：
 * - 后向屏障：将表标记为灰色
 * - 避免扫描大量的表项
 * - 在下次GC扫描时重新处理表
 * 
 * 优化考虑：
 * - 表可能包含大量元素，前向屏障代价高
 * - 后向屏障只需要标记一个对象（表本身）
 * - 适用于频繁修改的表结构
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param t 表对象指针
 * @param v 被表引用的值
 * 
 * @see luaC_barrierback()
 */
#define luaC_barriert(L, t, v) { if (valiswhite(v) && isblack(obj2gco(t)))  \
    luaC_barrierback(L, t); }

/**
 * @brief 对象到对象写屏障：处理对象间直接引用的屏障
 * 
 * 详细说明：
 * 这个宏处理一个对象直接引用另一个对象的情况。与值引用不同，
 * 对象引用涉及两个明确的GCObject，可以更精确地处理屏障逻辑。
 * 
 * 对象引用场景：
 * - 用户数据的元表引用
 * - 函数的环境表引用
 * - 线程的函数调用栈引用
 * 
 * 屏障策略选择：
 * - 优先使用前向屏障
 * - 将被引用对象标记为灰色
 * - 保持引用对象的黑色状态
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param p 引用对象，建立引用关系的对象
 * @param o 被引用对象，被引用关系指向的对象
 */
#define luaC_objbarrier(L, p, o)  \
    { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
        luaC_barrierf(L, obj2gco(p), obj2gco(o)); }

/**
 * @brief 表的对象到对象写屏障：表引用对象的专用屏障
 * 
 * 详细说明：
 * 这个宏是表对象引用其他对象时使用的写屏障，结合了表的特殊性
 * 和对象引用的精确性。对于表，优先使用后向屏障策略。
 * 
 * 应用场景：
 * - 表的元表设置
 * - 表中存储对象引用
 * - 表的弱引用处理
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param t 表对象指针
 * @param o 被表引用的对象
 */
#define luaC_objbarriert(L, t, o)  \
   { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L, t); }

/**
 * @brief 分离用户数据：将需要终结的用户数据从普通对象中分离
 * 
 * 详细说明：
 * 这个函数处理用户数据的终结过程，将有终结器的用户数据分离出来，
 * 确保它们在正确的时机被终结。这是垃圾收集器终结阶段的核心功能。
 * 
 * 终结流程：
 * 1. 扫描所有用户数据对象
 * 2. 识别有__gc元方法的用户数据
 * 3. 将它们移到单独的终结列表
 * 4. 按正确顺序调用终结器
 * 
 * 参数语义：
 * - all=0：只处理当前死亡的用户数据
 * - all=1：处理所有用户数据（关闭时使用）
 * 
 * 返回值：
 * 返回被分离的用户数据对象的总内存大小，用于内存统计。
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param all 是否处理所有用户数据（0=仅死亡对象，1=所有对象）
 * @return 被分离对象的总内存大小
 * 
 * @note 终结器的调用顺序是不确定的
 * @warning 终结器可能会创建新的对象引用
 */
LUAI_FUNC size_t luaC_separateudata(lua_State *L, int all);

/**
 * @brief 调用垃圾收集终结器：执行用户数据的__gc元方法
 * 
 * 详细说明：
 * 这个函数负责调用用户数据的终结器方法。它遍历终结列表，
 * 为每个需要终结的用户数据调用其__gc元方法，确保资源的正确清理。
 * 
 * 终结器执行：
 * - 查找用户数据的元表
 * - 检查是否存在__gc字段
 * - 调用__gc方法并传递用户数据作为参数
 * - 处理终结器执行过程中的错误
 * 
 * 错误处理：
 * - 终结器中的错误不会中断GC过程
 * - 错误会被记录但不会向上传播
 * - 确保所有终结器都有机会执行
 * 
 * 性能考虑：
 * - 终结器调用可能很耗时
 * - 可能触发新的内存分配和GC
 * - 需要保护GC状态的一致性
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * 
 * @note 终结器可能会修改Lua状态，需要小心处理
 * @warning 不应在终结器中执行长时间运行的操作
 */
LUAI_FUNC void luaC_callGCTM(lua_State *L);

/**
 * @brief 释放所有对象：关闭时的完整内存清理
 * 
 * 详细说明：
 * 这个函数在Lua状态关闭时被调用，负责释放所有分配的对象和内存。
 * 它执行彻底的清理工作，确保没有内存泄漏。
 * 
 * 清理流程：
 * 1. 调用所有用户数据的终结器
 * 2. 释放所有字符串对象
 * 3. 释放所有表、函数、线程等对象
 * 4. 清理全局状态和注册表
 * 5. 释放GC相关的数据结构
 * 
 * 特殊处理：
 * - 固定对象也会被释放
 * - 不执行增量收集，而是一次性清理
 * - 不触发常规的GC流程
 * 
 * 安全考虑：
 * - 按依赖关系的逆序释放对象
 * - 防止释放过程中的递归调用
 * - 确保终结器有机会执行清理工作
 * 
 * @param L lua_State指针，要关闭的Lua虚拟机状态
 * 
 * @note 调用后lua_State将不再可用
 * @warning 只能在lua_close时调用，不能在运行时使用
 */
LUAI_FUNC void luaC_freeall(lua_State *L);

/**
 * @brief 执行一步增量垃圾收集：GC算法的核心驱动函数
 * 
 * 详细说明：
 * 这个函数实现了增量垃圾收集的核心逻辑，每次调用执行一小步GC工作。
 * 它根据当前GC状态选择相应的操作，实现了状态机驱动的收集算法。
 * 
 * 状态机处理：
 * - GCSpause：准备开始新的收集周期
 * - GCSpropagate：执行标记传播工作
 * - GCSsweepstring：清扫字符串哈希表
 * - GCSsweep：清扫其他对象
 * - GCSfinalize：处理终结器
 * 
 * 工作量控制：
 * - 每步的工作量由GC参数控制
 * - 根据可用时间动态调整工作量
 * - 平衡GC效率和程序响应性
 * 
 * 自适应策略：
 * - 根据分配速度调整GC频率
 * - 动态调整各阶段的工作比例
 * - 优化内存使用和性能平衡
 * 
 * 性能优化：
 * - 最小化每步的执行时间
 * - 减少对程序执行的影响
 * - 提供可预测的停顿时间
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * 
 * @note 可能会改变GC状态和对象标记
 * @see luaC_checkGC(), luaC_fullgc()
 */
LUAI_FUNC void luaC_step(lua_State *L);

/**
 * @brief 执行完整垃圾收集：强制完成一个完整的GC周期
 * 
 * 详细说明：
 * 这个函数强制执行一个完整的垃圾收集周期，不考虑增量限制。
 * 它会一直执行直到完成所有GC阶段，确保回收所有可回收的内存。
 * 
 * 完整收集流程：
 * 1. 标记所有可达对象
 * 2. 清扫所有不可达对象
 * 3. 调用所有必要的终结器
 * 4. 重新计算GC参数
 * 
 * 使用场景：
 * - 用户显式调用collectgarbage()
 * - 内存压力过大时的紧急回收
 * - 调试和测试中的确定性回收
 * - 程序关键点的内存整理
 * 
 * 性能影响：
 * - 可能造成较长时间的停顿
 * - 回收效果最彻底
 * - 重置GC参数和阈值
 * 
 * 副作用：
 * - 可能移动大量对象
 * - 调用大量终结器
 * - 改变内存布局
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * 
 * @note 执行时间可能较长，谨慎在性能敏感场景使用
 * @warning 会调用所有终结器，可能产生副作用
 */
LUAI_FUNC void luaC_fullgc(lua_State *L);

/**
 * @brief 链接对象到GC：将新创建的对象加入垃圾收集管理
 * 
 * 详细说明：
 * 这个函数将新创建的对象链接到垃圾收集器的管理链表中。所有可收集
 * 的对象都必须通过这个函数注册到GC系统，以便能够被正确管理和回收。
 * 
 * 链接过程：
 * 1. 设置对象的基本GC信息
 * 2. 将对象加入相应的链表
 * 3. 设置正确的颜色标记
 * 4. 更新内存统计信息
 * 
 * 对象分类：
 * - 根据类型加入不同的链表
 * - 字符串有专门的哈希表管理
 * - 其他对象按类型分组管理
 * 
 * 颜色标记：
 * - 新对象通常标记为当前白色
 * - 在GC标记阶段创建的对象标记为非当前白色
 * - 固定对象设置特殊标记
 * 
 * 内存统计：
 * - 更新总分配字节数
 * - 可能触发GC阈值检查
 * - 影响下次GC的触发时机
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param o 要链接的GC对象指针
 * @param tt 对象的类型标识
 * 
 * @note 所有可收集对象都必须调用此函数
 * @warning 链接后对象的生命周期由GC管理
 */
LUAI_FUNC void luaC_link(lua_State *L, GCObject *o, lu_byte tt);

/**
 * @brief 链接upvalue到GC：处理upvalue的特殊链接需求
 * 
 * 详细说明：
 * Upvalue是闭包中引用外部变量的特殊对象，它们有独特的生命周期管理
 * 需求。这个函数专门处理upvalue的GC链接，确保它们被正确管理。
 * 
 * Upvalue特性：
 * - 可能被多个闭包共享
 * - 有开放和关闭两种状态
 * - 生命周期与栈变量和闭包相关
 * 
 * 链接策略：
 * - 开放upvalue链接到特殊链表
 * - 关闭upvalue作为普通对象管理
 * - 支持upvalue的重复引用
 * 
 * 生命周期管理：
 * - 跟踪upvalue的引用计数
 * - 处理栈变量的生命周期变化
 * - 支持闭包的动态创建和销毁
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param uv 要链接的upvalue对象指针
 * 
 * @note upvalue有特殊的生命周期规则
 * @see luaC_link()
 */
LUAI_FUNC void luaC_linkupval(lua_State *L, UpVal *uv);

/**
 * @brief 前向写屏障：将白色对象标记为灰色的屏障实现
 * 
 * 详细说明：
 * 这个函数实现前向写屏障策略，当黑色对象需要引用白色对象时，
 * 将白色对象标记为灰色，确保它不会被错误回收。
 * 
 * 前向屏障策略：
 * - 保持引用对象的黑色状态
 * - 将被引用对象标记为灰色
 * - 适用于单个对象引用的场景
 * 
 * 实现逻辑：
 * 1. 检查屏障条件是否满足
 * 2. 将白色对象标记为灰色
 * 3. 加入灰色对象列表等待处理
 * 4. 更新GC统计信息
 * 
 * 性能考虑：
 * - 只处理必要的对象
 * - 最小化颜色改变的开销
 * - 避免不必要的重复标记
 * 
 * 正确性保证：
 * - 维护三色不变性
 * - 防止对象丢失
 * - 确保增量收集的正确性
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param o 引用对象，建立引用关系的黑色对象
 * @param v 被引用对象，需要标记为灰色的白色对象
 * 
 * @note 只在必要时调用，由屏障宏自动判断
 * @see luaC_barrier(), luaC_objbarrier()
 */
LUAI_FUNC void luaC_barrierf(lua_State *L, GCObject *o, GCObject *v);

/**
 * @brief 后向写屏障：将黑色表标记为灰色的屏障实现
 * 
 * 详细说明：
 * 这个函数实现后向写屏障策略，专门用于表对象。当黑色表需要引用
 * 白色对象时，将表本身标记为灰色，在下次扫描时重新处理表的内容。
 * 
 * 后向屏障策略：
 * - 将引用对象（表）标记为灰色
 * - 保持被引用对象的原始状态
 * - 适用于容器对象（如表）的场景
 * 
 * 表的特殊性：
 * - 表可能包含大量键值对
 * - 扫描整个表的代价较高
 * - 后向屏障避免立即扫描所有内容
 * 
 * 实现逻辑：
 * 1. 将表的黑色标记清除
 * 2. 将表加入灰色对象列表
 * 3. 在下次传播阶段重新扫描表
 * 4. 更新相关的GC统计
 * 
 * 优化效果：
 * - 减少写屏障的即时开销
 * - 批量处理表的引用关系
 * - 适合频繁修改的表结构
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param t 需要重新标记的表对象指针
 * 
 * @note 专门为表对象优化的屏障策略
 * @see luaC_barriert(), luaC_objbarriert()
 */
LUAI_FUNC void luaC_barrierback(lua_State *L, Table *t);

#endif
