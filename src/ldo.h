/*
** ====================================================================
** Lua 栈和调用结构管理模块头文件 (ldo.h)
** ====================================================================
** 
** 文件标识: $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
** 功能描述: Lua 的栈管理和函数调用结构定义
** 版权信息: 参见 lua.h 中的版权声明
** 
** 模块概述:
** 本头文件定义了 Lua 虚拟机的核心执行控制机制，包括栈管理、
** 函数调用、错误处理和协程支持。这是 Lua 运行时系统的心脏，
** 负责管理程序的执行流程和内存栈的动态分配。
** 
** 主要功能领域:
** 1. 栈管理 - 动态栈增长、栈指针操作、栈空间检查
** 2. 函数调用 - 调用准备、参数传递、返回值处理
** 3. 错误处理 - 保护调用、异常传播、错误对象管理
** 4. 内存管理 - 栈重分配、调用信息管理
** 5. 协程支持 - yield/resume 机制、执行状态切换
** 6. 调试支持 - 调试钩子、执行跟踪
** 
** 设计目标:
** - 提供高效的函数调用机制
** - 支持动态栈管理和内存优化
** - 实现安全的错误处理和异常传播
** - 支持协程的轻量级线程模型
** - 为调试器提供完整的执行控制接口
** 
** 依赖关系:
** - lobject.h: Lua 对象系统和 TValue 定义
** - lstate.h: Lua 状态管理和虚拟机结构
** - lzio.h: 输入流抽象层（用于解析器）
** 
** 注意事项:
** - 栈操作需要谨慎处理，避免栈溢出或下溢
** - 错误处理函数可能不会正常返回
** - 协程操作需要正确的状态管理
** - 内存重分配可能触发垃圾回收
** ====================================================================
*/

/*
** ====================================================================
** [预处理] 头文件保护和依赖包含
** ====================================================================
*/

#ifndef ldo_h
#define ldo_h

/*
** ====================================================================
** [依赖] 核心依赖模块包含
** ====================================================================
*/

/*
** [核心依赖] Lua 对象系统
** 
** 包含 lobject.h 以获取：
** - TValue 结构体定义（Lua 值的统一表示）
** - StkId 类型定义（栈索引指针）
** - 各种 Lua 类型的宏定义和操作函数
** - 对象类型检查和转换宏
*/
#include "lobject.h"

/*
** [核心依赖] Lua 状态管理
** 
** 包含 lstate.h 以获取：
** - lua_State 结构体定义（虚拟机状态）
** - CallInfo 结构体定义（调用信息）
** - global_State 结构体定义（全局状态）
** - 栈和调用链的管理结构
*/
#include "lstate.h"

/*
** [核心依赖] 输入流抽象层
** 
** 包含 lzio.h 以获取：
** - ZIO 结构体定义（输入流抽象）
** - 用于 luaD_protectedparser 函数的流处理
** - 代码加载和解析时的输入管理
*/
#include "lzio.h"


/*
** ====================================================================
** [管理] 栈空间检查和管理宏
** ====================================================================
*/

/*
** [管理] 栈空间检查和自动增长宏
**
** 功能：检查栈空间是否足够，不足时自动增长
** @param L: lua_State* Lua 虚拟机状态指针
** @param n: int 需要的额外栈空间大小
**
** 实现机制：
** 1. 计算当前可用栈空间：stack_last - top
** 2. 与需求空间 n * sizeof(TValue) 比较
** 3. 空间不足时调用 luaD_growstack 增长栈
** 4. 调试模式下进行额外的栈测试
**
** 性能优化：
** - 使用指针算术快速计算可用空间
** - 避免不必要的函数调用
** - 内联检查减少开销
** - 条件编译的调试支持
**
** 安全考虑：
** - 防止栈溢出导致的内存访问错误
** - 确保栈有足够空间进行操作
** - 在栈增长失败时抛出错误
**
** 使用场景：
** - 函数调用前的栈空间预分配
** - 表达式计算时的临时空间保证
** - 循环体内的栈空间管理
** - API 函数的栈安全检查
**
** 调试支持：
** condhardstacktests 宏在调试模式下会强制进行栈重分配测试，
** 帮助发现栈管理相关的潜在问题。
*/
#define luaD_checkstack(L,n)	\
  if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) \
    luaD_growstack(L, n); \
  else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));

/*
** [管理] 栈顶指针安全递增宏
**
** 功能：安全地将栈顶指针向上移动一个位置
** @param L: lua_State* Lua 虚拟机状态指针
**
** 安全机制：
** 1. 首先检查栈空间是否足够（至少1个位置）
** 2. 如果空间不足，自动增长栈
** 3. 然后安全地递增栈顶指针
**
** 使用时机：
** - 向栈中压入新值之前
** - 为函数调用准备参数空间
** - 临时值的栈空间分配
** - 表达式计算的中间结果存储
**
** 性能考虑：
** - 大多数情况下只是简单的指针递增
** - 栈空间检查的开销很小
** - 避免了手动栈管理的复杂性
** - 内联展开提高执行效率
**
** 错误处理：
** 如果栈增长失败（通常是内存不足），会抛出 Lua 错误。
*/
#define incr_top(L) {luaD_checkstack(L,1); L->top++;}

/*
** ====================================================================
** [实用] 栈指针保存和恢复宏
** ====================================================================
*/

/*
** [实用] 栈指针保存宏
**
** 功能：将栈指针转换为相对于栈基址的偏移量
** @param L: lua_State* Lua 虚拟机状态指针
** @param p: TValue* 要保存的栈指针
** @return: ptrdiff_t 相对偏移量（字节数）
**
** 保存机制：
** - 计算指针 p 相对于栈基址 L->stack 的字节偏移
** - 返回值是字节数，不是 TValue 元素数
** - 使用字符指针算术确保字节级精度
**
** 应用场景：
** - 垃圾回收前保存栈指针
** - 栈重分配前的指针保护
** - 错误处理中的栈状态保存
** - 协程切换时的栈指针保存
**
** 重要性：
** 栈可能在垃圾回收或重分配时移动，绝对指针会失效，
** 因此需要保存相对偏移量来维持指针的有效性。
*/
#define savestack(L,p)		((char *)(p) - (char *)L->stack)

/*
** [实用] 栈指针恢复宏
**
** 功能：从相对偏移量恢复栈指针
** @param L: lua_State* Lua 虚拟机状态指针
** @param n: ptrdiff_t 之前保存的偏移量
** @return: TValue* 恢复的栈指针
**
** 恢复机制：
** - 将字节偏移量加到当前栈基址上
** - 转换回 TValue 指针类型
** - 确保指针指向正确的栈位置
**
** 配合使用：
** 必须与 savestack 配对使用，先保存偏移量，后恢复指针。
**
** 线程安全：
** 这些宏不是线程安全的，假设在单线程环境中使用。
*/
#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))

/*
** ====================================================================
** [实用] 调用信息指针保存和恢复宏
** ====================================================================
*/

/*
** [实用] 调用信息指针保存宏
**
** 功能：将调用信息指针转换为相对于基址的偏移量
** @param L: lua_State* Lua 虚拟机状态指针
** @param p: CallInfo* 要保存的调用信息指针
** @return: ptrdiff_t 相对偏移量（字节数）
**
** 保存机制：
** - 计算指针 p 相对于调用信息基址 L->base_ci 的偏移
** - 使用字符指针算术计算字节偏移
** - 适用于调用信息数组的动态管理
**
** 应用场景：
** - 调用信息数组重分配前的指针保护
** - 错误处理中的调用栈保存
** - 协程状态切换时的调用信息保存
** - 垃圾回收过程中的指针保护
*/
#define saveci(L,p)		((char *)(p) - (char *)L->base_ci)

/*
** [实用] 调用信息指针恢复宏
**
** 功能：从相对偏移量恢复调用信息指针
** @param L: lua_State* Lua 虚拟机状态指针
** @param n: ptrdiff_t 之前保存的偏移量
** @return: CallInfo* 恢复的调用信息指针
**
** 恢复机制：
** - 将字节偏移量加到当前调用信息基址上
** - 转换回 CallInfo 指针类型
** - 确保指针指向正确的调用信息位置
**
** 内存安全：
** 调用信息数组在重分配时可能移动，使用偏移量机制
** 确保指针在数组移动后仍然有效。
*/
#define restoreci(L,n)		((CallInfo *)((char *)L->base_ci + (n)))


/*
** ====================================================================
** [常量] 函数预调用结果代码
** ====================================================================
*/

/*
** [常量] Lua 函数调用启动代码
**
** 含义：luaD_precall 启动了对 Lua 函数的调用
** 
** 处理流程：
** - 函数是 Lua 字节码函数
** - 需要设置新的调用帧
** - 准备局部变量和参数
** - 将控制权转移给虚拟机执行器
**
** 后续操作：
** - 调用 luaV_execute 执行字节码
** - 函数执行完成后调用 luaD_poscall
** - 处理返回值和栈清理
*/
#define PCRLUA		0	/* initiated a call to a Lua function */

/*
** [常量] C 函数调用完成代码
**
** 含义：luaD_precall 完成了对 C 函数的调用
** 
** 处理流程：
** - 函数是 C 函数（lua_CFunction）
** - C 函数已经执行完成
** - 返回值已经放置在栈上
** - 不需要额外的虚拟机执行
**
** 后续操作：
** - 直接调用 luaD_poscall 处理返回值
** - 清理调用帧和栈状态
** - 返回到调用者
*/
#define PCRC		1	/* did a call to a C function */

/*
** [常量] C 函数让出代码
**
** 含义：C 函数执行了 yield 操作
** 
** 处理流程：
** - C 函数调用了 lua_yield
** - 当前协程需要暂停执行
** - 保存执行状态以便后续恢复
** - 将控制权返回给调用者
**
** 协程状态：
** - 协程状态变为 LUA_YIELD
** - 保存让出时的栈状态
** - 等待 lua_resume 恢复执行
** - 支持协程的协作式多任务
**
** 注意事项：
** - 只有在协程中才能使用 yield
** - 主线程不能执行 yield 操作
** - yield 可能携带返回值
*/
#define PCRYIELD	2	/* C funtion yielded */


/*
** ====================================================================
** [类型] 保护函数类型定义
** ====================================================================
*/

/*
** [类型] 保护函数指针类型
**
** 功能：定义由 runprotected 执行的保护函数类型
** @param L: lua_State* Lua 虚拟机状态指针
** @param ud: void* 用户数据指针（传递给保护函数的参数）
**
** 保护机制：
** - 保护函数在受保护的环境中执行
** - 如果发生错误，通过 longjmp 机制捕获
** - 不会因为错误而终止整个程序
** - 提供异常安全的执行环境
**
** 使用场景：
** - 解析器执行：luaD_protectedparser
** - 函数调用：luaD_pcall
** - 垃圾回收：安全的 GC 操作
** - 用户代码执行：API 函数的安全执行
**
** 参数传递：
** - L: 提供虚拟机状态和栈访问
** - ud: 传递函数特定的参数和上下文
** - 支持任意类型的数据传递
**
** 错误处理：
** - 保护函数可以调用 luaD_throw 抛出错误
** - 错误会被外层的保护机制捕获
** - 支持错误码的传递和处理
** - 自动进行资源清理
*/
typedef void (*Pfunc) (lua_State *L, void *ud);

/*
** ====================================================================
** [核心] 解析器和调试钩子函数
** ====================================================================
*/

/*
** [核心] 保护模式解析器函数
**
** 功能：在保护模式下解析 Lua 代码
** @param L: lua_State* Lua 虚拟机状态指针
** @param z: ZIO* 输入流抽象对象
** @param name: const char* 代码块名称（用于错误报告）
** @return: int 解析结果（0表示成功，非0表示错误）
**
** 保护机制：
** - 在受保护的环境中执行代码解析
** - 捕获解析过程中的所有错误
** - 防止语法错误导致程序崩溃
** - 提供安全的代码加载机制
**
** 解析流程：
** 1. 设置保护环境和错误处理
** 2. 调用词法分析器和语法分析器
** 3. 生成字节码和函数原型
** 4. 处理编译时错误和警告
**
** 错误类型：
** - 语法错误：不正确的 Lua 语法
** - 内存错误：解析过程中的内存分配失败
** - 输入错误：输入流读取问题
** - 内部错误：编译器内部错误
**
** 应用场景：
** - lua_load 函数的底层实现
** - dofile、loadfile 等文件加载
** - loadstring 字符串代码解析
** - 交互式解释器的命令解析
*/
LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name);

/*
** [核心] 调试钩子调用函数
**
** 功能：调用用户设置的调试钩子函数
** @param L: lua_State* Lua 虚拟机状态指针
** @param event: int 调试事件类型
** @param line: int 当前源代码行号
**
** 调试事件类型：
** - LUA_HOOKCALL: 函数调用事件
** - LUA_HOOKRET: 函数返回事件
** - LUA_HOOKLINE: 新行执行事件
** - LUA_HOOKCOUNT: 指令计数事件
** - LUA_HOOKTAILRET: 尾调用返回事件
**
** 钩子机制：
** - 用户可以通过 lua_sethook 设置钩子函数
** - 钩子函数在特定事件发生时被调用
** - 提供程序执行的详细监控
** - 支持调试器和性能分析工具
**
** 性能影响：
** - 启用钩子会影响执行性能
** - 每个事件都会检查是否需要调用钩子
** - 钩子函数的执行时间会累积
** - 生产环境通常禁用调试钩子
**
** 钩子函数特性：
** - 可以访问当前的执行状态
** - 能够获取局部变量和上值
** - 支持堆栈检查和修改
** - 可以设置断点和单步执行
*/
LUAI_FUNC void luaD_callhook (lua_State *L, int event, int line);
/*
** ====================================================================
** [核心] 函数调用控制函数
** ====================================================================
*/

/*
** [核心] 函数预调用准备函数
**
** 功能：准备函数调用的执行环境
** @param L: lua_State* Lua 虚拟机状态指针
** @param func: StkId 函数对象在栈中的位置
** @param nresults: int 期望的返回值数量
** @return: int 调用类型（PCRLUA、PCRC 或 PCRYIELD）
**
** 调用准备流程：
** 1. 检查函数对象的有效性和类型
** 2. 为 Lua 函数设置新的调用帧
** 3. 为 C 函数直接执行调用
** 4. 处理参数传递和栈布局
** 5. 设置局部变量和上值环境
**
** 函数类型处理：
** - Lua 函数：设置 CallInfo，准备字节码执行
** - C 函数：直接调用，处理返回值
** - 轻量 C 函数：简化的 C 函数调用
** - 元方法：特殊的函数调用处理
**
** 栈管理：
** - 调整栈布局以适应函数调用
** - 设置参数的正确位置
** - 预留返回值空间
** - 管理临时变量的存储
**
** 协程支持：
** - 处理协程中的函数调用
** - 支持 yield 操作的检测
** - 维护协程状态的一致性
*/
LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);

/*
** [核心] 函数调用执行函数
**
** 功能：执行函数调用的完整流程
** @param L: lua_State* Lua 虚拟机状态指针
** @param func: StkId 函数对象在栈中的位置
** @param nResults: int 期望的返回值数量
**
** 完整调用流程：
** 1. 调用 luaD_precall 准备执行环境
** 2. 对于 Lua 函数，调用虚拟机执行器
** 3. 调用 luaD_poscall 处理返回值
** 4. 清理调用帧和栈状态
**
** 与 luaD_precall 的区别：
** - luaD_call 是完整的调用过程
** - luaD_precall 只是调用准备阶段
** - luaD_call 包含执行和后处理
** - 用于需要立即完成的函数调用
**
** 错误处理：
** - 不提供错误保护
** - 错误会直接传播到调用者
** - 适用于内部可靠的函数调用
** - 性能优于保护调用
**
** 应用场景：
** - 虚拟机内部的函数调用
** - 元方法的自动调用
** - 运算符重载的函数调用
** - 内部库函数的调用
*/
LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);
/*
** ====================================================================
** [核心] 保护调用和后处理函数
** ====================================================================
*/

/*
** [核心] 保护模式函数调用
**
** 功能：在保护模式下执行函数
** @param L: lua_State* Lua 虚拟机状态指针
** @param func: Pfunc 要执行的保护函数
** @param u: void* 传递给保护函数的用户数据
** @param oldtop: ptrdiff_t 调用前的栈顶位置（保存的偏移）
** @param ef: ptrdiff_t 错误处理函数的栈位置（保存的偏移）
** @return: int 执行结果（0表示成功，非0表示错误码）
**
** 保护机制：
** - 使用 setjmp/longjmp 实现异常捕获
** - 捕获执行过程中的所有错误
** - 防止错误导致程序异常终止
** - 提供异常安全的函数执行环境
**
** 错误恢复：
** - 恢复栈到调用前的状态
** - 调用错误处理函数（如果指定）
** - 清理分配的资源
** - 返回适当的错误码
**
** 错误码类型：
** - 0: 成功执行
** - LUA_ERRRUN: 运行时错误
** - LUA_ERRMEM: 内存分配错误
** - LUA_ERRERR: 错误处理函数中的错误
** - LUA_ERRSYNTAX: 语法错误
**
** 应用场景：
** - lua_pcall 的底层实现
** - 安全的用户代码执行
** - 插件加载和执行
** - 错误边界的建立
*/
LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
                                        ptrdiff_t oldtop, ptrdiff_t ef);

/*
** [核心] 函数调用后处理函数
**
** 功能：处理函数调用完成后的返回值和栈清理
** @param L: lua_State* Lua 虚拟机状态指针
** @param firstResult: StkId 第一个返回值在栈中的位置
** @return: int 实际返回值的数量
**
** 后处理任务：
** 1. 整理函数返回值到正确的栈位置
** 2. 清理调用帧和局部变量
** 3. 恢复调用者的执行环境
** 4. 调整栈顶指针到正确位置
** 5. 处理多返回值的情况
**
** 返回值处理：
** - 移动返回值到调用者期望的位置
** - 处理返回值数量的匹配
** - 支持多返回值和可变返回值
** - 清理多余的栈空间
**
** 栈清理：
** - 移除被调用函数的局部变量
** - 清理临时计算值
** - 恢复调用者的栈环境
** - 释放不需要的栈空间
**
** 调用帧管理：
** - 弹出当前调用帧
** - 恢复上一层调用的状态
** - 更新程序计数器
** - 维护调用链的一致性
*/
LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
/*
** ====================================================================
** [管理] 内存重分配和栈管理函数
** ====================================================================
*/

/*
** [管理] 调用信息数组重分配函数
**
** 功能：重新分配调用信息数组的大小
** @param L: lua_State* Lua 虚拟机状态指针
** @param newsize: int 新的调用信息数组大小
**
** 重分配场景：
** - 调用深度超过当前数组容量
** - 递归调用需要更多调用帧
** - 协程创建时的初始分配
** - 内存优化时的数组缩减
**
** 内存管理：
** - 分配新的更大的调用信息数组
** - 复制现有调用信息到新数组
** - 更新所有相关指针引用
** - 释放旧的调用信息数组
**
** 指针更新：
** - 更新 L->base_ci 指向新数组基址
** - 调整 L->ci 指向当前调用帧
** - 重新计算数组边界指针
** - 确保所有 CallInfo 指针有效
**
** 错误处理：
** - 内存分配失败时抛出内存错误
** - 保持虚拟机状态的一致性
** - 确保错误后系统可恢复
**
** 性能考虑：
** - 重分配是相对昂贵的操作
** - 通常按指数增长策略分配
** - 避免频繁的小幅调整
** - 平衡内存使用和性能
*/
LUAI_FUNC void luaD_reallocCI (lua_State *L, int newsize);

/*
** [管理] 栈空间重分配函数
**
** 功能：重新分配 Lua 栈的大小
** @param L: lua_State* Lua 虚拟机状态指针
** @param newsize: int 新的栈大小（TValue 元素数量）
**
** 重分配触发：
** - 栈空间不足时的自动扩展
** - 深度递归导致的栈溢出预防
** - 大量局部变量的分配需求
** - 内存优化时的栈缩减
**
** 栈数据保护：
** - 保护所有有效的栈数据
** - 正确处理栈中的 Lua 值
** - 维护垃圾回收的对象引用
** - 保持栈数据的完整性
**
** 指针调整：
** - 更新 L->stack 指向新栈基址
** - 调整 L->top 到正确位置
** - 重新计算 L->stack_last 边界
** - 更新所有栈相关指针
**
** 垃圾回收考虑：
** - 新栈可能触发垃圾回收
** - 确保所有对象正确标记
** - 处理栈移动对 GC 的影响
** - 维护对象引用的有效性
*/
LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);

/*
** [管理] 栈空间增长函数
**
** 功能：增长栈空间以满足额外需求
** @param L: lua_State* Lua 虚拟机状态指针
** @param n: int 需要的额外栈空间大小
**
** 增长策略：
** - 计算满足需求的最小新大小
** - 应用增长策略（通常是指数增长）
** - 考虑系统内存限制和配置
** - 平衡性能和内存使用
**
** 容量计算：
** - 当前栈大小 + 需求大小 + 安全余量
** - 应用最大栈大小限制
** - 考虑对齐和效率因素
** - 防止栈无限增长
**
** 错误检查：
** - 检查是否超过最大栈限制
** - 验证内存分配是否成功
** - 处理栈溢出的情况
** - 抛出适当的错误信息
**
** 调用时机：
** - luaD_checkstack 检测到空间不足时
** - 函数调用需要额外栈空间时
** - 表达式计算需要临时空间时
** - API 函数确保栈安全时
*/
LUAI_FUNC void luaD_growstack (lua_State *L, int n);

/*
** ====================================================================
** [错误] 异常处理和错误对象管理
** ====================================================================
*/

/*
** [错误] 异常抛出函数
**
** 功能：抛出指定错误码的异常
** @param L: lua_State* Lua 虚拟机状态指针
** @param errcode: int 错误代码
**
** 异常机制：
** - 使用 longjmp 跳转到最近的错误处理点
** - 不会正常返回，直接跳转到保护点
** - 自动清理当前执行上下文
** - 传播错误到上层调用
**
** 错误代码类型：
** - LUA_ERRRUN: 运行时错误
** - LUA_ERRMEM: 内存分配错误
** - LUA_ERRERR: 错误处理函数中的错误
** - LUA_ERRSYNTAX: 语法分析错误
** - LUA_ERRYIELD: 协程让出（特殊情况）
**
** 错误传播：
** - 跳转到最近的 luaD_pcall 或 luaD_rawrunprotected
** - 触发错误处理和资源清理
** - 维护虚拟机状态的一致性
** - 支持嵌套的错误处理
**
** 使用场景：
** - 内存分配失败时抛出内存错误
** - 运行时类型检查失败
** - 栈溢出和系统资源耗尽
** - 用户显式调用 error() 函数
**
** 注意事项：
** - 函数永不正常返回
** - 必须在保护环境中调用
** - 错误对象应已在栈顶
** - 自动触发清理机制
*/
LUAI_FUNC void luaD_throw (lua_State *L, int errcode);

/*
** [错误] 原始保护执行函数
**
** 功能：在最底层保护模式下执行函数
** @param L: lua_State* Lua 虚拟机状态指针
** @param f: Pfunc 要执行的函数
** @param ud: void* 传递给函数的用户数据
** @return: int 执行状态（0表示成功，非0表示错误）
**
** 底层保护：
** - 设置 setjmp/longjmp 的跳转点
** - 最基础的异常捕获机制
** - 不进行额外的错误处理
** - 直接返回错误状态码
**
** 与 luaD_pcall 的区别：
** - 更底层的保护机制
** - 不进行栈恢复和错误对象处理
** - 主要用于系统级操作
** - 性能开销最小
**
** 应用场景：
** - 垃圾回收器的保护执行
** - 解析器的底层保护
** - 系统初始化的安全执行
** - 其他保护函数的基础
**
** 返回值处理：
** - 成功执行返回 0
** - 异常时返回对应错误码
** - 不修改栈状态
** - 不调用错误处理函数
*/
LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);

/*
** [错误] 错误对象设置函数
**
** 功能：在栈上设置适当的错误对象
** @param L: lua_State* Lua 虚拟机状态指针
** @param errcode: int 错误代码
** @param oldtop: StkId 错误发生前的栈顶位置
**
** 错误对象处理：
** - 根据错误类型创建或调整错误对象
** - 确保栈顶有正确的错误信息
** - 处理特殊错误类型的对象
** - 为错误传播准备错误对象
**
** 错误类型处理：
** - 运行时错误：保持原有错误对象
** - 内存错误：设置固定的内存错误消息
** - 语法错误：保持解析器生成的错误
** - 嵌套错误：设置错误处理错误消息
**
** 栈状态管理：
** - 调整栈顶到错误对象位置
** - 清理错误发生后的栈内容
** - 确保错误对象在正确位置
** - 维护栈的一致性状态
**
** 内存安全：
** - 处理内存不足时的错误对象创建
** - 使用预分配的错误字符串
** - 避免在错误处理中再次分配内存
** - 保证错误处理的稳定性
*/
LUAI_FUNC void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop);

/*
** ====================================================================
** [总结] Lua 执行控制模块总结
** ====================================================================
**
** 本头文件是 Lua 虚拟机执行控制的核心，定义了栈管理、函数调用、
** 错误处理和协程支持的完整基础设施。这是 Lua 运行时系统的心脏。
**
** 核心功能架构：
**
** 1. [栈管理系统]
**    - 动态栈增长：luaD_growstack, luaD_reallocstack
**    - 安全检查：luaD_checkstack, incr_top
**    - 指针管理：savestack/restorestack, saveci/restoreci
**    - 内存优化：智能增长策略，垃圾回收协作
**
** 2. [函数调用机制]
**    - 调用准备：luaD_precall（类型检查，栈布局）
**    - 调用执行：luaD_call（完整调用流程）
**    - 调用后处理：luaD_poscall（返回值，栈清理）
**    - 调用信息管理：luaD_reallocCI（动态调用栈）
**
** 3. [错误处理体系]
**    - 保护执行：luaD_pcall, luaD_rawrunprotected
**    - 异常抛出：luaD_throw（longjmp 机制）
**    - 错误对象：luaD_seterrorobj（错误信息管理）
**    - 资源清理：自动栈恢复和状态重置
**
** 4. [协程支持]
**    - 执行状态：PCRLUA, PCRC, PCRYIELD
**    - 状态切换：yield/resume 机制
**    - 栈保护：协程间的栈隔离
**    - 轻量级线程：协作式多任务
**
** 5. [调试基础设施]
**    - 调试钩子：luaD_callhook（事件通知）
**    - 执行跟踪：调用栈监控
**    - 性能分析：指令计数和事件记录
**    - 交互调试：断点和单步支持
**
** 6. [解析器集成]
**    - 保护解析：luaD_protectedparser
**    - 安全加载：防止语法错误崩溃
**    - 动态编译：运行时代码生成
**    - 错误恢复：编译错误的优雅处理
**
** 设计特点：
**
** 1. [安全性优先]
**    - 全面的错误保护机制
**    - 自动资源清理和状态恢复
**    - 栈溢出保护和内存安全
**    - 异常安全的执行环境
**
** 2. [性能优化]
**    - 内联宏减少函数调用开销
**    - 智能栈增长策略
**    - 高效的指针算术操作
**    - 最小化内存重分配
**
** 3. [灵活性]
**    - 支持多种函数类型（Lua/C/轻量C）
**    - 可配置的栈大小和增长策略
**    - 模块化的错误处理机制
**    - 可扩展的调试钩子系统
**
** 4. [健壮性]
**    - 完整的错误检查和验证
**    - 优雅的降级和错误恢复
**    - 一致的状态管理
**    - 防御性编程实践
**
** 执行模型：
**
** 1. [调用流程]
**    准备阶段 → 执行阶段 → 后处理阶段 → 清理阶段
**
** 2. [错误处理]
**    检测阶段 → 捕获阶段 → 恢复阶段 → 传播阶段
**
** 3. [栈管理]
**    检查阶段 → 增长阶段 → 使用阶段 → 清理阶段
**
** 4. [协程生命周期]
**    创建阶段 → 运行阶段 → 让出阶段 → 恢复阶段 → 结束阶段
**
** 性能考虑：
**
** 1. [热点路径优化]
**    - 栈检查和增长的快速路径
**    - 函数调用的内联优化
**    - 指针操作的直接算术
**    - 错误处理的分支预测
**
** 2. [内存效率]
**    - 栈的按需增长
**    - 调用信息的紧凑存储
**    - 指针保存的偏移量机制
**    - 垃圾回收的协作优化
**
** 3. [缓存友好]
**    - 顺序访问模式
**    - 局部性优化
**    - 预取友好的数据布局
**    - 分支预测优化
**
** 与其他模块的协作：
** - lvm.c: 虚拟机执行器的控制基础
** - lapi.c: C API 的底层执行支持
** - lgc.c: 垃圾回收的安全执行环境
** - lparser.c: 代码解析的保护机制
** - lstate.c: 虚拟机状态的生命周期管理
**
** 可扩展性：
** - 新的函数类型可以轻松集成
** - 错误处理机制易于扩展
** - 调试功能可以增强
** - 协程模型支持扩展
**
** 质量保证：
** - 全面的边界检查
** - 完整的错误覆盖
** - 一致的状态管理
** - 可靠的资源清理
*/

#endif

