/**
 * @file ldo.h
 * @brief Lua执行引擎头文件：定义Lua虚拟机的栈管理和函数调用机制
 * 
 * 详细说明：
 * 本文件是Lua执行引擎的核心头文件，定义了Lua虚拟机的栈管理、
 * 函数调用、错误处理和保护执行等关键机制。这些功能构成了Lua
 * 运行时系统的基础设施，确保了代码执行的安全性和可靠性。
 * 
 * 系统架构定位：
 * 在Lua解释器架构中，执行引擎处于核心位置：
 * 
 * 用户代码层
 *     ↓
 * API接口层 (lapi) ←→ 调试接口 (ldebug)
 *     ↓                    ↓
 * 执行引擎层 (ldo) ←→ 虚拟机 (lvm) ←→ 垃圾回收 (lgc)
 *     ↓                    ↓              ↓
 * 对象系统 (lobject) ←→ 状态管理 (lstate) ←→ 内存管理 (lmem)
 * 
 * 核心职责：
 * 
 * 1. **栈管理和安全**：
 *    - 动态栈空间分配和扩展
 *    - 栈溢出检测和保护
 *    - 栈指针的安全操作
 *    - 栈状态的保存和恢复
 * 
 * 2. **函数调用机制**：
 *    - Lua函数和C函数的统一调用
 *    - 参数传递和返回值处理
 *    - 调用栈的维护和管理
 *    - 尾调用优化支持
 * 
 * 3. **错误处理和异常**：
 *    - 保护执行环境的建立
 *    - 异常的捕获和传播
 *    - 错误对象的创建和管理
 *    - 栈展开和资源清理
 * 
 * 4. **协程和控制流**：
 *    - 协程的创建和切换
 *    - yield和resume操作
 *    - 执行上下文的保存
 *    - 调用链的管理
 * 
 * 技术特点：
 * 
 * **高效的栈设计**：
 * - 使用连续内存块存储栈帧
 * - 支持栈的动态增长和收缩
 * - 最小化栈操作的开销
 * - 优化寄存器式虚拟机的需求
 * 
 * **安全的内存管理**：
 * - 自动栈边界检查
 * - 防止栈溢出攻击
 * - 安全的指针运算
 * - 内存访问的边界保护
 * 
 * **灵活的调用约定**：
 * - 支持可变参数函数
 * - 多返回值的高效处理
 * - C函数和Lua函数的透明调用
 * - 元方法的自动调用
 * 
 * **鲁棒的错误处理**：
 * - 基于setjmp/longjmp的异常机制
 * - 保护调用和错误恢复
 * - 丰富的错误上下文信息
 * - 可定制的错误处理策略
 * 
 * 栈架构设计：
 * 
 * Lua使用一个统一的栈来管理所有的值：
 * 
 * ```
 * 高地址 ┌─────────────┐ ← stack_last (栈末尾)
 *       │             │
 *       │   可用空间   │
 *       │             │
 *       ├─────────────┤ ← top (栈顶)
 *       │  返回值n    │
 *       │     ...     │
 *       │  返回值1    │
 *       ├─────────────┤
 *       │  参数n      │
 *       │     ...     │
 *       │  参数1      │
 *       │  函数对象   │ ← func
 *       ├─────────────┤
 *       │   前一帧    │
 *       │     ...     │
 * 低地址 └─────────────┘ ← stack (栈底)
 * ```
 * 
 * 调用栈管理：
 * 
 * 每个函数调用都有对应的CallInfo结构：
 * - func: 指向栈中的函数对象
 * - top: 函数的栈顶位置
 * - previous: 指向调用者的CallInfo
 * - nresults: 期望的返回值数量
 * - tailcalls: 尾调用计数
 * 
 * 性能优化：
 * 
 * 1. **栈预分配**：
 *    - 预分配合理大小的栈空间
 *    - 减少频繁的内存分配
 *    - 支持栈的快速重用
 * 
 * 2. **调用优化**：
 *    - 尾调用优化减少栈使用
 *    - 内联简单函数调用
 *    - 快速路径处理常见情况
 * 
 * 3. **内存局部性**：
 *    - 连续存储提高缓存效率
 *    - 减少内存碎片化
 *    - 优化内存访问模式
 * 
 * 依赖关系：
 * - lobject.h: Lua对象系统和类型定义
 * - lstate.h: Lua状态机和执行环境
 * - lzio.h: 输入输出抽象层
 * - lvm.h: 虚拟机指令执行
 * - lgc.h: 垃圾回收和内存管理
 * 
 * 调试和诊断：
 * - 详细的调用栈跟踪
 * - 栈状态的可视化
 * - 内存使用统计
 * - 性能监控钩子
 * 
 * @author Roberto Ierusalimschy (Lua团队)
 * @version 5.1.5
 * @date 2007年12月27日
 * @since Lua 5.0
 * @see lstate.h, lvm.h, lgc.h
 */

#ifndef ldo_h
#define ldo_h

#include "lobject.h"
#include "lstate.h"
#include "lzio.h"

/**
 * @brief 栈空间检查和自动扩展宏
 * 
 * 详细说明：
 * 这是Lua栈管理的核心宏，用于确保栈有足够的空间容纳指定数量的新元素。
 * 如果空间不足，会自动触发栈扩展操作。这个宏是栈安全的基础保障。
 * 
 * 检查机制：
 * 1. **空间计算**：计算当前可用栈空间
 *    - stack_last: 栈的最大边界
 *    - top: 当前栈顶位置
 *    - 可用空间 = (stack_last - top) * sizeof(TValue)
 * 
 * 2. **需求评估**：评估需要的额外空间
 *    - n: 需要的新元素数量
 *    - 需求空间 = n * sizeof(TValue)
 * 
 * 3. **扩展策略**：根据需求执行扩展
 *    - 不足时调用luaD_growstack()扩展栈
 *    - 足够时可选择执行硬栈测试
 * 
 * 安全考虑：
 * - 防止栈溢出导致的内存破坏
 * - 自动处理栈空间不足的情况
 * - 在扩展失败时抛出内存错误
 * - 支持递归调用的深度限制
 * 
 * 性能优化：
 * - 快速路径：空间充足时的轻量级检查
 * - 延迟扩展：只在必要时才进行扩展
 * - 批量检查：一次检查多个元素的需求
 * - 预测扩展：根据历史使用模式预分配
 * 
 * 硬栈测试（condhardstacktests）：
 * 在调试版本中，即使有足够空间也可能执行栈重分配测试：
 * - 验证栈管理代码的正确性
 * - 测试极端情况下的行为
 * - 发现潜在的栈相关bug
 * 
 * 使用模式：
 * ```c
 * // 确保有空间存储3个新值
 * luaD_checkstack(L, 3);
 * lua_pushinteger(L, 42);
 * lua_pushstring(L, "hello");
 * lua_pushboolean(L, 1);
 * ```
 * 
 * 错误处理：
 * - 如果栈扩展失败（通常是内存不足），会抛出Lua错误
 * - 错误会通过异常机制传播到保护调用边界
 * - 调用者可以通过pcall捕获和处理这类错误
 * 
 * @param L Lua状态机指针
 * @param n 需要的额外栈空间（TValue元素数量）
 * 
 * @note 这个宏可能会修改L->top和L->stack指针
 * @warning 宏展开后包含复杂控制流，使用时注意语法上下文
 */
#define luaD_checkstack(L,n) \
    if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) \
        luaD_growstack(L, n); \
    else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));

/**
 * @brief 安全地将栈顶向上移动一位的宏
 * 
 * 详细说明：
 * 这个宏提供了一种安全的方式来增加栈顶指针，它会自动进行栈空间
 * 检查，确保操作不会导致栈溢出。这是push操作的基础设施。
 * 
 * 操作步骤：
 * 1. **空间检查**：调用luaD_checkstack检查是否有足够空间
 * 2. **指针递增**：将L->top指针向上移动一个TValue位置
 * 3. **状态更新**：更新栈的状态信息
 * 
 * 安全保障：
 * - 在移动指针前确保有足够空间
 * - 防止栈溢出导致的内存破坏
 * - 在空间不足时自动扩展栈
 * 
 * 使用场景：
 * - push操作的实现基础
 * - 为新值分配栈位置
 * - 函数调用时的参数准备
 * - 临时值的栈管理
 * 
 * 性能考虑：
 * - 大多数情况下只是简单的指针递增
 * - 只在栈快满时才进行扩展检查
 * - 批量操作时建议先检查总需求
 * 
 * 与其他操作的配合：
 * ```c
 * incr_top(L);              // 安全地增加栈顶
 * setnvalue(L->top-1, 3.14); // 在新位置设置值
 * ```
 * 
 * @param L Lua状态机指针
 * 
 * @note 这个宏会修改L->top指针
 * @see luaD_checkstack(), push系列API函数
 */
#define incr_top(L) {luaD_checkstack(L,1); L->top++;}

/**
 * @brief 将栈指针转换为相对偏移量的宏
 * 
 * 详细说明：
 * 这个宏将栈中的绝对指针转换为相对于栈底的字节偏移量。这种转换
 * 对于栈的重分配和保存/恢复操作至关重要，因为重分配后绝对地址
 * 可能发生变化。
 * 
 * 转换原理：
 * - 计算指针p与栈底stack之间的字节距离
 * - 使用字节偏移而非元素偏移，提供更大的灵活性
 * - 支持任意类型指针的转换（不仅仅是TValue*）
 * 
 * 应用场景：
 * 
 * 1. **栈重分配**：
 *    - 重分配前保存关键指针的位置
 *    - 重分配后恢复指针的正确位置
 *    - 确保重分配不破坏现有引用
 * 
 * 2. **协程切换**：
 *    - 保存当前协程的栈状态
 *    - 切换到其他协程
 *    - 恢复协程时还原栈指针
 * 
 * 3. **错误处理**：
 *    - 在异常处理中保存栈状态
 *    - 错误恢复时还原正确的栈位置
 *    - 支持多层次的错误处理
 * 
 * 4. **调试和诊断**：
 *    - 记录栈指针位置用于调试
 *    - 分析栈使用模式
 *    - 检测栈泄漏和异常
 * 
 * 类型安全：
 * - 返回ptrdiff_t类型，保证足够的精度
 * - 支持负偏移量（虽然在正常使用中不会出现）
 * - 与restorestack()宏配对使用
 * 
 * 性能特点：
 * - 简单的指针算术运算
 * - 编译时可以优化为常量计算
 * - 没有函数调用开销
 * 
 * 使用示例：
 * ```c
 * ptrdiff_t saved_top = savestack(L, L->top);
 * // ... 可能导致栈重分配的操作 ...
 * L->top = restorestack(L, saved_top);
 * ```
 * 
 * @param L Lua状态机指针（用于访问stack字段）
 * @param p 要转换的栈指针
 * @return 相对于栈底的字节偏移量
 * 
 * @note 只有在同一个Lua状态机中保存和恢复的偏移量才有效
 * @see restorestack(), 栈重分配相关函数
 */
#define savestack(L,p) ((char *)(p) - (char *)L->stack)

/**
 * @brief 将相对偏移量还原为栈指针的宏
 * 
 * 详细说明：
 * 这个宏是savestack()的逆操作，将相对偏移量转换回栈中的绝对指针。
 * 它通常用于栈重分配后恢复之前保存的指针位置。
 * 
 * 恢复机制：
 * - 以当前栈底为基准
 * - 加上之前保存的偏移量
 * - 转换为正确的TValue指针类型
 * 
 * 安全考虑：
 * - 偏移量必须是有效的（由savestack生成）
 * - 栈的大小必须足以容纳恢复的位置
 * - 只能在同一个Lua状态机中使用
 * 
 * 典型用法：
 * ```c
 * // 保存重要指针
 * ptrdiff_t func_pos = savestack(L, func);
 * ptrdiff_t top_pos = savestack(L, L->top);
 * 
 * // 执行可能重分配栈的操作
 * luaD_checkstack(L, 100);
 * 
 * // 恢复指针
 * func = restorestack(L, func_pos);
 * L->top = restorestack(L, top_pos);
 * ```
 * 
 * @param L Lua状态机指针
 * @param n 之前由savestack()返回的偏移量
 * @return 恢复的TValue指针
 * 
 * @note 返回类型强制转换为TValue*
 * @see savestack(), 栈管理相关函数
 */
#define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))

/**
 * @brief 将CallInfo指针转换为相对偏移量的宏
 * 
 * 详细说明：
 * 类似于savestack()，但专门用于CallInfo结构体指针的保存。CallInfo
 * 数组也可能在运行时重分配，因此需要类似的保存/恢复机制。
 * 
 * CallInfo管理：
 * - CallInfo数组存储函数调用信息
 * - 支持嵌套调用和递归
 * - 在调用深度增加时可能需要扩展
 * 
 * @param L Lua状态机指针
 * @param p CallInfo指针
 * @return 相对于base_ci的字节偏移量
 */
#define saveci(L,p) ((char *)(p) - (char *)L->base_ci)

/**
 * @brief 将相对偏移量还原为CallInfo指针的宏
 * 
 * 详细说明：
 * saveci()的逆操作，用于恢复CallInfo指针。
 * 
 * @param L Lua状态机指针
 * @param n 之前由saveci()返回的偏移量
 * @return 恢复的CallInfo指针
 */
#define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))

/* ============================================================================
 * 函数调用结果常量定义
 * ============================================================================ */

/**
 * @brief luaD_precall函数的返回值常量
 * 
 * 详细说明：
 * 这些常量定义了luaD_precall函数的可能返回值，用于指示不同类型
 * 的函数调用结果和后续处理方式。
 */

/**
 * @brief 表示成功启动了Lua函数调用
 * 
 * 当luaD_precall成功设置了Lua函数的调用环境后返回此值。
 * 调用者应该继续执行虚拟机指令来运行Lua函数。
 */
#define PCRLUA      0

/**
 * @brief 表示执行了C函数调用并已完成
 * 
 * 当调用的是C函数且已经执行完毕后返回此值。
 * 调用者可以直接处理返回值，无需进一步的虚拟机执行。
 */
#define PCRC        1

/**
 * @brief 表示C函数调用了yield（协程挂起）
 * 
 * 当C函数调用了lua_yield导致协程挂起后返回此值。
 * 调用者应该保存当前状态并返回到调度器。
 */
#define PCRYIELD    2

/* ============================================================================
 * 保护函数类型定义
 * ============================================================================ */

/**
 * @brief 保护执行函数的类型定义
 * 
 * 详细说明：
 * 定义了可以在保护环境中执行的函数类型。这些函数在setjmp/longjmp
 * 保护环境中运行，如果发生错误，可以安全地通过longjmp返回到
 * 错误处理点。
 * 
 * 函数签名：
 * - L: Lua状态机指针，提供执行环境
 * - ud: 用户数据指针，传递任意参数
 * - 返回值：void，错误通过异常机制传播
 * 
 * 使用场景：
 * - 解析器的保护执行
 * - 字节码加载和验证
 * - 垃圾回收的关键操作
 * - 其他可能失败的核心操作
 * 
 * 错误处理：
 * 保护函数如果遇到错误，应该调用luaD_throw()抛出异常，
 * 而不是直接返回错误码。这确保了错误的一致性处理。
 * 
 * @param L Lua状态机指针
 * @param ud 用户数据指针，用于传递参数
 */
typedef void (*Pfunc)(lua_State *L, void *ud);

/* ============================================================================
 * 解析和加载接口
 * ============================================================================ */

/**
 * @brief 在保护环境中执行Lua代码解析
 * 
 * 详细说明：
 * 在保护环境中解析Lua源代码或字节码，如果解析过程中发生错误，
 * 可以安全地捕获和处理，而不会导致程序崩溃。
 * 
 * 解析过程：
 * 1. **词法分析**：将源代码分解为标记序列
 * 2. **语法分析**：构建抽象语法树
 * 3. **代码生成**：生成字节码指令
 * 4. **优化处理**：执行基本的代码优化
 * 
 * 输入格式支持：
 * - 纯文本的Lua源代码
 * - 预编译的Lua字节码
 * - 混合格式（自动检测）
 * 
 * 错误处理：
 * - 语法错误：报告具体的错误位置和原因
 * - 语义错误：检测类型和作用域问题
 * - 内存错误：处理解析过程中的内存不足
 * - 格式错误：检测损坏的字节码文件
 * 
 * 安全特性：
 * - 防止恶意代码的解析攻击
 * - 限制嵌套深度避免栈溢出
 * - 检查字节码的完整性和有效性
 * - 隔离解析错误对运行时的影响
 * 
 * 性能优化：
 * - 增量解析减少内存峰值
 * - 优化常见语法模式的处理
 * - 缓存重复使用的符号和常量
 * - 并行处理独立的语法单元
 * 
 * @param L Lua状态机指针
 * @param z 输入流抽象接口
 * @param name 源代码的名称（用于错误报告）
 * @return 解析结果：0表示成功，非零表示错误类型
 * 
 * @note 解析成功后，生成的函数会被压入栈顶
 * @see ZIO结构体，luaD_pcall()
 */
LUAI_FUNC int luaD_protectedparser(lua_State *L, ZIO *z, const char *name);

/* ============================================================================
 * 调试和钩子接口
 * ============================================================================ */

/**
 * @brief 调用调试钩子函数
 * 
 * 详细说明：
 * 在特定事件发生时调用用户注册的调试钩子函数。这是Lua调试系统
 * 的核心机制，支持断点、单步执行、性能分析等调试功能。
 * 
 * 支持的钩子事件：
 * 
 * - **LUA_HOOKCALL**：函数调用时触发
 *   - 包括Lua函数和C函数的调用
 *   - 提供被调用函数的信息
 *   - 支持调用栈分析
 * 
 * - **LUA_HOOKRET**：函数返回时触发
 *   - 正常返回和异常返回都会触发
 *   - 提供返回值信息
 *   - 支持性能测量
 * 
 * - **LUA_HOOKLINE**：执行新源代码行时触发
 *   - 用于单步调试
 *   - 提供精确的行号信息
 *   - 支持断点设置
 * 
 * - **LUA_HOOKCOUNT**：执行指定数量指令后触发
 *   - 用于性能监控
 *   - 支持执行超时检测
 *   - 可配置触发间隔
 * 
 * 钩子函数接口：
 * ```c
 * void hook_function(lua_State *L, lua_Debug *ar);
 * ```
 * 
 * 调试信息结构：
 * lua_Debug结构包含丰富的调试信息：
 * - 事件类型和源位置
 * - 函数名和类型
 * - 局部变量和上值
 * - 调用栈和作用域
 * 
 * 性能考虑：
 * - 钩子会增加执行开销
 * - 应该尽量保持钩子函数的轻量级
 * - 可以动态启用/禁用特定类型的钩子
 * - 支持条件性钩子减少不必要的调用
 * 
 * 应用场景：
 * - IDE中的调试器实现
 * - 性能分析和优化工具
 * - 代码覆盖率统计
 * - 运行时监控和诊断
 * 
 * @param L Lua状态机指针
 * @param event 钩子事件类型
 * @param line 当前执行的源代码行号（如果适用）
 * 
 * @note 钩子函数的执行也可能触发其他钩子
 * @see lua_sethook(), lua_Debug结构体
 */
LUAI_FUNC void luaD_callhook(lua_State *L, int event, int line);

/* ============================================================================
 * 函数调用管理接口
 * ============================================================================ */

/**
 * @brief 准备函数调用（调用预处理）
 * 
 * 详细说明：
 * 执行函数调用的预处理工作，包括参数验证、调用环境设置、
 * 函数类型识别等。这是所有函数调用的必经步骤。
 * 
 * 预处理步骤：
 * 
 * 1. **函数对象验证**：
 *    - 检查func位置的值是否可调用
 *    - 支持函数、C函数、可调用表（__call元方法）
 *    - 验证参数数量和类型
 * 
 * 2. **调用环境设置**：
 *    - 为Lua函数创建新的CallInfo
 *    - 设置函数的局部变量环境
 *    - 配置参数传递和返回值处理
 * 
 * 3. **类型特定处理**：
 *    - Lua函数：设置执行环境，准备进入虚拟机
 *    - C函数：直接调用并处理返回值
 *    - 元方法：设置元方法调用环境
 * 
 * 参数处理：
 * - 参数从func+1开始在栈上排列
 * - 支持可变参数函数
 * - 自动处理参数数量不匹配的情况
 * - 为不足的参数填充nil值
 * 
 * 返回值管理：
 * - nresults指定期望的返回值数量
 * - LUA_MULTRET表示接受所有返回值
 * - 自动调整栈以适应返回值
 * 
 * 错误处理：
 * - 非法函数对象会触发类型错误
 * - 栈空间不足会自动扩展
 * - C函数中的错误会正确传播
 * 
 * 性能优化：
 * - 快速路径处理常见的C函数调用
 * - 尾调用优化减少栈使用
 * - 内联简单函数避免调用开销
 * 
 * @param L Lua状态机指针
 * @param func 指向栈中函数对象的指针
 * @param nresults 期望的返回值数量
 * @return 调用类型：PCRLUA、PCRC或PCRYIELD
 * 
 * @pre func位置必须包含可调用的对象
 * @post 根据返回值，调用环境已准备好或调用已完成
 * 
 * @see PCRLUA, PCRC, PCRYIELD常量定义
 */
LUAI_FUNC int luaD_precall(lua_State *L, StkId func, int nresults);

/**
 * @brief 执行函数调用
 * 
 * 详细说明：
 * 这是函数调用的高级接口，它结合了预处理、执行和后处理的
 * 完整流程。对于大多数情况，这是推荐使用的调用接口。
 * 
 * 执行流程：
 * 1. **调用预处理**：调用luaD_precall进行准备
 * 2. **执行阶段**：根据函数类型执行相应逻辑
 * 3. **后处理**：调用luaD_poscall处理返回值
 * 
 * 函数类型处理：
 * - Lua函数：启动虚拟机执行字节码
 * - C函数：直接调用C函数指针
 * - 元方法：按照元方法调用约定执行
 * 
 * 栈管理：
 * - 自动管理调用栈的增长和收缩
 * - 确保调用前后栈状态的一致性
 * - 处理异常情况下的栈清理
 * 
 * 递归控制：
 * - 监控调用深度防止栈溢出
 * - 支持深度限制的配置
 * - 在达到限制时抛出适当错误
 * 
 * 调试支持：
 * - 在适当时机触发调用钩子
 * - 维护调试信息的完整性
 * - 支持调试器的断点和单步
 * 
 * @param L Lua状态机指针
 * @param func 指向栈中函数对象的指针
 * @param nResults 期望的返回值数量
 * 
 * @note 这个函数可能会修改栈的结构和内容
 * @see luaD_precall(), luaD_poscall()
 */
LUAI_FUNC void luaD_call(lua_State *L, StkId func, int nResults);

/**
 * @brief 保护模式下的函数调用
 * 
 * 详细说明：
 * 在保护环境中执行指定的函数，如果执行过程中发生错误，
 * 可以安全地捕获和处理，而不会影响调用者的执行环境。
 * 
 * 保护机制：
 * - 使用setjmp建立错误捕获点
 * - 在保护环境中执行目标函数
 * - 通过longjmp处理异常情况
 * - 确保资源的正确清理
 * 
 * 参数说明：
 * - func: 要执行的保护函数
 * - u: 传递给函数的用户数据
 * - oldtop: 调用前的栈顶位置（用于错误恢复）
 * - ef: 错误处理函数的栈位置
 * 
 * 错误恢复：
 * - 恢复栈到调用前的状态
 * - 清理临时分配的资源
 * - 调用错误处理函数
 * - 返回适当的错误码
 * 
 * 典型用法：
 * ```c
 * int status = luaD_pcall(L, protected_func, userdata, 
 *                        savestack(L, L->top), 0);
 * if (status != 0) {
 *     // 处理错误
 * }
 * ```
 * 
 * @param L Lua状态机指针
 * @param func 要在保护环境中执行的函数
 * @param u 传递给函数的用户数据
 * @param oldtop 调用前的栈顶位置
 * @param ef 错误处理函数位置
 * @return 执行状态：0表示成功，非零表示错误类型
 * 
 * @note 这是实现pcall和xpcall的基础
 * @see Pfunc类型定义，错误处理相关函数
 */
LUAI_FUNC int luaD_pcall(lua_State *L, Pfunc func, void *u, ptrdiff_t oldtop, ptrdiff_t ef);

/**
 * @brief 函数调用后处理
 * 
 * 详细说明：
 * 处理函数调用完成后的清理工作，包括返回值整理、调用栈维护、
 * 钩子触发等。这是函数调用流程的最后阶段。
 * 
 * 后处理任务：
 * 
 * 1. **返回值处理**：
 *    - 整理函数的返回值
 *    - 调整栈以匹配期望的返回值数量
 *    - 处理多返回值的情况
 * 
 * 2. **调用栈维护**：
 *    - 恢复调用者的CallInfo
 *    - 清理被调用函数的栈帧
 *    - 更新栈顶指针
 * 
 * 3. **钩子和调试**：
 *    - 触发函数返回钩子
 *    - 更新调试信息
 *    - 维护调用统计
 * 
 * 返回值调整：
 * - 根据调用时指定的nresults调整返回值数量
 * - 不足的返回值用nil填充
 * - 多余的返回值被丢弃
 * - 特殊处理LUA_MULTRET情况
 * 
 * 栈状态恢复：
 * - firstResult指向第一个返回值的位置
 * - 调整L->top以反映正确的栈顶
 * - 确保调用者看到正确的栈状态
 * 
 * @param L Lua状态机指针
 * @param firstResult 指向第一个返回值的栈位置
 * @return 实际的返回值数量
 * 
 * @note 这个函数通常由luaD_call和luaD_precall内部调用
 * @see luaD_call(), luaD_precall()
 */
LUAI_FUNC int luaD_poscall(lua_State *L, StkId firstResult);

/* ============================================================================
 * 栈和内存管理接口
 * ============================================================================ */

/**
 * @brief 重新分配CallInfo数组
 * 
 * 详细说明：
 * 调整CallInfo数组的大小以支持更深的函数调用嵌套。当调用深度
 * 超过当前数组容量时，需要扩展数组来避免栈溢出。
 * 
 * @param L Lua状态机指针
 * @param newsize 新的CallInfo数组大小
 */
LUAI_FUNC void luaD_reallocCI(lua_State *L, int newsize);

/**
 * @brief 重新分配栈空间
 * 
 * 详细说明：
 * 调整Lua栈的大小，可以扩展或收缩栈空间。这是栈管理的核心函数，
 * 确保栈有足够的空间同时避免内存浪费。
 * 
 * @param L Lua状态机指针
 * @param newsize 新的栈大小（TValue元素数量）
 */
LUAI_FUNC void luaD_reallocstack(lua_State *L, int newsize);

/**
 * @brief 扩展栈空间
 * 
 * 详细说明：
 * 确保栈有至少n个额外的空闲位置。如果当前空间不足，会自动
 * 扩展栈以满足需求。
 * 
 * @param L Lua状态机指针
 * @param n 需要的额外栈空间数量
 */
LUAI_FUNC void luaD_growstack(lua_State *L, int n);

/* ============================================================================
 * 错误处理和异常管理接口
 * ============================================================================ */

/**
 * @brief 抛出Lua异常
 * 
 * 详细说明：
 * 抛出指定类型的Lua异常，通过longjmp机制跳转到最近的错误处理点。
 * 这是Lua错误处理系统的核心函数。
 * 
 * @param L Lua状态机指针
 * @param errcode 错误代码
 * @throws 通过longjmp抛出异常，不会正常返回
 */
LUAI_FUNC void luaD_throw(lua_State *L, int errcode);

/**
 * @brief 原始保护执行
 * 
 * 详细说明：
 * 在最基本的保护环境中执行函数，这是所有保护执行的基础。
 * 
 * @param L Lua状态机指针
 * @param f 要执行的保护函数
 * @param ud 用户数据
 * @return 执行状态：0表示成功，非零表示错误
 */
LUAI_FUNC int luaD_rawrunprotected(lua_State *L, Pfunc f, void *ud);

/**
 * @brief 设置错误对象
 * 
 * 详细说明：
 * 在错误处理过程中设置适当的错误对象，并调整栈状态。
 * 
 * @param L Lua状态机指针
 * @param errcode 错误代码
 * @param oldtop 错误发生前的栈顶位置
 */
LUAI_FUNC void luaD_seterrorobj(lua_State *L, int errcode, StkId oldtop);

#endif

