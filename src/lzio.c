/**
 * @file lzio.c
 * @brief Lua通用输入流接口：为词法分析和解析提供统一的缓冲输入流抽象
 * 
 * 详细说明：
 * 这个文件实现了Lua解释器的通用输入流接口（ZIO - Zio Input/Output），
 * 为Lua的词法分析器和解析器提供了统一的、高效的输入数据访问机制。
 * 它抽象了不同的数据源（文件、字符串、内存缓冲区等），提供一致的
 * 读取接口，并通过缓冲机制优化I/O性能。
 * 
 * 系统架构定位：
 * 作为Lua编译系统的底层组件，本模块位于词法分析器之下，为上层的
 * token扫描和语法分析提供字节流服务。它是Lua源码编译流水线的
 * 起点，负责高效地向编译器前端供应源代码数据。
 * 
 * 技术特点：
 * - 统一抽象：通过回调函数支持多种输入源
 * - 缓冲优化：减少系统调用，提升I/O性能
 * - 前瞻支持：提供单字符前瞻，便于词法分析
 * - 内存安全：严格的边界检查和错误处理
 * - 可扩展缓冲区：动态调整缓冲区大小以适应不同需求
 * 
 * 依赖关系：
 * - 标准C库：string.h（内存操作）
 * - Lua核心API：lua.h（基础类型定义）
 * - Lua内部模块：llimits.h（限制和常量）、lmem.h（内存管理）
 * - Lua状态管理：lstate.h（虚拟机状态）
 * - 自身头文件：lzio.h（接口定义）
 * 
 * 编译要求：
 * - C标准版本：C89/C90兼容
 * - 编译器要求：支持函数指针和结构体
 * - 定义：LUA_CORE（表示这是Lua核心模块）
 * 
 * 使用示例：
 * @code
 * // 从文件创建输入流
 * ZIO z;
 * FILE *f = fopen("script.lua", "r");
 * luaZ_init(L, &z, file_reader, f);
 * 
 * // 读取数据
 * char buffer[256];
 * size_t bytes_read = luaZ_read(&z, buffer, sizeof(buffer));
 * 
 * // 前瞻下一个字符
 * int next_char = luaZ_lookahead(&z);
 * if (next_char != EOZ) {
 *     // 处理字符
 * }
 * @endcode
 * 
 * 内存安全考虑：
 * 所有缓冲区操作都经过严格的边界检查，动态缓冲区通过Lua的内存管理
 * 系统分配和释放。错误处理机制确保在内存不足或I/O错误时能够
 * 安全地终止操作并报告错误。
 * 
 * 性能特征：
 * - 缓冲I/O：大幅减少系统调用次数，提升整体性能
 * - 前瞻优化：单字符前瞻不需要额外的I/O操作
 * - 内存效率：缓冲区大小可根据需要动态调整
 * - 零拷贝：在可能的情况下避免不必要的数据复制
 * 
 * 线程安全性：
 * 输入流对象是线程局部的，每个lua_State使用独立的ZIO实例。
 * 内部使用Lua的锁机制（lua_lock/lua_unlock）确保与虚拟机的
 * 线程安全协调。
 * 
 * 注意事项：
 * - ZIO实例的生命周期必须与相关的lua_State匹配
 * - 读取器函数必须是可重入的
 * - 缓冲区内容在下次fill操作后可能失效
 * 
 * @author Roberto Ierusalimschy and Lua Team
 * @version 5.1.5
 * @date 2007/12/27
 * @since Lua 5.0
 * @see lzio.h, llex.c, lparser.c
 */

#include <string.h>

#define lzio_c
#define LUA_CORE

#include "lua.h"

#include "llimits.h"
#include "lmem.h"
#include "lstate.h"
#include "lzio.h"


/**
 * @brief 缓冲区填充：从输入源读取数据填充内部缓冲区
 * 
 * 详细说明：
 * 这是ZIO系统的核心函数，负责从底层输入源读取数据并填充内部缓冲区。
 * 当缓冲区为空时，词法分析器会调用此函数来获取更多的输入数据。
 * 它通过回调函数与各种输入源（文件、字符串、网络等）进行交互，
 * 实现了输入源的完全抽象化。
 * 
 * 算法描述：
 * 1. 临时解锁Lua状态，允许读取操作（可能涉及I/O阻塞）
 * 2. 调用注册的读取器函数从输入源获取数据
 * 3. 重新锁定Lua状态，恢复虚拟机的线程安全
 * 4. 检查读取结果，处理EOF和错误情况
 * 5. 设置缓冲区指针和计数器，返回第一个字符
 * 
 * 算法复杂度：
 * - 时间复杂度：O(1)，不考虑底层I/O操作的时间
 * - 空间复杂度：O(1)，只使用常量额外空间
 * - I/O复杂度：依赖于底层读取器的实现
 * 
 * 线程安全机制：
 * 函数使用lua_unlock/lua_lock对来管理线程同步。在调用可能阻塞的
 * I/O操作之前释放锁，避免阻塞其他线程，操作完成后重新获取锁。
 * 
 * 错误处理：
 * - 读取器返回NULL：表示输入结束或错误
 * - 返回大小为0：同样表示输入结束
 * - 两种情况都返回EOZ（End Of Zone）标记
 * 
 * 缓冲区管理：
 * 函数假设至少能读取到一个字节，并立即消费第一个字节作为返回值。
 * 这种设计优化了常见的字符消费模式。
 * 
 * 使用模式：
 * 此函数通常由luaZ_zgetc宏间接调用，当缓冲区空时自动触发填充操作。
 * 直接调用较少，主要用于初始化和特殊的缓冲区管理场景。
 * 
 * 性能考虑：
 * - 锁的开销：解锁/加锁操作有一定开销，但避免了I/O阻塞
 * - 批量读取：一次读取多个字节，摊销I/O成本
 * - 缓存友好：连续内存访问模式
 * 
 * @param[in,out] z ZIO输入流指针，包含输入源信息和缓冲区状态
 *                  z->L: Lua虚拟机状态，用于线程同步
 *                  z->reader: 读取器回调函数
 *                  z->data: 传递给读取器的用户数据
 * 
 * @return 读取的第一个字符的整数值，或EOF标记
 * @retval >=0    成功读取，返回第一个字符的值（0-255）
 * @retval EOZ    输入结束或读取错误
 * 
 * @pre z != NULL && z->L != NULL && z->reader != NULL
 * @post 成功时：z->p指向缓冲区中下一个字符，z->n为剩余字符数
 * @post 失败时：缓冲区状态不变，返回EOZ
 * 
 * @note 函数会临时释放Lua锁，调用者需要注意线程安全
 * @note 读取器函数必须是线程安全的或在单线程环境中使用
 * @note 返回的字符已从缓冲区中移除
 * 
 * @warning 不要在持有其他Lua对象引用时调用，锁释放可能导致GC
 * @warning 读取器函数不应调用Lua API或访问Lua对象
 * 
 * @since Lua 5.0
 * @see luaZ_lookahead(), luaZ_zgetc(), char2int()
 */
int luaZ_fill(ZIO *z) {
    size_t size;
    lua_State *L = z->L;
    const char *buff;
    
    lua_unlock(L);                                  // 释放锁，允许I/O操作
    buff = z->reader(L, z->data, &size);            // 调用读取器获取数据
    lua_lock(L);                                    // 重新获取锁
    
    // 检查读取结果：NULL或大小为0表示输入结束
    if (buff == NULL || size == 0) {
        return EOZ;
    }
    
    // 设置缓冲区状态：减1是因为要立即返回第一个字符
    z->n = size - 1;                               // 剩余字符数
    z->p = buff;                                   // 缓冲区指针
    
    // 返回第一个字符并移动指针
    return char2int(*(z->p++));
}


/**
 * @brief 前瞻读取：查看下一个字符而不消费它
 * 
 * 详细说明：
 * 这个函数实现了单字符前瞻功能，允许词法分析器查看下一个输入字符
 * 而不实际消费它。这是词法分析中的常见需求，用于决定如何解析当前
 * token或确定下一个token的类型。函数采用惰性求值策略，只在需要时
 * 才触发缓冲区填充。
 * 
 * 算法描述：
 * 1. 检查缓冲区是否为空（n == 0）
 * 2. 如果为空，尝试填充缓冲区
 * 3. 如果填充失败（达到输入末尾），返回EOZ
 * 4. 如果填充成功，需要"撤销"fill操作的副作用
 * 5. 返回当前位置的字符（不移动指针）
 * 
 * 撤销机制：
 * luaZ_fill函数会消费并返回第一个字符，但前瞻操作不应该消费字符。
 * 因此需要通过增加计数器(n++)和回退指针(p--)来撤销这个副作用。
 * 
 * 算法复杂度：
 * - 时间复杂度：O(1)，除非需要触发缓冲区填充
 * - 空间复杂度：O(1)，不使用额外存储空间
 * - 摊销复杂度：由于缓冲机制，平均性能很好
 * 
 * 使用场景：
 * - 词法分析：确定token边界和类型
 * - 语法分析：预测分析中的look-ahead
 * - 条件解析：根据下一个字符决定解析策略
 * 
 * 性能优化：
 * 大多数情况下，函数只需要检查计数器和返回字符，没有I/O开销。
 * 只有在缓冲区为空时才会触发相对昂贵的填充操作。
 * 
 * 设计模式：
 * 这是一个典型的惰性求值模式，延迟昂贵操作直到真正需要时才执行。
 * 结合缓冲机制，提供了高效的输入流访问。
 * 
 * @param[in,out] z ZIO输入流指针，包含缓冲区状态信息
 *                  z->n: 缓冲区中剩余字符数
 *                  z->p: 当前读取位置指针
 * 
 * @return 下一个字符的整数值，不移动读取位置
 * @retval >=0    成功前瞻，返回下一个字符的值（0-255）
 * @retval EOZ    输入结束或读取错误
 * 
 * @pre z != NULL
 * @post 缓冲区读取位置不变
 * @post 如果触发了填充，缓冲区包含新数据
 * 
 * @note 连续多次调用返回相同的结果
 * @note 下次实际读取操作会消费这个字符
 * @note 如果缓冲区为空，可能触发I/O操作
 * 
 * @since Lua 5.0
 * @see luaZ_fill(), luaZ_zgetc()
 */
int luaZ_lookahead(ZIO *z) {
    if (z->n == 0) {
        // 缓冲区为空，尝试填充
        if (luaZ_fill(z) == EOZ) {
            return EOZ;                             // 输入结束
        } else {
            // 撤销fill操作的副作用：恢复被消费的字符
            z->n++;                                 // 恢复字符计数
            z->p--;                                 // 回退指针位置
        }
    }
    
    // 返回当前位置的字符（不移动指针）
    return char2int(*z->p);
}


/**
 * @brief ZIO输入流初始化：设置输入流的基本参数和回调函数
 * 
 * 详细说明：
 * 这个函数负责初始化ZIO输入流对象，设置必要的回调函数和用户数据。
 * 它建立了输入流与特定数据源之间的连接，为后续的读取操作做好准备。
 * 这是使用ZIO系统的第一步，必须在任何读取操作之前调用。
 * 
 * 初始化内容：
 * - 关联Lua虚拟机状态：用于内存管理和错误处理
 * - 设置读取器回调：定义如何从输入源获取数据
 * - 保存用户数据：传递给读取器的上下文信息
 * - 重置缓冲区状态：清空计数器和指针
 * 
 * 回调函数模式：
 * 通过函数指针实现的回调机制，允许ZIO系统适配各种输入源：
 * - 文件输入：从FILE*读取
 * - 字符串输入：从内存缓冲区读取
 * - 网络输入：从socket读取
 * - 自定义输入：用户定义的任意数据源
 * 
 * 设计原则：
 * - 零状态初始化：所有计数器和指针都设为安全的初始值
 * - 延迟加载：实际的数据读取延迟到第一次访问时
 * - 类型安全：通过void*实现通用性，但保持类型检查
 * 
 * 内存管理：
 * 函数本身不分配内存，只是设置指针和计数器。实际的缓冲区内存
 * 由读取器函数管理，ZIO只是引用这些外部管理的内存。
 * 
 * 线程安全：
 * 初始化操作本身是线程安全的，但后续的使用必须在正确的线程
 * 上下文中进行，特别是与传入的lua_State相关联的线程。
 * 
 * @param[in] L Lua虚拟机状态指针，用于内存管理和错误处理
 * @param[out] z 要初始化的ZIO输入流对象指针
 * @param[in] reader 读取器回调函数，用于从输入源获取数据
 * @param[in] data 用户数据指针，将传递给读取器函数
 * 
 * @pre L != NULL && z != NULL && reader != NULL
 * @post z已完全初始化，可以进行读取操作
 * @post z->n == 0 && z->p == NULL（缓冲区为空状态）
 * 
 * @note data参数可以为NULL，具体取决于读取器的要求
 * @note 初始化后的ZIO对象必须与传入的lua_State保持关联
 * @note 读取器函数的生命周期必须覆盖ZIO对象的使用期间
 * 
 * @since Lua 5.0
 * @see lua_Reader, luaZ_fill(), luaZ_read()
 */
void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader, void *data) {
    z->L = L;                                       // 关联Lua虚拟机状态
    z->reader = reader;                             // 设置读取器回调函数
    z->data = data;                                 // 保存用户数据指针
    z->n = 0;                                       // 缓冲区字符计数初始化为0
    z->p = NULL;                                    // 缓冲区指针初始化为NULL
}


/**
 * =====================================================================
 * 批量读取接口 - 高效的多字节读取操作
 * =====================================================================
 */

/**
 * @brief 批量数据读取：从输入流读取指定数量的字节到缓冲区
 * 
 * 详细说明：
 * 这个函数提供了高效的批量数据读取功能，可以一次性读取多个字节到
 * 目标缓冲区。它是ZIO系统的高级接口，在需要读取大量数据时比逐字符
 * 读取更加高效。函数会尽力读取请求的字节数，但可能因为输入结束而
 * 读取到较少的数据。
 * 
 * 算法描述：
 * 1. 循环直到读取完成或遇到输入结束
 * 2. 使用前瞻检查是否还有数据可读
 * 3. 计算当前批次能读取的最大字节数
 * 4. 使用memcpy高效复制数据到目标缓冲区
 * 5. 更新缓冲区状态和目标缓冲区指针
 * 6. 继续下一轮读取直到完成或输入结束
 * 
 * 算法复杂度：
 * - 时间复杂度：O(n)，其中n为请求读取的字节数
 * - 空间复杂度：O(1)，不使用额外存储空间
 * - I/O复杂度：取决于底层缓冲区填充的次数
 * 
 * 优化策略：
 * - 批量复制：使用memcpy进行高效的内存复制
 * - 缓冲区复用：充分利用现有缓冲区中的数据
 * - 最小化I/O：只在必要时才触发新的缓冲区填充
 * 
 * 错误处理：
 * 函数采用部分成功模式，即使不能读取全部请求的数据，也会返回
 * 实际读取的数据。调用者可以通过返回值判断是否读取完整。
 * 
 * 内存安全：
 * - 使用memcpy进行安全的内存复制
 * - 严格的边界检查，防止缓冲区溢出
 * - 正确的指针算术，避免内存访问错误
 * 
 * 性能特征：
 * - 大数据优势：对于大块数据读取，性能显著优于逐字符读取
 * - 缓存友好：连续内存访问模式，缓存命中率高
 * - 系统调用优化：减少系统调用次数，降低开销
 * 
 * 使用场景：
 * - 二进制数据读取：读取数值、结构体等固定大小数据
 * - 字符串块读取：读取已知长度的字符串
 * - 缓冲区填充：为其他处理模块提供数据
 * - 文件内容读取：读取整个文件或大段内容
 * 
 * @param[in,out] z ZIO输入流指针，提供数据源
 * @param[out] b 目标缓冲区指针，用于存储读取的数据
 * @param[in] n 请求读取的字节数
 * 
 * @return 未能读取的字节数（0表示完全成功）
 * @retval 0      成功读取了所有请求的字节
 * @retval >0     部分读取，返回值为剩余未读取的字节数
 * 
 * @pre z != NULL && b != NULL
 * @pre n == 0 或 b指向至少n字节的有效内存
 * @post 目标缓冲区包含从输入流读取的数据
 * @post 返回值 <= n
 * 
 * @note 返回值为0表示完全成功，非零表示遇到输入结束
 * @note 函数可能修改目标缓冲区的内容，即使未完全成功
 * @note 对于n=0的调用，函数立即返回0
 * 
 * @warning 调用者必须确保目标缓冲区有足够的空间
 * @warning 部分读取时，缓冲区可能包含不完整的数据结构
 * 
 * @since Lua 5.0
 * @see luaZ_lookahead(), memcpy()
 */
size_t luaZ_read(ZIO *z, void *b, size_t n) {
    while (n) {
        size_t m;
        
        // 检查是否还有数据可读
        if (luaZ_lookahead(z) == EOZ) {
            return n;                               // 返回剩余未读取的字节数
        }
        
        // 计算当前批次能读取的字节数：取n和z->n的最小值
        m = (n <= z->n) ? n : z->n;
        
        // 高效复制数据到目标缓冲区
        memcpy(b, z->p, m);
        
        // 更新输入流状态
        z->n -= m;                                  // 减少剩余字符计数
        z->p += m;                                  // 移动缓冲区指针
        
        // 更新目标缓冲区指针和剩余计数
        b = (char *)b + m;                          // 移动目标指针
        n -= m;                                     // 减少剩余读取计数
    }
    
    return 0;                                       // 完全成功
}

/**
 * =====================================================================
 * 动态缓冲区管理系统 - 可扩展内存缓冲区
 * =====================================================================
 */

/**
 * @brief 开辟缓冲区空间：确保缓冲区有足够的空间容纳指定大小的数据
 * 
 * 详细说明：
 * 这个函数管理动态可扩展的内存缓冲区（Mbuffer），确保缓冲区至少能
 * 容纳指定大小的数据。如果当前缓冲区太小，函数会自动扩展缓冲区大小。
 * 它还实现了最小缓冲区大小策略，避免频繁的小规模重分配操作。
 * 
 * 算法描述：
 * 1. 检查请求的大小是否超过当前缓冲区容量
 * 2. 如果需要扩展，应用最小缓冲区大小策略
 * 3. 调用缓冲区调整函数重新分配内存
 * 4. 返回指向缓冲区的指针
 * 
 * 缓冲区策略：
 * - 按需分配：只有在需要时才扩展缓冲区
 * - 最小大小保证：确保缓冲区至少为LUA_MINBUFFER大小
 * - 内存复用：尽可能复用现有的缓冲区空间
 * 
 * 性能优化：
 * - 避免频繁分配：通过最小大小策略减少重分配次数
 * - 内存局部性：连续的内存分配有利于缓存性能
 * - 摊销成本：大缓冲区摊销了内存管理的开销
 * 
 * 内存管理：
 * 实际的内存分配和释放由luaZ_resizebuffer函数处理，该函数使用
 * Lua的内存管理系统，确保与垃圾回收器的正确协调。
 * 
 * 错误处理：
 * 如果内存分配失败，luaZ_resizebuffer会抛出Lua错误，因此这个
 * 函数要么成功返回有效指针，要么通过异常终止。
 * 
 * 线程安全：
 * 函数依赖于Lua的内存管理系统的线程安全性。在多线程环境中，
 * 必须确保每个缓冲区只被一个线程访问。
 * 
 * 使用模式：
 * 通常在需要临时存储可变长度数据时使用，如：
 * - 词法分析中的token缓冲
 * - 字符串构建和拼接
 * - 临时数据处理缓冲区
 * 
 * @param[in] L Lua虚拟机状态指针，用于内存管理和错误处理
 * @param[in,out] buff 要管理的缓冲区对象指针
 *                     buff->buffer: 当前缓冲区指针
 *                     buff->buffsize: 当前缓冲区大小
 * @param[in] n 需要的最小缓冲区大小（字节数）
 * 
 * @return 指向缓冲区的字符指针，保证至少有n字节空间
 * @retval char* 有效的缓冲区指针，可安全写入n字节数据
 * 
 * @pre L != NULL && buff != NULL && n >= 0
 * @post buff->buffer指向至少n字节的有效内存
 * @post buff->buffsize >= max(n, LUA_MINBUFFER)
 * @post 返回值 == buff->buffer
 * 
 * @note 如果n <= buff->buffsize，函数不会重新分配内存
 * @note 缓冲区大小只会增长，不会缩小
 * @note 重新分配后，原缓冲区内容可能会被复制到新位置
 * 
 * @warning 重新分配可能使之前的缓冲区指针失效
 * @warning 内存不足时会抛出Lua错误，不会返回NULL
 * 
 * @since Lua 5.0
 * @see luaZ_resizebuffer(), Mbuffer, LUA_MINBUFFER
 */
char *luaZ_openspace(lua_State *L, Mbuffer *buff, size_t n) {
    // 检查是否需要扩展缓冲区
    if (n > buff->buffsize) {
        // 应用最小缓冲区大小策略
        if (n < LUA_MINBUFFER) {
            n = LUA_MINBUFFER;
        }
        
        // 调整缓冲区大小到新的容量
        luaZ_resizebuffer(L, buff, n);
    }
    
    // 返回指向缓冲区的指针
    return buff->buffer;
}


