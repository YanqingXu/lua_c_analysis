/*
** [核心] Lua 缓冲I/O接口实现
**
** 功能概述：
** 本模块实现了Lua的通用输入流接口，为词法分析器和其他需要流式输入的模块
** 提供统一的数据读取抽象。通过ZIO结构体封装了不同的数据源（文件、字符串、
** 内存块等），提供一致的字节流读取接口。
**
** 主要组件：
** - ZIO结构体：缓冲I/O状态管理
** - 数据填充机制：按需从数据源读取数据
** - 前瞻读取：支持不消费数据的预读操作
** - 缓冲区管理：动态调整缓冲区大小
**
** 设计特点：
** - 延迟加载：仅在需要时才从数据源读取数据
** - 缓冲优化：减少频繁的系统调用
** - 统一接口：不同数据源使用相同的API
** - 错误处理：优雅处理EOF和读取错误
**
** 依赖模块：
** - lmem.c：内存管理功能
** - lstate.c：Lua状态机访问
** - llimits.h：平台相关的限制定义
*/

#include <string.h>

#define lzio_c
#define LUA_CORE

#include "lua.h"

#include "llimits.h"
#include "lmem.h"
#include "lstate.h"
#include "lzio.h"


/*
** [核心] 从输入流中填充缓冲区
**
** 详细功能说明：
** 当ZIO缓冲区为空时，调用此函数从底层数据源读取新数据。
** 使用reader函数从data指向的数据源读取数据，更新缓冲区状态，
** 并返回第一个可用字节。
**
** 参数说明：
** @param z - ZIO*：ZIO输入流对象指针
**
** 返回值：
** @return int：成功时返回第一个字节(0-255)，失败或EOF时返回EOZ(-1)
**
** 算法复杂度：O(1) 时间，O(1) 空间
**
** 执行流程：
** 1. 解锁Lua状态机（允许reader回调函数执行）
** 2. 调用reader函数从数据源读取数据
** 3. 重新锁定Lua状态机
** 4. 检查读取结果，更新缓冲区状态
** 5. 返回第一个可用字节或EOF标志
**
** 注意事项：
** - reader函数可能触发Lua代码执行，因此需要解锁状态机
** - 返回值包含第一个字节，同时将缓冲区指针前移
** - 空数据或NULL返回值都被视为EOF条件
*/
int luaZ_fill(ZIO *z)
{
    size_t size;
    lua_State *L = z->L;
    const char *buff;
    
    /*
    ** [线程安全] 解锁状态机允许reader回调执行
    ** reader函数可能需要访问Lua状态或执行Lua代码
    */
    lua_unlock(L);
    
    /*
    ** [数据读取] 调用reader函数获取新数据
    ** reader是用户提供的回调函数，负责从具体数据源读取
    */
    buff = z->reader(L, z->data, &size);
    
    /*
    ** [状态恢复] 重新锁定状态机保证线程安全
    */
    lua_lock(L);
    
    /*
    ** [EOF检查] 检查是否到达数据流末尾
    ** NULL指针或0大小都表示没有更多数据可读
    */
    if (buff == NULL || size == 0) 
    {
        return EOZ;
    }
    
    /*
    ** [缓冲区更新] 设置新的缓冲区状态
    ** n保存剩余字节数（减1是因为要返回第一个字节）
    ** p指向当前读取位置
    */
    z->n = size - 1;
    z->p = buff;
    
    /*
    ** [返回首字节] 返回缓冲区第一个字节并前移指针
    ** char2int宏确保返回值在0-255范围内
    */
    return char2int(*(z->p++));
}


/*
** [进阶] 前瞻读取一个字节但不消费
**
** 详细功能说明：
** 返回输入流中下一个字节的值，但不从流中移除该字节。
** 后续的读取操作仍然可以获取这个字节。如果缓冲区为空，
** 会自动填充缓冲区，但会恢复缓冲区指针位置。
**
** 参数说明：
** @param z - ZIO*：ZIO输入流对象指针
**
** 返回值：
** @return int：下一个字节值(0-255)，或EOF时返回EOZ(-1)
**
** 算法复杂度：O(1) 时间，O(1) 空间
**
** 实现原理：
** 1. 检查缓冲区是否有数据
** 2. 如果为空，调用luaZ_fill填充
** 3. 如果填充成功，回退缓冲区指针
** 4. 返回当前指针位置的字节
**
** 使用场景：
** - 词法分析器需要预读字符判断token类型
** - 解析器需要根据下一个字符决定解析路径
** - 任何需要"看一眼但不消费"的场景
*/
int luaZ_lookahead(ZIO *z)
{
    /*
    ** [缓冲区检查] 检查是否有可用数据
    */
    if (z->n == 0) 
    {
        /*
        ** [自动填充] 缓冲区为空时自动填充
        */
        if (luaZ_fill(z) == EOZ)
        {
            return EOZ;
        }
        else 
        {
            /*
            ** [状态恢复] luaZ_fill消费了第一个字节，需要恢复
            ** 增加剩余字节数，回退指针位置
            */
            z->n++;
            z->p--;
        }
    }
    
    /*
    ** [返回预览] 返回当前指针位置的字节但不移动指针
    */
    return char2int(*z->p);
}


/*
** [入门] 初始化ZIO输入流对象
**
** 详细功能说明：
** 设置ZIO对象的初始状态，关联Lua状态机、reader函数和数据源。
** 初始化后的ZIO对象可以用于流式读取数据。
**
** 参数说明：
** @param L - lua_State*：Lua状态机指针
** @param z - ZIO*：要初始化的ZIO对象指针
** @param reader - lua_Reader：数据读取回调函数
** @param data - void*：传递给reader函数的用户数据
**
** 返回值：无
**
** 算法复杂度：O(1) 时间，O(1) 空间
**
** 初始化状态：
** - 关联Lua状态机以支持内存分配等操作
** - 设置reader函数用于数据读取
** - 保存用户数据指针
** - 清空缓冲区状态（延迟到首次读取时填充）
**
** 使用示例：
** ```c
** ZIO z;
** luaZ_init(L, &z, file_reader, file_handle);
** int c = luaZ_lookahead(&z);  // 读取第一个字节
** ```
*/
void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader, void *data)
{
    /* 关联Lua状态机 */
    z->L = L;
    /* 设置数据读取函数 */
    z->reader = reader;
    /* 保存用户数据指针 */
    z->data = data;
    /* 缓冲区初始为空 */
    z->n = 0;
    /* 缓冲区指针初始为空 */
    z->p = NULL;
}


/*
** [进阶] 从输入流中读取指定数量的字节
**
** 详细功能说明：
** 从ZIO输入流中读取最多n个字节到缓冲区b中。如果流中没有足够的数据，
** 则读取所有可用数据。返回值表示还有多少字节没有读取到。
**
** 参数说明：
** @param z - ZIO*：ZIO输入流对象指针
** @param b - void*：目标缓冲区指针
** @param n - size_t：要读取的字节数
**
** 返回值：
** @return size_t：未能读取的字节数（0表示完全成功）
**
** 算法复杂度：O(n) 时间，O(1) 空间
**
** 读取策略：
** 1. 循环直到读取完成或遇到EOF
** 2. 使用lookahead检查数据可用性
** 3. 计算本次可读取的字节数
** 4. 使用memcpy批量复制数据
** 5. 更新各种指针和计数器
**
** 优化特点：
** - 批量复制减少函数调用开销
** - 利用现有缓冲区避免重复填充
** - 处理跨缓冲区边界的读取
*/
size_t luaZ_read(ZIO *z, void *b, size_t n)
{
    /*
    ** [批量读取] 循环读取直到完成或EOF
    */
    while (n) 
    {
        size_t m;
        
        /*
        ** [可用性检查] 确保有数据可读
        */
        if (luaZ_lookahead(z) == EOZ)
        {
            return n;  /* 返回未读取的字节数 */
        }
        
        /*
        ** [读取量计算] 本次最多能读取的字节数
        ** 取请求字节数和缓冲区剩余数的最小值
        */
        m = (n <= z->n) ? n : z->n;
        
        /*
        ** [数据复制] 批量复制数据到目标缓冲区
        */
        memcpy(b, z->p, m);
        
        /*
        ** [状态更新] 更新ZIO缓冲区状态
        */
        z->n -= m;                    /* 减少剩余字节数 */
        z->p += m;                    /* 前移缓冲区指针 */
        
        /*
        ** [目标更新] 更新目标缓冲区状态
        */
        b = (char *)b + m;            /* 前移目标指针 */
        n -= m;                       /* 减少剩余需求 */
    }
    
    /*
    ** [完成标志] 所有数据都已成功读取
    */
    return 0;
}


/*
** [高级] 为缓冲区分配指定大小的空间
**
** 详细功能说明：
** 确保Mbuffer缓冲区至少有n个字节的可用空间。如果当前缓冲区
** 不够大，会重新分配更大的缓冲区。应用最小缓冲区大小限制。
**
** 参数说明：
** @param L - lua_State*：Lua状态机指针，用于内存分配
** @param buff - Mbuffer*：要调整的缓冲区对象
** @param n - size_t：需要的最小空间大小
**
** 返回值：
** @return char*：指向缓冲区起始位置的指针
**
** 算法复杂度：O(1) 平均时间，O(n) 最坏时间（重新分配）
**
** 内存管理策略：
** - 仅在需要时进行重新分配（避免不必要的开销）
** - 应用最小缓冲区大小限制（提高效率）
** - 使用Lua的内存管理器（统一内存管理）
**
** 使用场景：
** - 词法分析器需要累积token内容
** - 解析器需要构建中间字符串
** - 任何需要动态增长缓冲区的场景
**
** 注意事项：
** - 可能触发垃圾回收和内存重新分配
** - 返回的指针在下次调用前有效
** - 缓冲区内容在重新分配后保持不变
*/
char *luaZ_openspace(lua_State *L, Mbuffer *buff, size_t n)
{
    /*
    ** [容量检查] 检查当前缓冲区是否足够大
    */
    if (n > buff->buffsize) 
    {
        /*
        ** [最小限制] 应用最小缓冲区大小限制
        ** 避免频繁的小幅重新分配
        */
        if (n < LUA_MINBUFFER) 
        {
            n = LUA_MINBUFFER;
        }
        
        /*
        ** [缓冲区扩展] 重新分配更大的缓冲区
        ** luaZ_resizebuffer宏处理实际的内存重新分配
        */
        luaZ_resizebuffer(L, buff, n);
    }
    
    /*
    ** [返回指针] 返回可用缓冲区的起始地址
    */
    return buff->buffer;
}