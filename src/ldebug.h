/*
** ====================================================================
** Lua 调试接口模块头文件 (ldebug.h)
** ====================================================================
** 
** 文件标识: $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
** 功能描述: 调试接口模块的辅助函数声明
** 版权信息: 参见 lua.h 中的版权声明
** 
** 模块概述:
** 本头文件定义了 Lua 虚拟机调试系统的核心接口，包括错误处理、
** 调试信息管理、代码验证和运行时诊断功能。这些函数为 Lua 的
** 错误报告、调试器支持和代码验证提供了基础设施。
** 
** 主要功能领域:
** 1. 错误处理与报告 - 类型错误、运算错误、运行时错误
** 2. 调试信息管理 - 行号映射、程序计数器转换
** 3. 代码验证 - 字节码合法性检查
** 4. 调试钩子管理 - 钩子计数器重置
** 5. 运行时诊断 - 错误消息生成和传播
** 
** 设计目标:
** - 提供完整的错误诊断和报告机制
** - 支持源码级调试和性能分析
** - 确保字节码的完整性和安全性
** - 为开发工具提供丰富的调试接口
** 
** 依赖关系:
** - lstate.h: Lua 状态管理和虚拟机结构
** - lobject.h: Lua 对象系统（间接依赖）
** - lopcodes.h: 虚拟机指令集（间接依赖）
** 
** 注意事项:
** - 错误处理函数可能触发长跳转，不会正常返回
** - 调试钩子可能影响程序执行性能
** - 代码验证函数用于内部一致性检查
** ====================================================================
*/

/*
** ====================================================================
** [预处理] 头文件保护和依赖包含
** ====================================================================
*/

#ifndef ldebug_h
#define ldebug_h

/*
** ====================================================================
** [依赖] 核心依赖模块包含
** ====================================================================
*/

/*
** [核心依赖] Lua 状态管理
** 
** 包含 lstate.h 以获取：
** - lua_State 结构体定义（虚拟机状态）
** - CallInfo 结构体定义（调用信息）
** - Proto 结构体定义（函数原型）
** - global_State 结构体定义（全局状态）
** - TValue 和相关类型定义
** - StkId 栈索引类型定义
*/
#include "lstate.h"


/*
** ====================================================================
** [实用] 调试信息处理宏定义
** ====================================================================
*/

/*
** [实用] 程序计数器相对位置计算宏
**
** 功能：计算程序计数器相对于函数开始位置的偏移量
** @param pc: Instruction* 当前程序计数器位置
** @param p: Proto* 函数原型指针
** @return: int 相对偏移量（从0开始的指令索引）
**
** 计算原理：
** - pc 指向当前执行的指令位置
** - p->code 指向函数字节码数组的开始
** - 减1是因为 pc 通常指向下一条要执行的指令
**
** 使用场景：
** - 错误报告中的精确位置定位
** - 调试器中断点的位置计算
** - 性能分析中的热点代码识别
** - 堆栈跟踪中的指令位置显示
**
** 注意事项：
** - 结果可能为负数（在某些边界情况下）
** - 调用者需要确保 pc 在有效范围内
** - 不进行边界检查，需要调用者保证安全性
*/
#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)

/*
** [实用] 指令行号获取宏
**
** 功能：获取指定程序计数器位置对应的源代码行号
** @param f: Proto* 函数原型指针
** @param pc: int 程序计数器偏移量
** @return: int 源代码行号，如果无行号信息则返回0
**
** 行号信息处理：
** - f->lineinfo 数组存储每条指令对应的行号
** - 如果没有调试信息，lineinfo 为 NULL
** - 行号从1开始计数，0表示无效或无行号信息
**
** 优化考虑：
** - 使用三元运算符避免函数调用开销
** - 直接数组访问，性能高效
** - 条件检查避免空指针解引用
**
** 应用场景：
** - 错误报告中显示出错的源代码行
** - 调试器中的源代码定位
** - 性能分析工具的源码标注
** - 堆栈跟踪的详细信息显示
*/
#define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)

/*
** [实用] 调试钩子计数器重置宏
**
** 功能：重置 Lua 状态的调试钩子计数器
** @param L: lua_State* Lua 虚拟机状态指针
**
** 钩子机制说明：
** - hookcount: 当前钩子计数器，每执行一条指令递减
** - basehookcount: 基础钩子间隔，重置时的目标值
** - 当 hookcount 为0时，触发调试钩子函数
**
** 钩子类型：
** - 指令钩子：每执行指定数量指令后触发
** - 行钩子：执行到新的源代码行时触发
** - 调用钩子：函数调用时触发
** - 返回钩子：函数返回时触发
**
** 性能影响：
** - 启用钩子会降低执行性能
** - 计数器操作的开销很小
** - 钩子函数的执行代价较大
**
** 使用时机：
** - 调试器启动时初始化钩子
** - 性能分析开始时设置采样间隔
** - 调试会话重新开始时重置状态
*/
#define resethookcount(L)	(L->hookcount = L->basehookcount)


/*
** ====================================================================
** [错误] 类型和运算错误处理函数
** ====================================================================
*/

/*
** [错误] 类型错误报告函数
**
** 功能：报告由于类型不匹配导致的运行时错误
** @param L: lua_State* Lua 虚拟机状态指针
** @param o: const TValue* 导致错误的 Lua 值对象
** @param opname: const char* 操作名称字符串
**
** 错误类型处理：
** - 算术运算的类型错误（如字符串参与数学运算）
** - 比较操作的类型错误（如表与数字比较）
** - 索引操作的类型错误（如对非表对象进行索引）
** - 函数调用的类型错误（如调用非函数对象）
**
** 错误信息生成：
** - 识别对象的实际类型
** - 生成易于理解的错误描述
** - 包含操作上下文信息
** - 提供调试所需的详细信息
**
** 调用约定：
** - 此函数不会正常返回
** - 通过 longjmp 机制抛出错误
** - 调用者无需处理返回值
** - 自动清理栈和资源
**
** 错误传播：
** 错误会沿调用链向上传播，直到被 pcall 或 xpcall 捕获。
*/
LUAI_FUNC void luaG_typeerror (lua_State *L, const TValue *o,
                                             const char *opname);

/*
** [错误] 字符串连接错误报告函数
**
** 功能：报告字符串连接操作中的类型错误
** @param L: lua_State* Lua 虚拟机状态指针
** @param p1: StkId 第一个操作数的栈位置
** @param p2: StkId 第二个操作数的栈位置
**
** 连接操作要求：
** - 操作数必须是字符串或数字类型
** - 数字会自动转换为字符串
** - 其他类型（如表、函数等）不能直接连接
**
** 错误诊断：
** - 识别哪个操作数导致了错误
** - 报告操作数的实际类型
** - 提供修正建议信息
** - 显示操作的上下文
**
** 特殊处理：
** - nil 值的特殊错误信息
** - 表或函数的类型说明
** - 用户数据的类型识别
** - 布尔值的处理说明
*/
LUAI_FUNC void luaG_concaterror (lua_State *L, StkId p1, StkId p2);

/*
** [错误] 算术运算错误报告函数
**
** 功能：报告算术运算中的类型错误
** @param L: lua_State* Lua 虚拟机状态指针
** @param p1: const TValue* 第一个操作数
** @param p2: const TValue* 第二个操作数
**
** 算术运算要求：
** - 操作数必须是数字类型
** - 字符串可以尝试转换为数字
** - 转换失败时报告类型错误
**
** 支持的运算：
** - 基本算术：+、-、*、/、%
** - 幂运算：^
** - 取负运算：-（一元）
**
** 错误分析：
** - 确定哪个操作数不是数字
** - 尝试字符串到数字的转换
** - 生成具体的错误信息
** - 提供类型转换建议
**
** 特殊情况：
** - 除零错误的特殊处理
** - NaN 和无穷大的处理
** - 科学计数法的识别
*/
LUAI_FUNC void luaG_aritherror (lua_State *L, const TValue *p1,
                                              const TValue *p2);

/*
** [错误] 比较操作错误报告函数
**
** 功能：报告比较操作中的类型错误
** @param L: lua_State* Lua 虚拟机状态指针
** @param p1: const TValue* 第一个操作数
** @param p2: const TValue* 第二个操作数
** @return: int 总是返回0（错误函数的约定）
**
** 比较操作规则：
** - 数字可以与数字比较
** - 字符串可以与字符串比较
** - 不同类型间的比较（除了数字和字符串的特殊情况）会出错
**
** 支持的比较：
** - 大小比较：<、<=、>、>=
** - 相等比较：==、~=
** - 元方法比较：通过元表定义的比较
**
** 错误生成：
** - 识别不兼容的类型组合
** - 解释比较操作的类型要求
** - 提供元方法的使用建议
** - 显示具体的类型名称
**
** 返回值约定：
** 虽然函数声明有返回值，但实际上会抛出错误，不会正常返回。
*/
LUAI_FUNC int luaG_ordererror (lua_State *L, const TValue *p1,
                                             const TValue *p2);
/*
** ====================================================================
** [错误] 通用错误处理和消息系统
** ====================================================================
*/

/*
** [错误] 运行时错误报告函数
**
** 功能：报告格式化的运行时错误信息
** @param L: lua_State* Lua 虚拟机状态指针
** @param fmt: const char* 格式化字符串（类似 printf）
** @param ...: 可变参数列表，对应格式化字符串中的占位符
**
** 格式化支持：
** - 标准 printf 风格的格式化字符串
** - 支持 %s（字符串）、%d（整数）、%f（浮点数）等
** - 自动处理参数类型转换
** - 支持 Lua 特定的格式化选项
**
** 错误信息构建：
** - 自动添加堆栈跟踪信息
** - 包含当前执行位置
** - 添加函数调用上下文
** - 格式化最终的错误消息
**
** 使用场景：
** - 虚拟机内部错误（如栈溢出）
** - 系统资源错误（如内存不足）
** - 用户定义的运行时检查
** - 断言失败的错误报告
**
** 错误传播：
** - 通过 longjmp 机制跳转到错误处理器
** - 自动清理局部资源
** - 维护错误状态的一致性
** - 支持错误链的构建
**
** 性能考虑：
** - 错误路径的性能不是关键
** - 优先考虑错误信息的完整性
** - 格式化开销可以接受
** - 堆栈遍历的时间成本
*/
LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);

/*
** [错误] 错误消息传播函数
**
** 功能：处理和传播已构建的错误消息
** @param L: lua_State* Lua 虚拟机状态指针
**
** 错误消息处理：
** - 错误对象已在栈顶
** - 添加堆栈跟踪信息
** - 格式化最终的错误显示
** - 触发错误处理流程
**
** 堆栈跟踪生成：
** - 遍历当前的调用栈
** - 收集每层调用的信息
** - 包含源文件名和行号
** - 显示函数名和参数信息
**
** 错误增强：
** - 添加上下文信息
** - 包含变量状态
** - 提供调试提示
** - 格式化输出
**
** 调用时机：
** - 捕获到 Lua 错误时
** - C 函数抛出错误时
** - 错误对象需要增强时
** - 手动错误传播时
**
** 注意事项：
** - 函数不会正常返回
** - 栈顶必须包含错误对象
** - 会修改错误对象的内容
** - 触发错误处理机制
*/
LUAI_FUNC void luaG_errormsg (lua_State *L);
/*
** ====================================================================
** [验证] 代码完整性检查函数
** ====================================================================
*/

/*
** [验证] 字节码合法性检查函数
**
** 功能：验证函数原型中字节码的合法性和一致性
** @param pt: const Proto* 函数原型指针
** @return: int 验证结果（1表示合法，0表示有错误）
**
** 检查项目：
** - 指令格式的正确性
** - 操作码的有效性
** - 操作数范围的合法性
** - 跳转目标的有效性
** - 常量引用的正确性
** - 局部变量引用的有效性
** - 上值引用的一致性
** - 寄存器使用的合理性
**
** 验证算法：
** 1. 遍历所有指令
** 2. 检查每条指令的格式
** 3. 验证操作数的有效范围
** 4. 检查跳转指令的目标
** 5. 验证常量池引用
** 6. 检查寄存器分配
**
** 错误检测：
** - 非法操作码
** - 越界的操作数
** - 无效的跳转目标
** - 未定义的常量引用
** - 寄存器使用冲突
** - 栈深度异常
**
** 使用场景：
** - 调试模式下的代码验证
** - 字节码加载时的安全检查
** - 编译器输出的质量保证
** - 虚拟机内部的一致性检查
**
** 性能考虑：
** - 通常仅在调试模式下启用
** - 生产环境可能跳过此检查
** - 验证开销与代码大小成正比
** - 一次性检查，不影响执行性能
*/
LUAI_FUNC int luaG_checkcode (const Proto *pt);

/*
** [验证] 开放指令合法性检查函数
**
** 功能：检查指令是否为需要后续修正的"开放"指令
** @param i: Instruction 要检查的虚拟机指令
** @return: int 检查结果（1表示是开放指令，0表示不是）
**
** 开放指令定义：
** 开放指令是指那些在生成时操作数不完整，需要在后续处理中
** 修正或补全的指令。
**
** 典型的开放指令：
** - LOADNIL: 可能需要调整 nil 值的数量
** - CALL: 可能需要调整参数和返回值数量
** - TAILCALL: 尾调用的参数数量调整
** - RETURN: 返回值数量的最终确定
** - VARARG: 可变参数的数量处理
**
** 检查目的：
** - 确保代码生成的正确性
** - 验证指令序列的完整性
** - 检测编译器的潜在错误
** - 保证虚拟机执行的安全性
**
** 实现方式：
** - 检查指令的操作码类型
** - 验证操作数的特殊模式
** - 识别需要修正的指令格式
** - 返回布尔结果表示检查状态
**
** 应用场景：
** - 编译器的代码生成验证
** - 字节码序列的完整性检查
** - 调试器的指令分析
** - 虚拟机的安全验证
**
** 注意事项：
** - 主要用于内部一致性检查
** - 不是运行时性能的关键路径
** - 帮助发现编译器的 bug
** - 确保字节码的正确性
*/
LUAI_FUNC int luaG_checkopenop (Instruction i);

/*
** ====================================================================
** [总结] Lua 调试接口模块总结
** ====================================================================
**
** 本头文件是 Lua 虚拟机调试和错误处理系统的核心，提供了完整的
** 调试支持基础设施和错误处理机制。
**
** 核心功能分类：
**
** 1. [调试信息管理]
**    - pcRel: 程序计数器位置转换
**    - getline: 源代码行号映射
**    - resethookcount: 调试钩子管理
**
** 2. [错误类型处理]
**    - luaG_typeerror: 类型不匹配错误
**    - luaG_concaterror: 字符串连接错误
**    - luaG_aritherror: 算术运算错误
**    - luaG_ordererror: 比较操作错误
**
** 3. [错误传播机制]
**    - luaG_runerror: 格式化错误报告
**    - luaG_errormsg: 错误消息增强和传播
**
** 4. [代码验证系统]
**    - luaG_checkcode: 字节码完整性验证
**    - luaG_checkopenop: 开放指令检查
**
** 设计特点：
**
** 1. [完整性]
**    - 覆盖所有可能的运行时错误类型
**    - 提供详细的错误诊断信息
**    - 支持完整的堆栈跟踪
**    - 包含源代码级别的调试支持
**
** 2. [易用性]
**    - 宏定义简化常用操作
**    - 统一的错误处理接口
**    - 丰富的错误信息格式化
**    - 直观的调试信息获取
**
** 3. [性能考虑]
**    - 错误路径性能影响最小
**    - 调试信息的条件编译支持
**    - 高效的程序计数器转换
**    - 快速的行号查找
**
** 4. [安全性]
**    - 字节码完整性验证
**    - 指令合法性检查
**    - 栈状态一致性保证
**    - 错误传播的安全机制
**
** 错误处理架构：
**
** 1. [检测阶段]
**    - 类型检查和验证
**    - 操作合法性判断
**    - 边界条件检查
**    - 一致性验证
**
** 2. [报告阶段]
**    - 错误信息生成
**    - 上下文信息收集
**    - 堆栈跟踪构建
**    - 格式化输出准备
**
** 3. [传播阶段]
**    - 长跳转机制
**    - 资源清理
**    - 错误链构建
**    - 异常处理调用
**
** 调试支持特性：
**
** 1. [源码映射]
**    - 指令到行号的精确映射
**    - 函数调用的上下文信息
**    - 变量作用域的跟踪
**    - 执行路径的记录
**
** 2. [动态分析]
**    - 运行时类型检查
**    - 性能热点识别
**    - 内存使用监控
**    - 执行统计收集
**
** 3. [交互式调试]
**    - 断点支持
**    - 单步执行
**    - 变量检查
**    - 表达式求值
**
** 与其他模块的关系：
** - lvm.c: 虚拟机执行的错误处理客户
** - lapi.c: API 错误报告的基础服务
** - lparser.c: 编译时错误的处理支持
** - lgc.c: 垃圾回收错误的报告机制
** - ldo.c: 执行控制和错误传播的协作
**
** 扩展和维护：
** - 新的错误类型可以方便地添加
** - 调试信息格式易于扩展
** - 验证规则可以根据需要增强
** - 性能分析功能有良好的扩展性
**
** 质量保证：
** - 全面的错误覆盖
** - 详细的诊断信息
** - 一致的错误处理流程
** - 可靠的调试支持
*/

#endif
