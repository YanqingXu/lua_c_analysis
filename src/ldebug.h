/**
 * @file ldebug.h
 * @brief Lua调试接口模块头文件：提供Lua虚拟机的调试和错误处理功能
 * 
 * 详细说明：
 * 本文件定义了Lua调试接口模块的核心功能，包括错误处理、类型检查、
 * 运行时诊断和调试信息管理。这些功能是Lua虚拟机错误报告和调试
 * 支持的基础设施，为开发者提供了丰富的运行时诊断信息。
 * 
 * 系统架构定位：
 * 在Lua解释器架构中，调试模块横跨多个层次：
 * 
 * 用户代码层 ← 错误报告 ← 调试接口 ← 虚拟机执行层
 *     ↑                                    ↓
 * 调试器工具 ← 调试信息 ← 本模块 → 运行时错误处理
 * 
 * 主要职责：
 * - 提供统一的错误处理和报告机制
 * - 实现类型检查和类型错误诊断
 * - 支持运行时错误的格式化和上下文信息
 * - 提供字节码验证和完整性检查
 * - 管理调试钩子和断点机制
 * - 支持堆栈跟踪和调用链分析
 * 
 * 技术特点：
 * - 零开销调试信息（可选编译）
 * - 精确的错误位置定位
 * - 丰富的类型信息和上下文
 * - 支持多种调试模式和钩子
 * - 与虚拟机执行紧密集成
 * - 可扩展的错误分类体系
 * 
 * 调试信息管理：
 * Lua的调试信息包含以下几个层次：
 * 
 * 1. **源码级信息**：
 *    - 源文件名和路径
 *    - 行号和列号映射
 *    - 函数名和局部变量名
 *    - 作用域和生命周期信息
 * 
 * 2. **字节码级信息**：
 *    - 指令到源码的映射
 *    - 寄存器使用情况
 *    - 跳转目标和控制流
 *    - 常量表和上值信息
 * 
 * 3. **运行时信息**：
 *    - 调用栈状态
 *    - 变量值和类型
 *    - 内存使用情况
 *    - 执行统计信息
 * 
 * 错误处理架构：
 * Lua采用异常风格的错误处理机制：
 * 
 * ```
 * 错误发生 → 错误对象创建 → 栈展开 → 错误处理器 → 错误报告
 *     ↓              ↓           ↓           ↓
 * 上下文收集 → 格式化消息 → 清理资源 → 用户回调
 * ```
 * 
 * 性能考虑：
 * - 调试功能的条件编译支持
 * - 最小化正常执行路径的开销
 * - 延迟计算调试信息
 * - 缓存常用的调试数据
 * - 优化错误路径的性能
 * 
 * 依赖关系：
 * - lstate.h: Lua状态机和执行环境
 * - lobject.h: Lua对象系统和类型定义
 * - lvm.h: 虚拟机执行和指令处理
 * - lfunc.h: 函数对象和原型管理
 * 
 * 应用场景：
 * - 开发期调试和测试
 * - 生产环境错误诊断
 * - 性能分析和优化
 * - IDE集成和工具支持
 * - 教学和学习辅助
 * 
 * @author Roberto Ierusalimschy (Lua团队)
 * @version 5.1.5
 * @date 2007年12月27日
 * @since Lua 5.0
 * @see lstate.h, lvm.h, lapi.h
 */

#ifndef ldebug_h
#define ldebug_h

#include "lstate.h"

/**
 * @brief 计算相对程序计数器偏移量的宏
 * 
 * 详细说明：
 * 这个宏用于计算当前程序计数器相对于函数开始位置的偏移量。
 * 在Lua调试和错误报告中，相对偏移比绝对地址更有用，因为它：
 * - 便于在调试信息中定位具体指令
 * - 支持函数的重定位和加载
 * - 简化调试器的实现复杂度
 * 
 * 计算公式：
 * 相对偏移 = (当前PC - 函数代码起始地址) - 1
 * 
 * 减1的原因：
 * 在Lua虚拟机中，PC总是指向下一条要执行的指令，所以当前
 * 正在执行的指令的位置是PC-1。这个调整确保了错误报告中
 * 显示的是实际出错的指令位置。
 * 
 * 使用场景：
 * - 错误消息中的指令位置报告
 * - 调试器中的断点设置和命中
 * - 性能分析中的热点指令识别
 * - 代码覆盖率统计
 * 
 * @param pc 当前程序计数器指针
 * @param p 函数原型指针，包含代码起始地址
 * @return 相对于函数开始的指令偏移量
 * 
 * @note PC和代码地址都是Instruction*类型的指针
 * @warning 使用前必须确保pc和p都是有效指针
 */
#define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)

/**
 * @brief 获取指定指令的源代码行号的宏
 * 
 * 详细说明：
 * 这个宏用于获取字节码指令对应的源代码行号。Lua编译器在
 * 生成字节码时会同时生成行号信息表，建立指令与源码的映射
 * 关系，这对调试和错误报告至关重要。
 * 
 * 实现机制：
 * - 如果函数包含行号信息表(lineinfo != NULL)，则返回对应行号
 * - 如果没有行号信息（如某些优化编译），则返回0表示未知
 * 
 * 行号信息的存储：
 * lineinfo是一个整数数组，每个元素对应一条字节码指令的行号。
 * 数组的索引就是指令在代码数组中的位置。
 * 
 * 性能优化：
 * - 行号信息可以在编译时选择性生成
 * - 在发布版本中可以省略以减少内存占用
 * - 支持压缩存储减少空间开销
 * 
 * 调试应用：
 * - 运行时错误的精确定位
 * - 调试器的单步执行和断点
 * - 代码覆盖率分析
 * - 性能热点的源码关联
 * 
 * @param f 函数原型指针，包含行号信息表
 * @param pc 指令在代码数组中的索引
 * @return 对应的源代码行号，无信息时返回0
 * 
 * @note pc必须是有效的指令索引
 * @see Proto结构体中的lineinfo字段
 */
#define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)

/**
 * @brief 重置调试钩子计数器的宏
 * 
 * 详细说明：
 * 这个宏用于重置Lua状态机的调试钩子计数器。Lua支持基于指令
 * 计数的调试钩子，允许在执行指定数量的指令后触发调试回调。
 * 这种机制对于实现单步调试、性能监控和执行统计非常有用。
 * 
 * 钩子计数机制：
 * - basehookcount: 钩子触发的基础间隔
 * - hookcount: 当前剩余计数，递减到0时触发钩子
 * - 重置后，hookcount恢复为basehookcount的值
 * 
 * 钩子类型：
 * Lua支持以下几种调试钩子：
 * - LUA_HOOKCALL: 函数调用时触发
 * - LUA_HOOKRET: 函数返回时触发
 * - LUA_HOOKLINE: 执行新行时触发
 * - LUA_HOOKCOUNT: 执行指定数量指令后触发
 * 
 * 使用场景：
 * - 调试器的单步执行控制
 * - 性能分析和指令统计
 * - 执行超时检测
 * - 代码覆盖率统计
 * - 实时监控和诊断
 * 
 * 性能影响：
 * - 钩子会增加虚拟机的执行开销
 * - 计数检查在每条指令执行时进行
 * - 可以通过调整间隔平衡精度和性能
 * 
 * @param L Lua状态机指针
 * 
 * @note 只有在设置了计数钩子时才需要调用
 * @see lua_sethook(), lua_gethook()
 */
#define resethookcount(L) (L->hookcount = L->basehookcount)

/* ============================================================================
 * 错误处理和类型检查接口
 * ============================================================================ */

/**
 * @brief 报告类型错误
 * 
 * 详细说明：
 * 当操作数的类型不符合操作要求时，生成详细的类型错误消息。
 * 这个函数会分析操作上下文，提供精确的错误描述，帮助开发者
 * 快速定位和修复类型相关的问题。
 * 
 * 错误消息格式：
 * 典型的错误消息包含以下信息：
 * - 尝试执行的操作名称
 * - 期望的数据类型
 * - 实际遇到的数据类型
 * - 值的字符串表示（如果适用）
 * - 源代码位置信息
 * 
 * 类型分析：
 * 函数会对以下类型进行智能识别：
 * - 基本类型：nil, boolean, number, string
 * - 复合类型：table, function, userdata, thread
 * - 特殊值：全局变量、局部变量、字段访问
 * 
 * 上下文推断：
 * 通过分析调用栈和字节码指令，函数能够推断：
 * - 操作发生的具体位置
 * - 涉及的变量名或表达式
 * - 操作的语义上下文
 * 
 * 国际化支持：
 * 错误消息支持多语言本地化：
 * - 中文：尝试对nil值进行算术运算
 * - 英文：attempt to perform arithmetic on a nil value
 * 
 * @param L Lua状态机指针，用于错误处理和栈管理
 * @param o 引起类型错误的值对象指针
 * @param opname 操作名称字符串，用于错误消息生成
 * 
 * @throws lua_Error 总是抛出Lua错误，不会正常返回
 * 
 * @note 这个函数不会返回，它会通过longjmp跳转到错误处理器
 * @see luaG_aritherror(), luaG_runerror()
 */
LUAI_FUNC void luaG_typeerror(lua_State *L, const TValue *o, const char *opname);

/**
 * @brief 报告字符串连接错误
 * 
 * 详细说明：
 * 当字符串连接操作失败时，生成专门的错误消息。Lua的字符串
 * 连接操作(..)要求操作数必须是字符串或数字类型，其他类型
 * 会触发此错误。
 * 
 * 连接规则：
 * Lua字符串连接的类型转换规则：
 * - 字符串：直接参与连接
 * - 数字：自动转换为字符串后连接
 * - 其他类型：尝试调用__tostring元方法
 * - 无__tostring：报告类型错误
 * 
 * 错误分析：
 * 函数会分析两个操作数，确定哪个导致了错误：
 * - 如果p1无法转换为字符串，报告p1的类型错误
 * - 如果p2无法转换为字符串，报告p2的类型错误
 * - 提供具体的类型和值信息
 * 
 * 性能考虑：
 * - 错误路径不影响正常执行性能
 * - 延迟计算错误消息的详细信息
 * - 缓存类型名称和常用错误模板
 * 
 * 调试支持：
 * - 提供操作数的详细类型信息
 * - 显示尝试连接的实际值
 * - 包含源代码位置和上下文
 * 
 * @param L Lua状态机指针
 * @param p1 第一个连接操作数的栈位置
 * @param p2 第二个连接操作数的栈位置
 * 
 * @throws lua_Error 总是抛出Lua错误
 * 
 * @note StkId是指向栈元素的指针类型
 * @see OP_CONCAT指令的实现
 */
LUAI_FUNC void luaG_concaterror(lua_State *L, StkId p1, StkId p2);

/**
 * @brief 报告算术运算错误
 * 
 * 详细说明：
 * 当算术运算的操作数类型不正确时，生成专门的算术错误消息。
 * Lua的算术运算符(+, -, *, /, %, ^)要求操作数必须是数字类型
 * 或可转换为数字的字符串，否则会触发此错误。
 * 
 * 支持的算术运算：
 * - 加法(+)、减法(-)、乘法(*)、除法(/)
 * - 取模(%)、乘方(^)
 * - 一元负号(-)
 * 
 * 类型转换规则：
 * - 数字：直接参与运算
 * - 数字字符串：自动转换为数字
 * - 其他类型：尝试调用算术元方法
 * - 无元方法：报告类型错误
 * 
 * 元方法支持：
 * 如果操作数不是数字，会尝试以下元方法：
 * - __add, __sub, __mul, __div, __mod, __pow, __unm
 * - 元方法允许自定义类型参与算术运算
 * 
 * 错误消息细节：
 * - 指明具体的算术操作类型
 * - 显示两个操作数的实际类型
 * - 提供值的字符串表示（如果可能）
 * - 包含详细的源代码位置
 * 
 * 特殊情况处理：
 * - 除零错误单独处理
 * - NaN和无穷大值的特殊处理
 * - 数值溢出的检测和报告
 * 
 * @param L Lua状态机指针
 * @param p1 第一个算术操作数指针
 * @param p2 第二个算术操作数指针
 * 
 * @throws lua_Error 总是抛出Lua错误
 * 
 * @note 函数会分析哪个操作数导致了类型错误
 * @see 算术运算相关的字节码指令(OP_ADD, OP_SUB等)
 */
LUAI_FUNC void luaG_aritherror(lua_State *L, const TValue *p1, const TValue *p2);

/**
 * @brief 报告比较运算错误
 * 
 * 详细说明：
 * 当比较运算的操作数类型不兼容时，生成专门的比较错误消息。
 * Lua的比较运算符(<, <=, >, >=)要求操作数必须是相同类型
 * 或兼容类型，否则会触发此错误。
 * 
 * 比较规则：
 * Lua的比较运算有严格的类型要求：
 * - 数字与数字：直接比较数值
 * - 字符串与字符串：按字典序比较
 * - 不同类型：通常不允许比较
 * - 特殊情况：通过元方法自定义比较
 * 
 * 元方法支持：
 * 比较运算可以通过以下元方法自定义：
 * - __lt：小于比较
 * - __le：小于等于比较
 * - 其他比较通过这两个元方法推导
 * 
 * 错误场景：
 * 常见的比较错误情况：
 * - 数字与字符串比较（除非字符串可转换为数字）
 * - 表与数字比较
 * - 函数与字符串比较
 * - nil值参与比较
 * 
 * 返回值说明：
 * 这个函数返回一个整数，用于错误处理：
 * - 通常返回0表示错误已处理
 * - 返回值可用于错误恢复机制
 * 
 * 调试信息：
 * 错误消息包含：
 * - 尝试进行的比较操作类型
 * - 两个操作数的实际类型
 * - 类型不兼容的具体原因
 * - 建议的修复方案
 * 
 * @param L Lua状态机指针
 * @param p1 第一个比较操作数指针
 * @param p2 第二个比较操作数指针
 * @return 错误处理状态码
 * 
 * @note 与其他错误函数不同，这个函数可能返回而不抛出错误
 * @see OP_LT, OP_LE指令的实现
 */
LUAI_FUNC int luaG_ordererror(lua_State *L, const TValue *p1, const TValue *p2);

/**
 * @brief 报告运行时错误（格式化消息）
 * 
 * 详细说明：
 * 生成格式化的运行时错误消息，类似于printf的功能。这是Lua
 * 错误处理系统的核心函数，用于报告各种运行时异常和错误情况。
 * 
 * 格式化支持：
 * 支持标准的printf风格格式化：
 * - %s：字符串
 * - %d：整数
 * - %f：浮点数
 * - %c：字符
 * - %%：字面量%
 * 
 * Lua特殊格式：
 * 除了标准格式外，还支持Lua特有的格式：
 * - 自动类型检测和转换
 * - Lua值的智能字符串化
 * - 错误上下文的自动添加
 * 
 * 错误上下文：
 * 函数会自动添加丰富的上下文信息：
 * - 当前执行的源文件名
 * - 错误发生的精确行号
 * - 当前函数名和调用链
 * - 相关的局部变量信息
 * 
 * 堆栈展开：
 * 错误处理过程包括：
 * 1. 格式化错误消息
 * 2. 收集调试上下文
 * 3. 执行堆栈展开
 * 4. 调用错误处理器
 * 5. 清理资源和状态
 * 
 * 性能优化：
 * - 格式化操作仅在错误路径执行
 * - 延迟计算复杂的调试信息
 * - 缓存常用的错误消息模板
 * 
 * 使用示例：
 * ```c
 * luaG_runerror(L, "attempt to index field '%s' (a %s value)",
 *               key_name, luaL_typename(L, -1));
 * ```
 * 
 * @param L Lua状态机指针
 * @param fmt 格式化字符串，遵循printf约定
 * @param ... 可变参数列表，用于格式化
 * 
 * @throws lua_Error 总是抛出Lua错误，不会正常返回
 * 
 * @note 这是一个变参函数，参数数量必须与格式字符串匹配
 * @warning 格式字符串必须是有效的printf格式
 */
LUAI_FUNC void luaG_runerror(lua_State *L, const char *fmt, ...);

/**
 * @brief 抛出栈顶的错误对象
 * 
 * 详细说明：
 * 将Lua栈顶的值作为错误对象抛出。这个函数是Lua错误处理机制
 * 的底层接口，用于实现error()函数和其他错误抛出场景。
 * 
 * 错误对象类型：
 * Lua中的错误对象可以是任何类型：
 * - 字符串：最常见的错误消息
 * - 数字：错误代码或状态
 * - 表：结构化的错误信息
 * - 用户数据：自定义错误对象
 * - 其他类型：特殊用途的错误
 * 
 * 栈操作：
 * 函数执行以下栈操作：
 * 1. 读取栈顶的错误对象
 * 2. 可能添加调试信息
 * 3. 执行栈展开操作
 * 4. 将错误传播到错误处理器
 * 
 * 错误传播：
 * 错误会沿着调用链向上传播：
 * - C函数：通过longjmp跳转
 * - Lua函数：展开到保护调用
 * - 主线程：终止程序或返回错误
 * 
 * 调试信息增强：
 * 在适当的情况下，函数会增强错误对象：
 * - 为字符串错误添加位置信息
 * - 为表错误添加调用栈
 * - 保持原始错误对象的完整性
 * 
 * 与pcall的交互：
 * 这个函数与Lua的保护调用机制配合：
 * - pcall会捕获这里抛出的错误
 * - xpcall允许自定义错误处理器
 * - 错误对象会传递给错误处理器
 * 
 * 性能考虑：
 * - 错误抛出是相对昂贵的操作
 * - 应该避免在正常控制流中使用
 * - 主要用于异常情况的处理
 * 
 * @param L Lua状态机指针，栈顶必须包含错误对象
 * 
 * @pre 栈顶包含要抛出的错误对象
 * @throws lua_Error 总是抛出Lua错误
 * 
 * @note 函数不会返回，它会执行long jump
 * @see lua_error(), pcall(), xpcall()
 */
LUAI_FUNC void luaG_errormsg(lua_State *L);

/* ============================================================================
 * 代码验证和完整性检查接口
 * ============================================================================ */

/**
 * @brief 检查函数原型的字节码完整性
 * 
 * 详细说明：
 * 对函数原型的字节码进行全面的完整性和正确性检查。这个函数
 * 用于验证编译器生成的字节码是否符合Lua虚拟机的执行要求，
 * 是调试和质量保证的重要工具。
 * 
 * 检查项目：
 * 
 * 1. **指令有效性检查**：
 *    - 操作码是否在有效范围内
 *    - 操作数是否符合指令要求
 *    - 跳转目标是否在代码范围内
 *    - 寄存器索引是否合法
 * 
 * 2. **栈平衡检查**：
 *    - 函数入口和出口的栈平衡
 *    - 所有执行路径的栈一致性
 *    - 临时寄存器的正确使用
 *    - 栈溢出保护验证
 * 
 * 3. **控制流检查**：
 *    - 跳转指令的目标有效性
 *    - 函数调用和返回的匹配
 *    - 循环结构的完整性
 *    - 异常处理的正确性
 * 
 * 4. **常量表检查**：
 *    - 常量索引的有效性
 *    - 常量类型的一致性
 *    - 字符串常量的完整性
 *    - 嵌套函数的递归检查
 * 
 * 5. **上值检查**：
 *    - 上值索引的有效性
 *    - 上值栈位置的正确性
 *    - 闭包的完整性验证
 * 
 * 检查算法：
 * 使用数据流分析技术：
 * - 符号执行模拟指令效果
 * - 抽象解释验证栈状态
 * - 控制流图分析路径完整性
 * - 活跃变量分析优化验证
 * 
 * 错误诊断：
 * 当检查失败时，提供详细诊断：
 * - 具体的错误类型和位置
 * - 相关的指令和操作数
 * - 建议的修复方案
 * - 错误的严重程度分级
 * 
 * 性能考虑：
 * - 检查是可选的，主要用于调试版本
 * - 使用高效的数据结构减少开销
 * - 支持增量检查和缓存
 * - 可配置的检查深度和范围
 * 
 * 应用场景：
 * - 编译器测试和验证
 * - 字节码文件的完整性检查
 * - 动态代码生成的验证
 * - 安全审计和代码分析
 * 
 * @param pt 要检查的函数原型指针
 * @return 检查结果：1表示通过，0表示发现错误
 * 
 * @note 这个函数主要在调试版本中使用
 * @see Proto结构体，字节码指令定义
 */
LUAI_FUNC int luaG_checkcode(const Proto *pt);

/**
 * @brief 检查指令是否为开放操作
 * 
 * 详细说明：
 * 检查给定的字节码指令是否属于"开放操作"类别。开放操作是指
 * 那些可能返回多个值或消耗可变数量操作数的指令，这类指令在
 * 优化和代码生成中需要特殊处理。
 * 
 * 开放操作的特征：
 * 
 * 1. **可变返回值**：
 *    - 函数调用：可能返回0到多个值
 *    - VARARG：展开为可变数量的参数
 *    - 表达式列表：最后一个表达式可能多值
 * 
 * 2. **栈顶依赖**：
 *    - 操作数数量依赖于当前栈顶
 *    - 结果数量可能影响后续指令
 *    - 需要特殊的栈管理策略
 * 
 * 3. **优化限制**：
 *    - 不能随意重排序
 *    - 寄存器分配需要特殊考虑
 *    - 死代码消除需要保守处理
 * 
 * 典型的开放操作：
 * 
 * - **CALL指令**：
 *   ```
 *   CALL A B C  ; R(A), ..., R(A+C-2) := R(A)(R(A+1), ..., R(A+B-1))
 *   当C=0时，返回值数量由被调用函数决定
 *   ```
 * 
 * - **VARARG指令**：
 *   ```
 *   VARARG A B  ; R(A), R(A+1), ..., R(A+B-1) = vararg
 *   当B=0时，展开所有可变参数
 *   ```
 * 
 * - **SETLIST指令**：
 *   ```
 *   SETLIST A B C ; R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
 *   当B=0时，使用栈顶的所有值
 *   ```
 * 
 * 检查算法：
 * 1. 提取指令的操作码
 * 2. 分析指令的参数模式
 * 3. 检查是否有可变参数或返回值
 * 4. 返回布尔结果
 * 
 * 使用场景：
 * - 编译器优化阶段
 * - 代码生成和寄存器分配
 * - 静态分析和验证
 * - 调试器的指令分析
 * 
 * 性能影响：
 * - 这是一个轻量级的查询函数
 * - 主要进行位操作和表查找
 * - 通常在编译时而非运行时调用
 * 
 * @param i 要检查的字节码指令
 * @return 检查结果：非零表示是开放操作，0表示不是
 * 
 * @note 这个函数对于代码优化和分析非常重要
 * @see OpCode枚举，指令格式定义
 */
LUAI_FUNC int luaG_checkopenop(Instruction i);

#endif
