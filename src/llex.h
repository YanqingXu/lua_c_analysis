/**
 * @file llex.h
 * @brief Lua词法分析器：编译器前端的核心组件
 * 
 * 详细说明：
 * 本文件定义了Lua词法分析器的核心数据结构、标记类型和API接口。
 * 词法分析器是编译器前端的第一个阶段，负责将Lua源代码文本分解
 * 为标记（tokens）流，为后续的语法分析和代码生成提供基础。
 * 
 * 系统架构定位：
 * - 位于Lua编译器的最前端，直接处理源代码文本
 * - 与ZIO模块协作进行流式输入处理
 * - 为语法分析器（lparser）提供标准化的标记流
 * - 与字符串管理模块（lstring）紧密集成
 * 
 * 技术特点：
 * - 采用前瞻一个标记的LL(1)词法分析算法
 * - 支持Unicode字符集和本地化小数点
 * - 高效的字符串内部化和重用机制
 * - 流式处理，支持大文件和内存受限环境
 * - 精确的行号跟踪，便于错误报告和调试
 * 
 * 依赖关系：
 * - lobject.h：Lua对象系统（TString类型）
 * - lzio.h：零拷贝I/O模块（ZIO类型）
 * - 标准C库：字符分类和数值转换功能
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 字符集支持：ASCII兼容字符集
 * - 浮点数支持：IEEE 754兼容的浮点运算
 * 
 * 使用示例：
 * @code
 * #include "llex.h"
 * 
 * // 初始化词法分析器
 * lua_State *L = luaL_newstate();
 * luaX_init(L);
 * 
 * // 设置输入源
 * LexState ls;
 * ZIO zio;
 * TString *source_name = luaS_new(L, "test.lua");
 * 
 * luaZ_init(L, &zio, file_reader, file_handle);
 * luaX_setinput(L, &ls, &zio, source_name);
 * 
 * // 词法分析循环
 * do {
 *     luaX_next(&ls);
 *     printf("Token: %s\n", luaX_token2str(&ls, ls.t.token));
 * } while (ls.t.token != TK_EOS);
 * @endcode
 * 
 * 内存安全考虑：
 * - 所有字符串标记都通过Lua的字符串内部化机制管理
 * - 输入缓冲区使用Mbuffer进行动态管理，防止溢出
 * - 错误处理使用Lua的异常机制，确保资源正确清理
 * 
 * 性能特征：
 * - 单遍扫描，时间复杂度O(n)，其中n为源代码长度
 * - 字符串内部化减少内存使用和提升比较性能
 * - 前瞻一个标记的设计最小化回溯开销
 * - 流式处理支持任意大小的源文件
 * 
 * 线程安全性：
 * - LexState结构体不是线程安全的，每个线程需要独立实例
 * - 全局的保留字表是只读的，多线程访问安全
 * - 依赖Lua状态机的线程安全机制
 * 
 * 注意事项：
 * - 保留字枚举的顺序具有特殊意义，修改时需要特别小心
 * - 本地化小数点的处理影响数值字面量的解析
 * - 错误处理依赖Lua的异常机制，可能发生长跳转
 * 
 * @author Roberto Ierusalimschy
 * @version 1.58.1.1
 * @date 2007/12/27
 * @since C99
 * @see lparser.h, lzio.h, lobject.h
 */

#ifndef llex_h
#define llex_h

#include "lobject.h"    // Lua对象系统定义
#include "lzio.h"       // 零拷贝I/O系统

/**
 * @brief 保留字标记的起始值：词法标记编号的基准点
 * 
 * 详细说明：
 * 定义保留字标记的起始编号为257，这个值选择的考虑：
 * 1. 避免与ASCII字符码冲突（0-255）
 * 2. 为单字符标记预留充足空间
 * 3. 便于调试时区分字符标记和关键字标记
 * 
 * 设计意义：
 * - 0-255：保留给单字符标记（+、-、*、/等）
 * - 256：作为特殊用途的分界点
 * - 257+：保留字和复合标记的编号空间
 * 
 * 使用场景：
 * - 标记类型的范围检查
 * - 调试输出中的标记分类
 * - 编译器内部的标记处理逻辑
 * 
 * @since C99
 * @see enum RESERVED
 */
#define FIRST_RESERVED  257

/**
 * @brief 保留字的最大长度：词法缓冲区大小的计算基准
 * 
 * 详细说明：
 * 通过计算"function"字符串的长度来确定保留字的最大长度。
 * "function"是Lua中最长的保留字（8个字符），这个宏为词法
 * 分析器的缓冲区分配和字符串处理提供大小参考。
 * 
 * 计算方法：
 * - sizeof("function")：包括终止符'\0'的字符串长度
 * - 除以sizeof(char)：确保在不同字符编码下的正确性
 * 
 * 使用场景：
 * - 标识符缓冲区的初始大小分配
 * - 保留字识别的优化
 * - 内存预分配的参考值
 * 
 * @note 当前值为9（包括'\0'），实际字符数为8
 * @since C99
 */
#define TOKEN_LEN   (sizeof("function") / sizeof(char))

/**
 * @brief Lua标记类型枚举：定义所有词法标记的类型
 * 
 * 详细说明：
 * 定义了Lua语言的所有标记类型，包括保留字、操作符和特殊标记。
 * 枚举的顺序具有特殊意义，用于优化标记处理和错误报告。
 * 
 * 设计原则：
 * - 保留字按字母顺序排列，便于二分查找
 * - 复合操作符集中定义，便于统一处理
 * - 特殊标记放在最后，便于范围检查
 * 
 * 内存布局考虑：
 * - 使用连续的整数值，便于数组索引
 * - 起始值为FIRST_RESERVED，避免与字符冲突
 * - 总数量用于数组大小的计算
 * 
 * @warning 修改此枚举的顺序需要同步更新luaX_tokens数组
 * @warning 搜索"ORDER RESERVED"找到所有依赖此顺序的代码
 * @since C99
 */
enum RESERVED {
    // === Lua保留字：按字母顺序排列的语言关键字 ===
    
    /**
     * @brief 逻辑与操作符：and关键字
     * 用于逻辑表达式的与运算，具有短路求值特性
     */
    TK_AND = FIRST_RESERVED,
    
    /**
     * @brief 跳出循环：break关键字
     * 用于提前退出循环结构（for、while、repeat）
     */
    TK_BREAK,
    
    /**
     * @brief 语句块开始：do关键字
     * 标记语句块的开始，通常与end配对使用
     */
    TK_DO,
    
    /**
     * @brief 条件分支：else关键字
     * if语句的否则分支，处理条件为假的情况
     */
    TK_ELSE,
    
    /**
     * @brief 条件链：elseif关键字
     * if语句的多重条件分支，避免嵌套if结构
     */
    TK_ELSEIF,
    
    /**
     * @brief 语句块结束：end关键字
     * 标记语句块的结束，与do、if、function等配对
     */
    TK_END,
    
    /**
     * @brief 布尔假值：false关键字
     * 表示逻辑假值，Lua中的基本布尔字面量
     */
    TK_FALSE,
    
    /**
     * @brief 循环结构：for关键字
     * 定义for循环，支持数值循环和通用循环
     */
    TK_FOR,
    
    /**
     * @brief 函数定义：function关键字
     * 定义函数，支持命名函数和匿名函数
     */
    TK_FUNCTION,
    
    /**
     * @brief 条件判断：if关键字
     * 条件语句的开始，根据条件执行不同分支
     */
    TK_IF,
    
    /**
     * @brief 迭代操作：in关键字
     * 用于for循环中的迭代器，遍历集合元素
     */
    TK_IN,
    
    /**
     * @brief 局部变量：local关键字
     * 声明局部变量，限制变量的作用域
     */
    TK_LOCAL,
    
    /**
     * @brief 空值：nil关键字
     * 表示空值或未定义值，Lua中的特殊值
     */
    TK_NIL,
    
    /**
     * @brief 逻辑非操作：not关键字
     * 逻辑取反操作符，将真值转为假值，假值转为真值
     */
    TK_NOT,
    
    /**
     * @brief 逻辑或操作：or关键字
     * 逻辑或运算，具有短路求值特性
     */
    TK_OR,
    
    /**
     * @brief 重复循环：repeat关键字
     * repeat-until循环的开始，至少执行一次的循环
     */
    TK_REPEAT,
    
    /**
     * @brief 函数返回：return关键字
     * 从函数中返回值，可以返回多个值
     */
    TK_RETURN,
    
    /**
     * @brief 条件分支体：then关键字
     * if语句条件为真时执行的语句块标记
     */
    TK_THEN,
    
    /**
     * @brief 布尔真值：true关键字
     * 表示逻辑真值，Lua中的基本布尔字面量
     */
    TK_TRUE,
    
    /**
     * @brief 循环条件：until关键字
     * repeat循环的结束条件，条件为真时退出循环
     */
    TK_UNTIL,
    
    /**
     * @brief 条件循环：while关键字
     * while循环的开始，条件为真时继续执行
     */
    TK_WHILE,
    
    // === 复合操作符：多字符组成的操作符标记 ===
    
    /**
     * @brief 字符串连接：..操作符
     * 字符串连接操作符，将两个值连接为字符串
     */
    TK_CONCAT,
    
    /**
     * @brief 可变参数：...操作符
     * 表示可变参数列表，用于函数定义和调用
     */
    TK_DOTS,
    
    /**
     * @brief 相等比较：==操作符
     * 相等性比较，比较两个值是否相等
     */
    TK_EQ,
    
    /**
     * @brief 大于等于：>=操作符
     * 大于或等于比较操作符
     */
    TK_GE,
    
    /**
     * @brief 小于等于：<=操作符
     * 小于或等于比较操作符
     */
    TK_LE,
    
    /**
     * @brief 不等比较：~=操作符（或!=）
     * 不等性比较，比较两个值是否不相等
     */
    TK_NE,
    
    // === 字面量标记：基本数据类型的字面值 ===
    
    /**
     * @brief 数值字面量：数字常量标记
     * 表示整数或浮点数字面量，存储在seminfo.r中
     */
    TK_NUMBER,
    
    /**
     * @brief 标识符：变量名或函数名标记
     * 表示用户定义的标识符，存储在seminfo.ts中
     */
    TK_NAME,
    
    /**
     * @brief 字符串字面量：字符串常量标记
     * 表示字符串字面量，存储在seminfo.ts中
     */
    TK_STRING,
    
    /**
     * @brief 输入结束：文件或输入流结束标记
     * 表示词法分析到达输入的末尾
     */
    TK_EOS
};

/**
 * @brief 保留字数量：编译时计算的保留字总数
 * 
 * 详细说明：
 * 通过计算TK_WHILE和FIRST_RESERVED之间的差值来确定保留字的
 * 总数量。这个宏用于声明和初始化保留字相关的数组。
 * 
 * 计算公式：
 * - TK_WHILE是最后一个保留字标记
 * - FIRST_RESERVED是第一个保留字标记
 * - +1是因为包含两个端点
 * 
 * 使用场景：
 * - luaX_tokens数组的大小声明
 * - 保留字查找表的初始化
 * - 调试和统计信息的输出
 * 
 * @note 当前值为21，对应Lua 5.1的保留字数量
 * @since C99
 */
#define NUM_RESERVED    (cast(int, TK_WHILE - FIRST_RESERVED + 1))

/**
 * @brief 标记名称数组：所有标记的字符串表示
 * 
 * 详细说明：
 * 全局只读数组，包含所有标记类型的字符串表示。用于错误报告、
 * 调试输出和开发工具的标记显示。数组索引对应标记的枚举值。
 * 
 * 数组内容：
 * - 保留字：对应的关键字字符串（"and"、"break"等）
 * - 操作符：对应的操作符字符串（".."、"=="等）
 * - 字面量：类型描述字符串（"<number>"、"<string>"等）
 * 
 * 使用场景：
 * - 语法错误的友好提示信息
 * - 调试器的标记显示
 * - 开发工具的语法高亮
 * - 编译器的诊断输出
 * 
 * @since C99
 * @see luaX_token2str()
 */
LUAI_DATA const char *const luaX_tokens[];

/**
 * @brief 语义信息联合体：标记的附加数据存储
 * 
 * 详细说明：
 * 用于存储标记的语义信息，不同类型的标记使用联合体的不同成员。
 * 联合体设计节省内存，因为一个标记只会使用其中一种类型的数据。
 * 
 * 成员用途：
 * - r：存储数值字面量的值（lua_Number类型）
 * - ts：存储字符串和标识符的内部化字符串指针
 * 
 * 类型对应关系：
 * - TK_NUMBER：使用r成员存储数值
 * - TK_STRING：使用ts成员存储字符串对象
 * - TK_NAME：使用ts成员存储标识符字符串对象
 * - 其他标记：通常不使用语义信息
 * 
 * 内存效率：
 * - 联合体大小等于最大成员的大小
 * - 在64位系统上通常为8字节
 * - 避免了为每个标记分配多个成员的开销
 * 
 * @since C99
 */
typedef union {
    /**
     * @brief 数值存储：lua_Number类型的数值数据
     * 用于存储整数和浮点数字面量的实际数值
     */
    lua_Number r;
    
    /**
     * @brief 字符串存储：内部化字符串对象指针
     * 用于存储字符串字面量和标识符的字符串对象
     */
    TString *ts;
} SemInfo;

/**
 * @brief 标记结构体：词法分析的基本单元
 * 
 * 详细说明：
 * 表示词法分析过程中的一个标记，包含标记类型和相关的语义信息。
 * 这是词法分析器与语法分析器之间数据传递的基本单位。
 * 
 * 结构设计：
 * - token：标记类型，来自RESERVED枚举或ASCII字符
 * - seminfo：语义信息，根据标记类型使用不同成员
 * 
 * 生命周期：
 * 1. 词法分析器读取字符，识别标记类型
 * 2. 根据标记类型，设置相应的语义信息
 * 3. 将完整的Token传递给语法分析器
 * 4. 语法分析器使用标记信息进行语法分析
 * 
 * 内存布局：
 * - 在32位系统上通常为12字节
 * - 在64位系统上通常为16字节
 * - 结构体可能包含填充字节以满足对齐要求
 * 
 * @since C99
 */
typedef struct Token {
    /**
     * @brief 标记类型：标识标记的具体类型
     * 
     * 取值范围：
     * - 0-255：单字符标记（ASCII字符）
     * - 257+：保留字和复合操作符（RESERVED枚举值）
     */
    int token;
    
    /**
     * @brief 语义信息：标记的附加数据
     * 
     * 根据token的值决定使用哪个联合体成员：
     * - TK_NUMBER：使用seminfo.r
     * - TK_STRING/TK_NAME：使用seminfo.ts
     * - 其他：通常不使用
     */
    SemInfo seminfo;
} Token;

/**
 * @brief 词法分析器状态：词法分析的完整上下文
 * 
 * 详细说明：
 * 包含词法分析器运行所需的全部状态信息，支持流式输入处理和
 * 前瞻标记的LL(1)分析算法。这个结构体封装了词法分析的所有
 * 内部状态，使得分析过程可以暂停和恢复。
 * 
 * 设计特点：
 * - 支持一个标记的前瞻，满足LL(1)语法的需求
 * - 精确的行号跟踪，便于错误报告
 * - 流式处理，支持任意大小的输入
 * - 与Lua状态机集成，支持垃圾收集
 * 
 * 状态管理：
 * - current：当前正在处理的字符
 * - t和lookahead：当前和前瞻标记
 * - 缓冲区：动态管理标记的临时存储
 * - 行号：精确跟踪源代码位置
 * 
 * 内存安全：
 * - 所有指针都受Lua垃圾收集器管理
 * - 缓冲区使用Mbuffer动态管理
 * - 错误处理使用Lua异常机制
 * 
 * @since C99
 */
typedef struct LexState {
    /**
     * @brief 当前字符：正在处理的输入字符
     * 
     * 详细说明：
     * 存储当前从输入流读取的字符。使用int类型而不是char类型
     * 是为了支持EOF标记（通常为-1）和Unicode字符。
     * 
     * 特殊值：
     * - EOF（-1）：表示输入流结束
     * - 0-255：正常的ASCII/Latin-1字符
     * - 256+：扩展字符（如果支持）
     */
    int current;
    
    /**
     * @brief 行号计数器：当前输入的行号
     * 
     * 详细说明：
     * 从1开始计数的行号，每遇到换行符（\n、\r\n、\r）时递增。
     * 用于错误报告和调试信息的精确定位。
     * 
     * 用途：
     * - 语法错误的行号报告
     * - 调试信息的行号标记
     * - 源代码映射的行号对应
     */
    int linenumber;
    
    /**
     * @brief 最后标记行号：上一个消费标记的行号
     * 
     * 详细说明：
     * 记录最后一个被语法分析器"消费"的标记所在的行号。
     * 用于错误恢复和精确的错误定位。
     * 
     * 与linenumber的区别：
     * - linenumber：当前扫描位置的行号
     * - lastline：最后处理标记的行号
     * - 两者可能不同，因为存在前瞻标记
     */
    int lastline;
    
    /**
     * @brief 当前标记：正在处理的标记
     * 
     * 详细说明：
     * 存储当前识别出的标记，这是语法分析器主要使用的标记。
     * 在LL(1)分析中，这是"看到"的标记。
     */
    Token t;
    
    /**
     * @brief 前瞻标记：下一个将要处理的标记
     * 
     * 详细说明：
     * 存储预读的下一个标记，用于LL(1)语法分析的前瞻决策。
     * 这使得语法分析器可以根据下一个标记来决定当前的语法规则。
     * 
     * LL(1)分析原理：
     * - L：从左到右扫描输入
     * - L：产生最左推导
     * - 1：使用一个前瞻标记
     */
    Token lookahead;
    
    /**
     * @brief 函数状态指针：与语法分析器的连接
     * 
     * 详细说明：
     * 指向当前正在分析的函数的状态信息。FuncState是语法分析器
     * 的私有结构，词法分析器通过这个指针与语法分析器协作。
     * 
     * 用途：
     * - 局部变量的作用域管理
     * - 函数嵌套层次的跟踪
     * - 语法分析上下文的共享
     */
    struct FuncState *fs;
    
    /**
     * @brief Lua状态机指针：全局状态的访问
     * 
     * 详细说明：
     * 指向当前的Lua虚拟机状态，提供对Lua运行时环境的访问。
     * 用于内存分配、字符串内部化、错误处理等。
     */
    struct lua_State *L;
    
    /**
     * @brief 输入流指针：零拷贝I/O对象
     * 
     * 详细说明：
     * 指向ZIO（Zero I/O）对象，提供统一的输入接口。ZIO支持
     * 从文件、内存、网络等多种来源读取数据。
     * 
     * ZIO特点：
     * - 零拷贝设计，减少内存操作
     * - 统一的读取接口
     * - 支持缓冲和预读
     */
    ZIO *z;
    
    /**
     * @brief 标记缓冲区：动态字符串构建
     * 
     * 详细说明：
     * 指向Mbuffer对象，用于构建长标记（如字符串、标识符）。
     * Mbuffer提供动态扩展的字符缓冲区功能。
     * 
     * 用途：
     * - 字符串字面量的临时存储
     * - 长标识符的字符收集
     * - 数值字面量的字符串表示
     */
    Mbuffer *buff;
    
    /**
     * @brief 源文件名：当前分析文件的名称
     * 
     * 详细说明：
     * 指向表示当前源文件名称的内部化字符串。用于错误报告
     * 和调试信息中的文件名显示。
     * 
     * 特殊值：
     * - 文件名：普通文件路径
     * - "=stdin"：标准输入
     * - "=(load)"：动态加载的代码
     * - "=..."：其他特殊来源
     */
    TString *source;
    
    /**
     * @brief 本地化小数点：数值解析的小数分隔符
     * 
     * 详细说明：
     * 存储当前locale设置的小数点字符。在不同的地区设置下，
     * 小数点可能是'.'（英语）或','（德语、法语等）。
     * 
     * 本地化支持：
     * - 自动检测系统locale设置
     * - 支持不同地区的数值格式
     * - 确保数值解析的正确性
     * 
     * @note 通常在初始化时从系统locale获取
     */
    char decpoint;
} LexState;

// === 词法分析器API函数：外部接口的函数声明 ===

/**
 * @brief 初始化词法分析器：设置全局词法分析环境
 * 
 * 详细说明：
 * 初始化Lua状态机中与词法分析相关的全局数据结构。这个函数
 * 通常在Lua状态机创建时调用一次，设置保留字表和其他全局配置。
 * 
 * 初始化内容：
 * - 保留字字符串的内部化
 * - 标记名称表的设置
 * - 本地化参数的检测
 * - 词法分析器的全局配置
 * 
 * 调用时机：
 * - Lua状态机初始化时
 * - 重置词法分析环境时
 * - 状态机重新配置时
 * 
 * @param L Lua状态机指针
 * 
 * @pre L != NULL && L已正确初始化
 * @post 词法分析器全局环境已准备就绪
 * 
 * @since C99
 */
LUAI_FUNC void luaX_init(lua_State *L);

/**
 * @brief 设置词法分析输入：配置输入源和分析环境
 * 
 * 详细说明：
 * 为LexState对象配置输入源和分析环境，准备开始词法分析。
 * 这个函数将词法分析器与具体的输入源绑定。
 * 
 * 设置内容：
 * - 输入流的绑定
 * - 源文件名的设置
 * - 行号计数器的初始化
 * - 字符缓冲区的准备
 * - 第一个字符的预读
 * 
 * 参数说明：
 * - L：Lua状态机，提供运行时环境
 * - ls：要初始化的词法分析器状态
 * - z：输入流对象
 * - source：源文件名（用于错误报告）
 * 
 * @param L Lua状态机指针
 * @param ls 词法分析器状态指针
 * @param z 输入流指针
 * @param source 源文件名字符串
 * 
 * @pre 所有参数均非NULL且已正确初始化
 * @post ls已准备好进行词法分析
 * 
 * @since C99
 */
LUAI_FUNC void luaX_setinput(lua_State *L, LexState *ls, ZIO *z, TString *source);

/**
 * @brief 创建新字符串：字符串内部化和管理
 * 
 * 详细说明：
 * 在Lua的字符串表中创建或查找指定的字符串。如果字符串已存在，
 * 返回现有的字符串对象；否则创建新的字符串对象。这个机制
 * 确保相同内容的字符串在内存中只有一个副本。
 * 
 * 字符串内部化优势：
 * - 内存效率：相同字符串只存储一份
 * - 比较效率：字符串比较简化为指针比较
 * - 垃圾收集：统一的字符串生命周期管理
 * 
 * 使用场景：
 * - 标识符字符串的创建
 * - 字符串字面量的处理
 * - 保留字的查找和比较
 * 
 * @param ls 词法分析器状态指针
 * @param str 字符串内容指针
 * @param l 字符串长度
 * @return 内部化的字符串对象指针
 * 
 * @pre ls != NULL && str != NULL
 * @pre l为str的准确长度
 * @post 返回值指向有效的TString对象
 * 
 * @since C99
 */
LUAI_FUNC TString *luaX_newstring(LexState *ls, const char *str, size_t l);

/**
 * @brief 读取下一个标记：词法分析的核心函数
 * 
 * 详细说明：
 * 从输入流中读取并识别下一个标记，更新LexState的当前标记。
 * 这是词法分析器的主要工作函数，实现了完整的标记识别逻辑。
 * 
 * 识别过程：
 * 1. 跳过空白字符和注释
 * 2. 读取字符，识别标记类型
 * 3. 根据标记类型，提取语义信息
 * 4. 更新行号和位置信息
 * 5. 将结果存储在ls->t中
 * 
 * 标记类型处理：
 * - 单字符标记：直接返回ASCII值
 * - 数值字面量：解析并存储数值
 * - 字符串字面量：处理转义序列
 * - 标识符：检查是否为保留字
 * - 复合操作符：识别多字符操作符
 * 
 * 错误处理：
 * - 非法字符：报告词法错误
 * - 未终止字符串：报告语法错误
 * - 数值格式错误：报告格式错误
 * 
 * @param ls 词法分析器状态指针
 * 
 * @pre ls != NULL && ls已正确初始化
 * @post ls->t包含下一个有效标记
 * 
 * @note 可能抛出Lua异常（长跳转）
 * @since C99
 */
LUAI_FUNC void luaX_next(LexState *ls);

/**
 * @brief 执行前瞻分析：为LL(1)分析准备前瞻标记
 * 
 * 详细说明：
 * 读取并设置前瞻标记（lookahead token），用于LL(1)语法分析
 * 的决策。这个函数在语法分析器需要查看下一个标记来决定
 * 语法规则时调用。
 * 
 * LL(1)分析原理：
 * - 某些语法规则需要查看下一个标记才能确定产生式
 * - 前瞻标记提供必要的上下文信息
 * - 避免回溯，提高分析效率
 * 
 * 实现机制：
 * 1. 保存当前标记到临时位置
 * 2. 调用luaX_next获取下一个标记
 * 3. 将结果保存到ls->lookahead
 * 4. 恢复当前标记
 * 
 * 使用场景：
 * - 函数调用与函数定义的区分
 * - 表达式与语句的区分
 * - 赋值与函数调用的区分
 * 
 * @param ls 词法分析器状态指针
 * 
 * @pre ls != NULL && ls已正确初始化
 * @post ls->lookahead包含前瞻标记
 * 
 * @since C99
 */
LUAI_FUNC void luaX_lookahead(LexState *ls);

/**
 * @brief 报告词法错误：词法分析阶段的错误处理
 * 
 * 详细说明：
 * 在词法分析过程中遇到错误时调用，生成包含详细上下文信息的
 * 错误消息并抛出Lua异常。错误消息包括文件名、行号、错误
 * 描述和相关的标记信息。
 * 
 * 错误类型：
 * - 非法字符：源代码中的无效字符
 * - 未终止字符串：缺少结束引号的字符串
 * - 数值格式错误：无效的数值字面量
 * - 注释格式错误：未正确终止的长注释
 * 
 * 错误消息格式：
 * "filename:line: error_message near 'token_string'"
 * 
 * 异常处理：
 * - 函数不会正常返回
 * - 通过Lua异常机制（长跳转）传播错误
 * - 调用者应准备处理异常
 * 
 * @param ls 词法分析器状态指针
 * @param msg 错误消息字符串
 * @param token 相关的标记（用于上下文显示）
 * 
 * @pre ls != NULL && msg != NULL
 * @post 函数不会正常返回，抛出Lua异常
 * 
 * @warning 此函数会导致长跳转，不会正常返回
 * @since C99
 */
LUAI_FUNC void luaX_lexerror(LexState *ls, const char *msg, int token);

/**
 * @brief 报告语法错误：语法分析阶段的错误处理
 * 
 * 详细说明：
 * 在语法分析过程中遇到错误时调用，生成语法错误消息并抛出
 * Lua异常。与词法错误不同，语法错误通常涉及标记序列的
 * 语法规则违反。
 * 
 * 错误场景：
 * - 意外的标记：期望特定标记但遇到其他标记
 * - 语法规则违反：标记序列不符合语法规则
 * - 结构不匹配：括号、引号等不匹配
 * - 上下文错误：在错误的上下文中使用标记
 * 
 * 错误报告：
 * - 包含精确的位置信息
 * - 提供当前标记的上下文
 * - 给出可能的修复建议
 * 
 * @param ls 词法分析器状态指针
 * @param s 错误描述字符串
 * 
 * @pre ls != NULL && s != NULL
 * @post 函数不会正常返回，抛出Lua异常
 * 
 * @warning 此函数会导致长跳转，不会正常返回
 * @since C99
 */
LUAI_FUNC void luaX_syntaxerror(LexState *ls, const char *s);

/**
 * @brief 标记转字符串：获取标记的字符串表示
 * 
 * 详细说明：
 * 将标记类型转换为对应的字符串表示，用于错误报告、调试输出
 * 和开发工具。函数根据标记类型返回相应的字符串描述。
 * 
 * 转换规则：
 * - 保留字：返回关键字字符串（"if"、"then"等）
 * - 操作符：返回操作符字符串（".."、"=="等）
 * - 字面量：返回类型描述（"<number>"、"<string>"等）
 * - 单字符：返回字符本身
 * - 特殊标记：返回描述性字符串（"<eof>"等）
 * 
 * 使用场景：
 * - 错误消息中的标记显示
 * - 调试器的标记信息显示
 * - 语法分析器的跟踪输出
 * - 开发工具的语法高亮
 * 
 * 内存管理：
 * - 返回的字符串指向静态或内部化存储
 * - 调用者不需要释放返回的字符串
 * - 字符串生命周期由Lua管理
 * 
 * @param ls 词法分析器状态指针
 * @param token 要转换的标记类型
 * @return 标记的字符串表示
 * 
 * @pre ls != NULL
 * @post 返回值指向有效的字符串
 * 
 * @note 返回的字符串不应被修改
 * @since C99
 */
LUAI_FUNC const char *luaX_token2str(LexState *ls, int token);

#endif
