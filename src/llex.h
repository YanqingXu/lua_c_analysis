/*
** ====================================================================
** Lua 词法分析器 (Lexical Analyzer)
** ====================================================================
** 
** 文件作用：
** 本文件定义了 Lua 语言的词法分析器，负责将源代码文本转换为 Token 流。
** 词法分析是编译过程的第一阶段，为语法分析器提供结构化的输入。
**
** 核心功能：
** 1. [扫描] 字符流扫描和识别
** 2. [分类] Token 分类和语义信息提取  
** 3. [缓存] 预读机制和 Token 缓存
** 4. [错误] 词法错误检测和报告
** 5. [字符串] 字符串字面量处理和内部化
** 6. [数字] 数值字面量解析和转换
**
** 设计特点：
** - 单字符预读的高效扫描算法
** - 保留字的哈希表快速识别
** - 字符串内部化与垃圾回收集成
** - 详细的错误位置信息维护
** - 支持不同数值格式和转义序列
**
** 依赖关系：
** - lobject.h: 基础对象系统，提供字符串和数值类型
** - lzio.h: 输入流抽象，支持多种数据源
**
** $Id: llex.h,v 1.58.1.1 2007/12/27 13:02:25 roberto Exp $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

#ifndef llex_h
#define llex_h

#include "lobject.h"
#include "lzio.h"

/*
** ====================================================================
** [常量] 词法分析器基础常量定义
** ====================================================================
*/

/*
** [常量] 保留字起始编号
**
** 含义：保留字 Token 编号的起始值
** 
** 设计原理：
** - ASCII 字符范围是 0-255
** - 保留字从 257 开始编号
** - 避免与单字符 Token 冲突
** - 为扩展留下足够空间
**
** 编号分配：
** - 0-255: 单字符 Token（如 +, -, *, / 等）
** - 256: 通常作为 EOF 或特殊标记
** - 257+: 保留字和复合 Token
*/
#define FIRST_RESERVED	257

/*
** [常量] 保留字最大长度
**
** 含义：定义保留字的最大长度限制
** 
** 计算方式：
** - 以 "function" 为基准（8 字符）
** - 使用 sizeof 确保类型安全
** - 编译时确定，无运行时开销
**
** 用途：
** - 词法分析器的缓冲区分配
** - 保留字匹配的优化
** - 内存使用量的预估
*/
#define TOKEN_LEN	(sizeof("function")/sizeof(char))

/*
** ====================================================================
** [枚举] Lua 语言 Token 类型定义
** ====================================================================
*/

/*
** [枚举] 保留字和特殊 Token 类型
**
** 重要提示：
** 如果修改此枚举的顺序，请搜索 "ORDER RESERVED" 
** 并更新相关的数组和函数
**
** Token 分类：
** 1. 保留字 Token：语言关键字
** 2. 操作符 Token：复合操作符
** 3. 字面量 Token：数值、字符串等
** 4. 特殊 Token：标识符、结束符等
*/
enum RESERVED {
  /*
  ** [保留字] 语言关键字 Token
  ** 
  ** 这些是 Lua 语言的核心关键字，具有特殊的语法含义。
  ** 它们不能用作变量名或函数名。
  */
  
  /* 逻辑和控制关键字 */
  TK_AND = FIRST_RESERVED,  /* and - 逻辑与操作符 */
  TK_BREAK,                 /* break - 跳出循环语句 */
  
  /* 控制结构关键字 */
  TK_DO,                    /* do - 块开始关键字 */
  TK_ELSE,                  /* else - 条件语句分支 */
  TK_ELSEIF,                /* elseif - 条件语句多分支 */
  TK_END,                   /* end - 块结束关键字 */
  
  /* 字面量和数据类型 */
  TK_FALSE,                 /* false - 布尔假值 */
  
  /* 循环和迭代 */
  TK_FOR,                   /* for - 循环语句关键字 */
  TK_FUNCTION,              /* function - 函数定义关键字 */
  
  /* 条件控制 */
  TK_IF,                    /* if - 条件语句关键字 */
  TK_IN,                    /* in - for 循环中的迭代关键字 */
  
  /* 作用域和声明 */
  TK_LOCAL,                 /* local - 局部变量声明 */
  
  /* 特殊值 */
  TK_NIL,                   /* nil - 空值字面量 */
  
  /* 逻辑操作 */
  TK_NOT,                   /* not - 逻辑非操作符 */
  TK_OR,                    /* or - 逻辑或操作符 */
  
  /* 循环控制 */
  TK_REPEAT,                /* repeat - repeat-until 循环 */
  TK_RETURN,                /* return - 函数返回语句 */
  TK_THEN,                  /* then - if-then 语句连接 */
  
  /* 布尔值 */
  TK_TRUE,                  /* true - 布尔真值 */
  
  /* 循环结束 */
  TK_UNTIL,                 /* until - repeat-until 循环结束 */
  TK_WHILE,                 /* while - while 循环关键字 */
  
  /*
  ** [操作符] 复合操作符 Token
  ** 
  ** 这些是由多个字符组成的操作符，需要特殊识别。
  */
  TK_CONCAT,                /* .. - 字符串连接操作符 */
  TK_DOTS,                  /* ... - 可变参数操作符 */
  TK_EQ,                    /* == - 相等比较操作符 */
  TK_GE,                    /* >= - 大于等于比较操作符 */
  TK_LE,                    /* <= - 小于等于比较操作符 */
  TK_NE,                    /* ~= - 不等比较操作符 */
  
  /*
  ** [字面量] 字面量和标识符 Token
  **
  ** 这些 Token 携带语义信息，需要额外的数据存储。
  */
  TK_NUMBER,                /* 数值字面量（整数或浮点数）*/
  TK_NAME,                  /* 标识符（变量名、函数名等）*/
  TK_STRING,                /* 字符串字面量 */
  
  /*
  ** [特殊] 特殊控制 Token
  */
  TK_EOS                    /* 输入流结束标记 */
};

/*
** [常量] 保留字数量
**
** 计算方式：从第一个保留字到最后一个保留字的数量
** 用途：
** - 保留字数组大小确定
** - 保留字查找表的初始化
** - 编译器优化和验证
*/
#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))

/*
** ====================================================================
** [数据] Token 名称字符串数组
** ====================================================================
*/

/*
** [数据] Token 名称映射数组
**
** 功能：提供 Token 类型到字符串名称的映射
** 
** 用途：
** - 错误消息的友好显示
** - 调试信息的输出
** - 语法分析器的错误报告
** - 开发工具的 Token 显示
**
** 注意：数组索引与 Token 枚举值对应
*/
LUAI_DATA const char *const luaX_tokens [];

/*
** ====================================================================
** [结构] Token 语义信息联合体
** ====================================================================
*/

/*
** [联合体] Token 语义信息
**
** 功能：存储不同类型 Token 的语义数据
** 
** 字段说明：
** @r: lua_Number 数值字面量的值
** @ts: TString* 字符串字面量或标识符的字符串对象
**
** 设计原理：
** - 使用联合体节省内存空间
** - 不同 Token 类型需要不同的语义信息
** - 数值 Token 存储计算后的数值
** - 字符串和标识符存储字符串对象引用
**
** 内存布局：
** - 联合体大小为最大成员的大小
** - 通常是 8 字节（64位指针或双精度浮点）
** - 访问时根据 Token 类型选择正确字段
*/
typedef union {
  lua_Number r;      /* 数值字面量的数值 */
  TString *ts;       /* 字符串字面量或标识符的字符串对象 */
} SemInfo;  /* 语义信息存储 */

/*
** ====================================================================
** [结构] Token 结构体定义
** ====================================================================
*/

/*
** [结构] Token 完整信息
**
** 功能：表示词法分析产生的一个完整 Token
** 
** 字段说明：
** @token: int Token 类型（对应 RESERVED 枚举或字符 ASCII 值）
** @seminfo: SemInfo 语义信息（根据 Token 类型解释）
**
** Token 类型分类：
** - 单字符 Token：ASCII 值（如 '+' = 43）
** - 保留字 Token：RESERVED 枚举值（>=257）
** - 复合操作符：RESERVED 枚举值
** - 字面量 Token：RESERVED 枚举值 + 语义信息
**
** 使用方式：
** - 词法分析器生成 Token 流
** - 语法分析器消费 Token 进行解析
** - 错误处理时提供位置和类型信息
*/
typedef struct Token {
  int token;          /* Token 类型标识 */
  SemInfo seminfo;    /* Token 语义信息 */
} Token;


/*
** ====================================================================
** [结构] 词法分析器状态结构体
** ====================================================================
*/

/*
** [结构] 词法分析器状态
**
** 功能：维护词法分析过程中的所有状态信息
** 
** 核心职责：
** 1. [输入] 管理输入字符流的读取
** 2. [位置] 跟踪当前解析位置和行号
** 3. [Token] 维护当前和预读 Token
** 4. [缓存] 管理 Token 构建的缓冲区
** 5. [上下文] 连接语法分析器和运行时状态
**
** 字段详细说明：
*/
typedef struct LexState {
  /*
  ** [输入管理] 字符流控制字段
  */
  int current;              /* 当前读取的字符（charint 类型）
                            ** - 存储当前正在处理的字符
                            ** - 使用 int 而非 char 支持 EOF 标记
                            ** - 值为 -1 表示流结束
                            ** - 支持 Unicode 和扩展字符集 */
  
  /*
  ** [位置跟踪] 源码位置信息字段
  */
  int linenumber;           /* 输入行计数器
                            ** - 从 1 开始计数的行号
                            ** - 遇到换行符时递增
                            ** - 用于错误消息的位置报告
                            ** - 调试信息的行号记录 */
                            
  int lastline;             /* 最后消费的 Token 所在行号
                            ** - 记录上一个处理完成的 Token 行号
                            ** - 用于语法错误的精确定位
                            ** - 支持跨行 Token 的位置管理
                            ** - 错误恢复时的上下文信息 */
  
  /*
  ** [Token 管理] 当前 Token 状态字段
  */
  Token t;                  /* 当前 Token 信息
                            ** - 存储正在处理的 Token
                            ** - 包含 Token 类型和语义信息
                            ** - 语法分析器的主要输入
                            ** - Token 流的当前位置 */
                            
  Token lookahead;          /* 预读 Token 信息
                            ** - 单 Token 预读缓存
                            ** - 支持语法分析的前瞻需求
                            ** - LL(1) 解析器的关键支持
                            ** - 减少回溯和重新解析 */
  
  /*
  ** [上下文连接] 关联状态字段
  */
  struct FuncState *fs;     /* 函数解析状态指针
                            ** - 连接到语法分析器的函数状态
                            ** - FuncState 是解析器的私有结构
                            ** - 提供作用域和局部变量信息
                            ** - 支持嵌套函数的解析上下文 */
                            
  struct lua_State *L;      /* Lua 虚拟机状态指针
                            ** - 连接到主要的 Lua 运行时
                            ** - 提供内存分配和 GC 服务
                            ** - 错误处理和异常传播
                            ** - 字符串内部化服务 */
  
  /*
  ** [输入源] 数据源管理字段
  */
  ZIO *z;                   /* 输入流抽象接口
                            ** - 统一的输入流抽象
                            ** - 支持文件、字符串、内存等多种源
                            ** - 缓冲和预读功能
                            ** - 流结束检测和错误处理 */
  
  /*
  ** [缓冲管理] Token 构建缓冲区
  */
  Mbuffer *buff;            /* Token 构建缓冲区
                            ** - 动态增长的字符缓冲区
                            ** - 用于构建标识符和字符串字面量
                            ** - 支持转义序列的处理
                            ** - 内存高效的临时存储 */
  
  /*
  ** [源信息] 源文件标识字段
  */
  TString *source;          /* 当前源代码名称
                            ** - 源文件的名称或标识符
                            ** - 用于错误消息和调试信息
                            ** - 支持 chunk 名称和文件路径
                            ** - 错误追踪的重要信息 */
  
  /*
  ** [本地化] 数值解析配置字段
  */
  char decpoint;            /* 本地化小数点字符
                            ** - 当前语言环境的小数点符号
                            ** - 通常是 '.' 或 ','
                            ** - 支持国际化的数值解析
                            ** - 与系统 locale 设置同步 */
} LexState;

/*
** ====================================================================
** [函数] 词法分析器公共接口
** ====================================================================
*/

/*
** [初始化] 词法分析器初始化函数
**
** 功能：初始化词法分析器的全局状态
** @param L: lua_State* Lua 虚拟机状态
**
** 初始化内容：
** - 保留字哈希表的建立
** - Token 名称数组的设置
** - 全局词法分析器配置
** - 本地化设置的获取
**
** 调用时机：
** - Lua 虚拟机启动时
** - 首次编译代码前
** - 系统初始化阶段
*/
LUAI_FUNC void luaX_init (lua_State *L);

/*
** [设置] 词法分析器输入配置函数
**
** 功能：为词法分析器设置输入源和上下文
** @param L: lua_State* Lua 虚拟机状态
** @param ls: LexState* 词法分析器状态结构
** @param z: ZIO* 输入流接口
** @param source: TString* 源代码名称
**
** 配置内容：
** - 输入流的绑定和初始化
** - 词法分析器状态的重置
** - 源文件信息的设置
** - 初始字符的读取和准备
**
** 调用时机：
** - 开始解析新的代码块时
** - 切换输入源时
** - 错误恢复后重新开始时
*/
LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
                              TString *source);

/*
** [字符串] 新字符串创建函数
**
** 功能：创建新的内部化字符串对象
** @param ls: LexState* 词法分析器状态
** @param str: const char* 源字符串数据
** @param l: size_t 字符串长度
** @return: TString* 新创建的字符串对象
**
** 创建过程：
** - 字符串数据的复制和处理
** - 字符串内部化和哈希计算
** - GC 对象的注册和管理
** - 字符串池的更新
**
** 使用场景：
** - 标识符的创建和存储
** - 字符串字面量的处理
** - 保留字的内部化
** - 临时字符串的构建
*/
LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);

/*
** [扫描] 下一个 Token 获取函数
**
** 功能：扫描并返回下一个 Token
** @param ls: LexState* 词法分析器状态
**
** 扫描过程：
** - 跳过空白字符和注释
** - 识别 Token 类型和边界
** - 提取语义信息和构建 Token
** - 更新词法分析器状态
**
** Token 类型处理：
** - 保留字的识别和映射
** - 操作符的多字符匹配
** - 数值字面量的解析和转换
** - 字符串字面量的转义处理
**
** 调用时机：
** - 语法分析器需要新 Token 时
** - 预读 Token 的构建时
** - Token 流的正常推进
*/
LUAI_FUNC void luaX_next (LexState *ls);

/*
** [预读] Token 预读函数
**
** 功能：构建预读 Token 而不推进主 Token
** @param ls: LexState* 词法分析器状态
**
** 预读机制：
** - 在不影响当前 Token 的情况下预读
** - 支持 LL(1) 语法分析器的前瞻需求
** - 缓存预读结果避免重复扫描
** - 处理复杂语法结构的歧义
**
** 实现特点：
** - 单 Token 预读缓存
** - 延迟计算和按需加载
** - 与主 Token 流的同步
** - 错误状态的一致性维护
*/
LUAI_FUNC void luaX_lookahead (LexState *ls);

/*
** [错误] 词法错误报告函数
**
** 功能：报告词法分析阶段的错误
** @param ls: LexState* 词法分析器状态
** @param msg: const char* 错误消息模板
** @param token: int 相关的 Token 类型
**
** 错误处理：
** - 构建详细的错误消息
** - 包含源文件和行号信息
** - 提供 Token 类型的上下文
** - 触发 Lua 的错误处理机制
**
** 错误类型：
** - 非法字符或字符序列
** - 未终止的字符串字面量
** - 数值格式错误
** - 超长标识符或字符串
*/
LUAI_FUNC void luaX_lexerror (LexState *ls, const char *msg, int token);

/*
** [错误] 语法错误报告函数
**
** 功能：报告语法分析阶段的错误（由词法分析器调用）
** @param ls: LexState* 词法分析器状态
** @param s: const char* 错误消息字符串
**
** 错误上下文：
** - 基于当前 Token 的语法错误
** - 与词法错误的协调处理
** - 错误恢复策略的支持
** - 用户友好的错误消息
**
** 调用场景：
** - 词法分析器检测到语法问题时
** - Token 序列不符合语法规则时
** - 语法分析器请求错误报告时
*/
LUAI_FUNC void luaX_syntaxerror (LexState *ls, const char *s);

/*
** [工具] Token 转字符串函数
**
** 功能：将 Token 类型转换为可读的字符串表示
** @param ls: LexState* 词法分析器状态
** @param token: int Token 类型标识
** @return: const char* Token 的字符串表示
**
** 转换规则：
** - 保留字返回关键字字符串
** - 操作符返回符号字符串
** - 字面量返回类型描述
** - 特殊 Token 返回标准名称
**
** 使用场景：
** - 错误消息的生成
** - 调试信息的输出
** - 开发工具的显示
** - 语法分析器的诊断
*/
LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);


#endif
