/*
** ====================================================================
** Lua 虚拟机操作码定义头文件 (lopcodes.h)
** ====================================================================
**
** 版本信息: $Id: lopcodes.h,v 1.125.1.1 2007/12/27 13:02:25 roberto Exp $
** 版权声明: 参见 lua.h 中的版权信息
**
** 模块职责:
** 本文件是 Lua 虚拟机的核心组件，定义了虚拟机的完整指令集架构。
** 包含操作码、指令格式、参数编码和解码机制等关键内容。
**
** 主要功能:
** 1. [指令格式] 定义虚拟机指令的二进制编码格式
** 2. [操作码表] 完整的 Lua 虚拟机指令集定义
** 3. [参数解析] 指令参数的提取和设置宏
** 4. [常量处理] 寄存器和常量的区分机制
** 5. [指令属性] 操作码的模式和属性信息
**
** 架构特点:
** - 32位固定长度指令编码
** - 支持3种指令格式：iABC、iABx、iAsBx
** - 高效的位操作宏实现
** - 完整的类型安全检查
**
** 技术细节:
** - 操作码：6位 (支持64个不同指令)
** - A参数：8位 (256个寄存器)
** - B/C参数：各9位 (512个值)
** - Bx参数：18位 (262144个值)
** - sBx参数：带符号18位 (-131072 到 +131071)
**
** 重要说明:
** 本文件是 Lua 解释器性能的关键，任何修改都可能影响虚拟机执行效率。
** 指令编码与解码操作通过内联宏实现，确保最佳运行时性能。
*/

#ifndef lopcodes_h
#define lopcodes_h

#include "llimits.h"


/*
** ====================================================================
** [核心] Lua 虚拟机指令编码架构
** ====================================================================
**
** 指令格式假设:
** - 所有指令都是无符号32位整数
** - 前6位始终是操作码 (支持64种不同指令)
** - 剩余26位用于参数编码
**
** 指令可以包含以下字段:
** - A  : 8位参数  (0-255)      - 通常是目标寄存器
** - B  : 9位参数  (0-511)      - 通常是源操作数
** - C  : 9位参数  (0-511)      - 通常是源操作数
** - Bx : 18位参数 (0-262143)   - B和C字段组合，用于大常量
** - sBx: 带符号18位 (-131072到+131071) - 用于跳转偏移
**
** 带符号参数表示法:
** 带符号参数使用超额K表示法，即实际值 = 无符号值 - K
** 其中 K 是该参数的最大值，这样:
** - 最小值(-max)用0表示
** - 最大值(+max)用2*max表示
** - 零值用max表示
** 这种编码方式使负数和正数都能有效表示。
**
** 指令布局示意 (32位):
** +------+--------+--------+--------+
** | 操作码 |   A   |   B   |   C   |  iABC格式
** | 6位  | 8位   | 9位   | 9位   |
** +------+--------+---------------+
** | 操作码 |   A   |      Bx      |  iABx格式  
** | 6位  | 8位   |     18位     |
** +------+--------+---------------+
** | 操作码 |   A   |     sBx      |  iAsBx格式
** | 6位  | 8位   |  带符号18位   |
** +------+--------+---------------+
*/


/*
** [核心] 基本指令格式枚举
**
** Lua虚拟机支持三种基本指令格式，每种格式适用于不同类型的操作：
**
** iABC  - 三参数格式，最常用的指令格式
**         适用于：算术运算、表操作、函数调用等
**         示例：ADD R(A) := R(B) + R(C)
**
** iABx  - 大参数格式，用于需要大常量索引的操作  
**         适用于：常量加载、全局变量访问等
**         示例：LOADK R(A) := Kst(Bx)
**
** iAsBx - 带符号参数格式，用于控制流操作
**         适用于：跳转指令、循环控制等
**         示例：JMP pc += sBx
*/
enum OpMode {iABC, iABx, iAsBx};


/*
** ====================================================================
** [核心] 指令字段大小和位置定义
** ====================================================================
**
** 字段大小定义 (单位：位):
** - C字段：9位   - 第二源操作数或常量索引
** - B字段：9位   - 第一源操作数或常量索引  
** - A字段：8位   - 目标寄存器，通常是结果存储位置
** - 操作码：6位  - 指令类型标识
**
** 组合字段：
** - Bx字段：18位 - B和C字段的组合，用于大索引值
**
** 特殊说明：
** Bx字段占用B和C字段的所有位，提供更大的数值范围，
** 主要用于常量表索引和函数原型索引等需要大数值的场景。
*/
#define SIZE_C		9
#define SIZE_B		9
#define SIZE_Bx		(SIZE_C + SIZE_B)
#define SIZE_A		8

#define SIZE_OP		6

/*
** 字段位置定义 (从低位开始计算):
**
** 32位指令的位分布：
** 位31-26: 未使用 (保留)
** 位25-8:  参数字段 (A, B, C 或 A, Bx)
** 位7-6:   参数字段A的高位部分
** 位5-0:   操作码
**
** 位置计算：
** - 操作码从第0位开始
** - A字段从第6位开始 (操作码之后)
** - C字段从第14位开始 (A字段之后)
** - B字段从第23位开始 (C字段之后)
** - Bx字段与C字段位置相同 (覆盖B和C)
*/
#define POS_OP		0
#define POS_A		(POS_OP + SIZE_OP)
#define POS_C		(POS_A + SIZE_A)
#define POS_B		(POS_C + SIZE_C)
#define POS_Bx		POS_C


/*
** ====================================================================
** [核心] 操作码参数的取值限制
** ====================================================================
**
** 参数限制说明：
** 由于我们使用(带符号)int来操作大部分参数，所以参数必须能够
** 容纳在 LUAI_BITSINT-1 位中（-1是为了符号位）。
**
** Bx和sBx参数的特殊处理：
** - 如果 SIZE_Bx 小于 LUAI_BITSINT-1，使用标准位移计算
** - 否则使用 MAX_INT 作为上限，确保不会溢出
**
** sBx的编码方式：
** sBx是带符号的Bx，使用超额编码：
** - 实际值 = 无符号值 - MAXARG_sBx
** - 这样负数、零、正数都能有效表示
*/
#if SIZE_Bx < LUAI_BITSINT-1
#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
#define MAXARG_sBx        (MAXARG_Bx>>1)         /* sBx是带符号的 */
#else
#define MAXARG_Bx        MAX_INT
#define MAXARG_sBx        MAX_INT
#endif

/*
** 各参数字段的最大值：
** - MAXARG_A: A字段最大值 (255)      - 最多256个寄存器
** - MAXARG_B: B字段最大值 (511)      - 支持512个值
** - MAXARG_C: C字段最大值 (511)      - 支持512个值
**
** 实际应用：
** - A通常表示寄存器索引，限制了函数内最大寄存器数
** - B和C可以是寄存器索引或常量索引
** - 这些限制平衡了指令紧凑性和表达能力
*/
#define MAXARG_A        ((1<<SIZE_A)-1)
#define MAXARG_B        ((1<<SIZE_B)-1)
#define MAXARG_C        ((1<<SIZE_C)-1)


/*
** ====================================================================
** [实用] 位掩码生成宏
** ====================================================================
*/

/*
** [实用] 创建具有n个1位的掩码，位于位置p
**
** 功能：生成一个掩码，在指定位置包含连续的1位
** @param n: 1位的数量
** @param p: 起始位置（从0开始）
** @return: 生成的位掩码
**
** 实现原理：
** 1. ~(Instruction)0 生成全1的值
** 2. (~(Instruction)0)<<n 左移n位，低n位变成0
** 3. ~(...) 取反，得到低n位为1的掩码  
** 4. (...<<p) 将掩码移动到位置p
**
** 使用示例：
** MASK1(6,0) = 0x3F     // 低6位为1，用于操作码掩码
** MASK1(8,6) = 0x3FC0   // 第6-13位为1，用于A字段掩码
*/
#define MASK1(n,p)	((~((~(Instruction)0)<<n))<<p)

/*
** [实用] 创建具有n个0位的掩码，位于位置p  
**
** 功能：生成一个掩码，在指定位置包含连续的0位，其他位为1
** @param n: 0位的数量
** @param p: 起始位置（从0开始）
** @return: 生成的位掩码
**
** 实现原理：
** 对 MASK1(n,p) 的结果取反，将1位变成0位，0位变成1位
**
** 使用示例：
** MASK0(6,0) = 0xFFFFFFC0  // 低6位为0，用于清除操作码
** MASK0(8,6) = 0xFFFFC03F  // 第6-13位为0，用于清除A字段
**
** 应用场景：
** 通常与按位AND操作结合，用于清除指令中的特定字段，
** 为设置新值做准备。
*/
#define MASK0(n,p)	(~MASK1(n,p))

/*
** ====================================================================
** [核心] 指令操作宏 - 高性能指令解析和构造
** ====================================================================
**
** 以下宏提供了高效的指令字段提取和设置功能，是虚拟机执行的核心。
** 所有操作都使用位运算，确保最佳性能。
*/

/*
** [核心] 操作码提取和设置宏
**
** GET_OPCODE: 从指令中提取操作码
** @param i: 指令值 (Instruction类型)
** @return: 操作码 (OpCode类型，0-63)
**
** 提取过程：
** 1. 右移POS_OP位，将操作码移到低位
** 2. 与MASK1(SIZE_OP,0)按位AND，只保留低6位
** 3. 转换为OpCode类型
*/
#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))

/*
** SET_OPCODE: 在指令中设置操作码
** @param i: 目标指令变量
** @param o: 新操作码值
**
** 设置过程：
** 1. 用MASK0清除原操作码字段
** 2. 将新操作码左移到正确位置
** 3. 用MASK1确保只影响操作码字段
** 4. 按位OR合并到指令中
*/
#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

/*
** [核心] A字段提取和设置宏
**
** GETARG_A: 提取A参数（通常是目标寄存器）
** @param i: 指令值
** @return: A字段值 (0-255)
*/
#define GETARG_A(i)	(cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))

/*
** SETARG_A: 设置A参数
** @param i: 目标指令变量  
** @param u: 新A值
*/
#define SETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
		((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))

/*
** [核心] B字段提取和设置宏
**
** GETARG_B: 提取B参数（通常是第一源操作数）
** @param i: 指令值
** @return: B字段值 (0-511)
*/
#define GETARG_B(i)	(cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))

/*
** SETARG_B: 设置B参数
** @param i: 目标指令变量
** @param b: 新B值
*/
#define SETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
		((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))

/*
** [核心] C字段提取和设置宏
**
** GETARG_C: 提取C参数（通常是第二源操作数）
** @param i: 指令值
** @return: C字段值 (0-511)
*/
#define GETARG_C(i)	(cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))

/*
** SETARG_C: 设置C参数
** @param i: 目标指令变量
** @param b: 新C值
*/
#define SETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
		((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))

/*
** [核心] Bx字段提取和设置宏（18位大参数）
**
** GETARG_Bx: 提取Bx参数（B和C字段组合）
** @param i: 指令值
** @return: Bx字段值 (0-262143)
**
** 用途：常量表索引、函数原型索引等大数值
*/
#define GETARG_Bx(i)	(cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))

/*
** SETARG_Bx: 设置Bx参数
** @param i: 目标指令变量
** @param b: 新Bx值
*/
#define SETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
		((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))

/*
** [核心] sBx字段提取和设置宏（带符号18位参数）
**
** GETARG_sBx: 提取带符号Bx参数
** @param i: 指令值  
** @return: 带符号整数 (-131072 到 +131071)
**
** 解码过程：从无符号Bx值减去MAXARG_sBx，得到带符号值
** 用途：跳转偏移、循环控制等需要正负值的场景
*/
#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)

/*
** SETARG_sBx: 设置带符号Bx参数
** @param i: 目标指令变量
** @param b: 带符号整数值
**
** 编码过程：将带符号值加上MAXARG_sBx，转换为无符号值存储
*/
#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))


/*
** ====================================================================
** [实用] 指令创建宏 - 快速指令构造
** ====================================================================
*/

/*
** [实用] 创建ABC格式指令
**
** 功能：从操作码和三个参数快速构造一条完整指令
** @param o: 操作码 (OpCode)
** @param a: A参数 (0-255)
** @param b: B参数 (0-511)  
** @param c: C参数 (0-511)
** @return: 完整的32位指令
**
** 构造过程：
** 1. 将操作码左移到正确位置
** 2. 将A参数左移到正确位置
** 3. 将B参数左移到正确位置
** 4. 将C参数左移到正确位置
** 5. 按位OR合并所有字段
**
** 使用场景：
** 代码生成器构造算术运算、表操作、函数调用等指令
*/
#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, b)<<POS_B) \
			| (cast(Instruction, c)<<POS_C))

/*
** [实用] 创建ABx格式指令
**
** 功能：从操作码、A参数和Bx参数构造指令
** @param o: 操作码 (OpCode)
** @param a: A参数 (0-255)
** @param bc: Bx参数 (0-262143)
** @return: 完整的32位指令
**
** 构造过程：
** 1. 将操作码左移到位置0
** 2. 将A参数左移到位置6
** 3. 将Bx参数左移到位置14
** 4. 按位OR合并所有字段
**
** 使用场景：
** 代码生成器构造常量加载、全局变量访问等需要大索引的指令
*/
#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, bc)<<POS_Bx))


/*
** ====================================================================
** [核心] RK索引操作宏 - 寄存器/常量统一编码
** ====================================================================
**
** RK编码系统说明：
** Lua虚拟机使用RK编码来统一表示寄存器和常量，这是一个重要的优化技术。
** 在B和C参数中，最高位用作标志位来区分寄存器和常量引用。
*/

/*
** [核心] 常量标志位
**
** 功能：标识RK值是否为常量引用
** 值：0x100 (二进制: 100000000)
**
** 编码规则：
** - 如果bit 8 = 1，表示常量引用
** - 如果bit 8 = 0，表示寄存器引用
**
** 设计优势：
** 这种编码方式使得指令可以灵活地混合使用寄存器和常量，
** 无需额外的指令变体，提高了指令集的紧凑性。
*/
#define BITRK		(1 << (SIZE_B - 1))

/*
** [实用] 常量测试宏
**
** 功能：测试RK值是否为常量引用
** @param x: RK编码值
** @return: 非零表示常量，0表示寄存器
**
** 实现：检查最高位是否为1
*/
#define ISK(x)		((x) & BITRK)

/*
** [实用] 常量索引提取宏
**
** 功能：从RK编码中提取实际的常量表索引
** @param r: RK编码值
** @return: 常量表中的索引 (0-255)
**
** 实现：清除常量标志位，保留低8位索引
*/
#define INDEXK(r)	((int)(r) & ~BITRK)

/*
** [核心] RK索引最大值
**
** 功能：定义RK编码中可用的最大索引值
** 值：255 (BITRK - 1)
**
** 意义：
** - 最多支持256个寄存器 (0-255)
** - 最多支持256个常量 (0-255)
** 这个限制来源于B和C字段只有9位，最高位用作标志位。
*/
#define MAXINDEXRK	(BITRK - 1)

/*
** [实用] 常量RK编码宏
**
** 功能：将常量索引编码为RK值
** @param x: 常量表索引 (0-255)
** @return: 编码后的RK值
**
** 实现：设置常量标志位
** 使用场景：代码生成时将常量引用编码到指令中
*/
#define RKASK(x)	((x) | BITRK)


/*
** ====================================================================
** [核心] 特殊寄存器定义和符号约定
** ====================================================================
*/

/*
** [核心] 无效寄存器标识
**
** 功能：表示无效或未使用的寄存器引用
** 值：255 (MAXARG_A)
**
** 使用场景：
** - 指令不需要目标寄存器时的占位符
** - 表示操作不产生结果
** - 编译器内部的特殊标记
**
** 选择依据：
** 使用8位A字段的最大值，确保在正常寄存器范围内，
** 但作为特殊值使用，避免与有效寄存器冲突。
*/
#define NO_REG		MAXARG_A

/*
** ====================================================================
** [约定] 指令参数符号约定
** ====================================================================
**
** 为了便于理解指令语义，我们使用以下符号约定：
**
** R(x)    - 寄存器：表示栈中索引为x的寄存器
**           示例：R(0) 表示栈底寄存器，R(1) 表示下一个寄存器
**
** Kst(x)  - 常量：表示常量表中索引为x的常量
**           示例：Kst(0) 表示第一个字符串常量
**
** RK(x)   - 寄存器或常量：根据ISK(x)的值决定
**           if ISK(x) then Kst(INDEXK(x)) else R(x)
**           这种设计使指令能够灵活地接受寄存器或常量作为操作数
**
** 使用示例：
** - ADD指令：R(A) := RK(B) + RK(C)
**   可以是：R(0) := R(1) + R(2)      // 两个寄存器相加
**   也可以是：R(0) := R(1) + Kst(5)  // 寄存器加常量
**   还可以是：R(0) := Kst(3) + Kst(7) // 两个常量相加
*/


/*
** ====================================================================
** [核心] Lua 虚拟机操作码定义
** ====================================================================
**
** 重要提示：如果修改这些枚举值，请搜索 "ORDER OP" 来查找需要
** 同步更新的相关代码（如操作码名称数组、操作模式数组等）。
**
** 指令格式说明：
** name        args    description
** --------    ----    -----------
*/

typedef enum {
/*
** ====================================================================
** [基础] 数据移动和加载指令
** ====================================================================
*/

/*
** [基础] 寄存器间移动指令
** 格式：A B
** 操作：R(A) := R(B)
** 
** 功能：将源寄存器B的值复制到目标寄存器A
** 用途：变量赋值、参数传递、结果传输
** 性能：虚拟机中最快的指令之一，直接内存复制
*/
OP_MOVE,

/*
** [基础] 常量加载指令  
** 格式：A Bx
** 操作：R(A) := Kst(Bx)
**
** 功能：将常量表中索引为Bx的常量加载到寄存器A
** 用途：字面量加载（数字、字符串、布尔值等）
** 优化：Bx为18位，支持262144个不同常量
*/
OP_LOADK,

/*
** [基础] 布尔值加载指令
** 格式：A B C  
** 操作：R(A) := (Bool)B; if (C) pc++
**
** 功能：加载布尔值并可选择性跳过下一条指令
** 参数：B=0表示false，B≠0表示true；C≠0表示跳过下一条指令
** 用途：布尔常量加载、条件跳转的优化组合
** 优化：合并了加载和跳转，减少指令数量
*/
OP_LOADBOOL,

/*
** [基础] nil值批量加载指令
** 格式：A B
** 操作：R(A) := ... := R(B) := nil
**
** 功能：将从寄存器A到寄存器B的所有寄存器设置为nil
** 用途：变量初始化、数组清空、栈空间清理
** 效率：批量操作比逐个设置更高效
*/
OP_LOADNIL,

/*
** [基础] 上值获取指令
** 格式：A B
** 操作：R(A) := UpValue[B]
**
** 功能：从上值数组中获取索引为B的上值到寄存器A
** 用途：闭包变量访问、外层函数变量引用
** 机制：上值是闭包捕获的外部变量的存储机制
*/
OP_GETUPVAL,

/*
** ====================================================================
** [表操作] 全局变量和表访问指令
** ====================================================================
*/

/*
** [表操作] 全局变量获取指令
** 格式：A Bx
** 操作：R(A) := Gbl[Kst(Bx)]
**
** 功能：从全局表中获取名为Kst(Bx)的变量值到寄存器A
** 用途：全局变量读取、标准库函数访问
** 实现：Gbl表是特殊的全局环境表，通常是_G
** 优化：常量Bx直接索引，避免字符串哈希计算
*/
OP_GETGLOBAL,

/*
** [表操作] 表索引获取指令
** 格式：A B C
** 操作：R(A) := R(B)[RK(C)]
**
** 功能：从表R(B)中获取键RK(C)对应的值到寄存器A
** 用途：数组访问、哈希表查找、对象属性读取
** 灵活性：C可以是寄存器或常量，支持动态和静态索引
** 性能：表访问是Lua的核心操作，高度优化
*/
OP_GETTABLE,

/*
** ====================================================================
** [赋值] 变量赋值指令
** ====================================================================
*/

/*
** [赋值] 全局变量设置指令
** 格式：A Bx  
** 操作：Gbl[Kst(Bx)] := R(A)
**
** 功能：将寄存器A的值赋给全局变量Kst(Bx)
** 用途：全局变量赋值、模块导出
** 副作用：可能触发__newindex元方法
*/
OP_SETGLOBAL,

/*
** [赋值] 上值设置指令
** 格式：A B
** 操作：UpValue[B] := R(A)
**
** 功能：将寄存器A的值赋给上值数组中索引为B的上值
** 用途：闭包变量修改、外层变量更新
** 机制：修改闭包捕获的外部变量
*/
OP_SETUPVAL,

/*
** [赋值] 表索引设置指令
** 格式：A B C
** 操作：R(A)[RK(B)] := RK(C)
**
** 功能：将值RK(C)赋给表R(A)的键RK(B)
** 用途：数组赋值、哈希表插入、对象属性设置
** 灵活性：B和C都可以是寄存器或常量
** 副作用：可能触发__newindex元方法，导致表扩容
*/
OP_SETTABLE,

/*
** ====================================================================
** [构造] 对象构造指令
** ====================================================================
*/

/*
** [构造] 新表创建指令
** 格式：A B C
** 操作：R(A) := {} (size = B,C)
**
** 功能：创建一个新的空表，并预分配指定大小
** 参数：B指定数组部分大小提示，C指定哈希部分大小提示
** 用途：表字面量、数组初始化、对象创建
** 优化：预分配避免表增长时的重新分配开销
*/
OP_NEWTABLE,

/*
** [构造] self调用准备指令  
** 格式：A B C
** 操作：R(A+1) := R(B); R(A) := R(B)[RK(C)]
**
** 功能：为方法调用准备self参数和方法函数
** 机制：将对象复制到A+1作为self，将方法函数复制到A
** 用途：面向对象编程中的方法调用（obj:method()）
** 优化：单条指令完成两个操作，减少指令数
*/
OP_SELF,

/*
** ====================================================================
** [算术] 算术运算指令
** ====================================================================
*/

/*
** [算术] 加法指令
** 格式：A B C
** 操作：R(A) := RK(B) + RK(C)
**
** 功能：计算两个操作数的和
** 类型：支持数字加法和字符串连接（通过元方法）
** 优化：数字加法直接计算，字符串通过__add元方法
*/
OP_ADD,

/*
** [算术] 减法指令
** 格式：A B C  
** 操作：R(A) := RK(B) - RK(C)
**
** 功能：计算第一个操作数减去第二个操作数
** 类型：主要用于数字，也可通过__sub元方法扩展
*/
OP_SUB,

/*
** [算术] 乘法指令
** 格式：A B C
** 操作：R(A) := RK(B) * RK(C)
**
** 功能：计算两个操作数的乘积
** 类型：数字乘法，可通过__mul元方法扩展到其他类型
*/
OP_MUL,

/*
** [算术] 除法指令
** 格式：A B C
** 操作：R(A) := RK(B) / RK(C)
**
** 功能：计算第一个操作数除以第二个操作数
** 类型：数字除法，结果总是浮点数
** 错误：除零会产生运行时错误
*/
OP_DIV,

/*
** [算术] 取模指令
** 格式：A B C
** 操作：R(A) := RK(B) % RK(C)
**
** 功能：计算第一个操作数对第二个操作数的模
** 定义：a % b = a - floor(a/b) * b
** 特点：结果符号与除数相同，支持浮点模运算
*/
OP_MOD,

/*
** [算术] 幂运算指令
** 格式：A B C
** 操作：R(A) := RK(B) ^ RK(C)
**
** 功能：计算第一个操作数的第二个操作数次幂
** 实现：调用pow()数学函数
** 特点：支持分数指数，右结合性
*/
OP_POW,

/*
** [算术] 一元负号指令
** 格式：A B
** 操作：R(A) := -R(B)
**
** 功能：计算操作数的负值
** 类型：主要用于数字，可通过__unm元方法扩展
** 优化：数字直接取负，其他类型调用元方法
*/
OP_UNM,

/*
** [逻辑] 逻辑非指令
** 格式：A B
** 操作：R(A) := not R(B)
**
** 功能：计算操作数的逻辑非值
** 规则：只有nil和false为假，其他所有值为真
** 结果：总是返回true或false
*/
OP_NOT,

/*
** [实用] 长度指令
** 格式：A B  
** 操作：R(A) := length of R(B)
**
** 功能：获取对象的长度
** 类型：字符串返回字节长度，表返回数组部分长度
** 元方法：可通过__len元方法自定义长度计算
*/
OP_LEN,

/*
** ====================================================================
** [字符串] 字符串操作指令
** ====================================================================
*/

/*
** [字符串] 字符串连接指令
** 格式：A B C
** 操作：R(A) := R(B).. ... ..R(C)
**
** 功能：连接从寄存器B到寄存器C的所有值为字符串
** 优化：一次性连接多个值，避免多次分配
** 转换：非字符串值自动转换为字符串
** 性能：使用缓冲区避免重复的内存分配
*/
OP_CONCAT,

/*
** ====================================================================
** [控制流] 跳转和比较指令  
** ====================================================================
*/

/*
** [控制流] 无条件跳转指令
** 格式：sBx
** 操作：pc += sBx
**
** 功能：程序计数器增加sBx，实现无条件跳转
** 范围：sBx是带符号数，支持向前和向后跳转
** 用途：循环、条件分支、函数退出等控制结构
*/
OP_JMP,

/*
** [比较] 相等比较指令
** 格式：A B C
** 操作：if ((RK(B) == RK(C)) ~= A) then pc++
**
** 功能：比较两个值是否相等，根据A决定跳转条件
** 逻辑：如果比较结果与A不同，则跳过下一条指令
** 用法：A=1表示相等时跳转，A=0表示不等时跳转
** 类型：支持所有Lua类型的相等比较
*/
OP_EQ,

/*
** [比较] 小于比较指令
** 格式：A B C
** 操作：if ((RK(B) < RK(C)) ~= A) then pc++
**
** 功能：比较第一个值是否小于第二个值
** 逻辑：如果比较结果与A不同，则跳过下一条指令
** 类型：数字直接比较，字符串按字典序，其他类型通过元方法
*/
OP_LT,

/*
** [比较] 小于等于比较指令
** 格式：A B C  
** 操作：if ((RK(B) <= RK(C)) ~= A) then pc++
**
** 功能：比较第一个值是否小于等于第二个值
** 逻辑：如果比较结果与A不同，则跳过下一条指令
** 优化：避免了分离的小于和等于比较
*/
OP_LE,

/*
** [控制流] 真值测试指令
** 格式：A C
** 操作：if not (R(A) <=> C) then pc++
**
** 功能：测试寄存器A的真值性，根据C决定跳转条件
** 真值：只有nil和false为假，其他所有值为真
** 逻辑：如果R(A)的真值性与C不符，则跳过下一条指令
** 用途：条件分支的核心指令
*/
OP_TEST,

/*
** [控制流] 测试并设置指令
** 格式：A B C
** 操作：if (R(B) <=> C) then R(A) := R(B) else pc++
**
** 功能：测试R(B)的真值性，符合C则赋值给R(A)，否则跳转
** 优化：合并了测试、赋值和跳转三个操作
** 用途：逻辑运算符and/or的高效实现
*/
OP_TESTSET, 

/*
** ====================================================================
** [函数] 函数调用和返回指令
** ====================================================================
*/

/*
** [函数] 函数调用指令
** 格式：A B C
** 操作：R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
**
** 功能：调用函数R(A)，传入B-1个参数，接收C-1个返回值
** 参数：R(A+1)到R(A+B-1)是参数列表
** 返回：R(A)到R(A+C-2)存储返回值
** 特殊：B=0表示参数到栈顶，C=0表示接收所有返回值
** 机制：支持多返回值，可变参数，尾调用优化
*/
OP_CALL,

/*
** [函数] 尾调用指令
** 格式：A B C
** 操作：return R(A)(R(A+1), ... ,R(A+B-1))
**
** 功能：执行尾调用并直接返回结果，无需返回当前函数
** 优化：不增加调用栈深度，避免栈溢出
** 用途：递归函数优化，函数末尾的调用
** 机制：复用当前栈帧，直接跳转到被调用函数
*/
OP_TAILCALL,

/*
** [函数] 函数返回指令
** 格式：A B
** 操作：return R(A), ... ,R(A+B-2)
**
** 功能：从当前函数返回指定数量的值
** 返回：R(A)到R(A+B-2)是返回值列表
** 特殊：B=0表示返回到栈顶的所有值
** 机制：恢复调用者的栈帧，传递返回值
*/
OP_RETURN,

/*
** ====================================================================
** [循环] 数值for循环指令
** ====================================================================
*/

/*
** [循环] for循环体指令
** 格式：A sBx
** 操作：R(A) += R(A+2);
**       if R(A) <?= R(A+1) then { pc += sBx; R(A+3) = R(A) }
**
** 功能：数值for循环的核心控制逻辑
** 寄存器：R(A)=当前值，R(A+1)=限制值，R(A+2)=步长，R(A+3)=循环变量
** 逻辑：增加当前值，检查是否超出限制，决定是否继续循环
** 优化：单条指令完成增量、比较、跳转和变量更新
*/
OP_FORLOOP,

/*
** [循环] for循环准备指令
** 格式：A sBx
** 操作：R(A) -= R(A+2); pc += sBx
**
** 功能：进入数值for循环前的准备工作
** 机制：将初始值减去步长，跳转到循环体
** 原因：FORLOOP指令先加步长再检查，所以需要提前减去
** 跳转：直接跳转到FORLOOP指令
*/
OP_FORPREP,

/*
** ====================================================================
** [循环] 泛型for循环指令
** ====================================================================
*/

/*
** [循环] 泛型for循环指令
** 格式：A C
** 操作：R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
**       if R(A+3) ~= nil then R(A+2) = R(A+3) else pc++
**
** 功能：泛型for循环的迭代控制
** 机制：调用迭代器函数，获取下一组值
** 检查：如果第一个返回值不是nil，继续循环并更新状态
** 寄存器：R(A)=迭代器，R(A+1)=状态，R(A+2)=控制变量
*/
OP_TFORLOOP, 
/*
** ====================================================================
** [表操作] 列表设置指令
** ====================================================================
*/

/*
** [表操作] 列表批量设置指令
** 格式：A B C
** 操作：R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
**
** 功能：批量设置表的数组部分
** 机制：将R(A+1)到R(A+B)的值设置到表R(A)的连续索引中
** 索引：起始索引 = (C-1) * FPF + 1，FPF是每批的字段数
** 用途：表构造器中的数组部分初始化
** 优化：批量操作比逐个设置更高效
*/
OP_SETLIST,

/*
** ====================================================================
** [函数] 闭包和上值管理指令
** ====================================================================
*/

/*
** [函数] 上值关闭指令
** 格式：A
** 操作：close all variables in the stack up to (>=) R(A)
**
** 功能：关闭栈中从R(A)开始的所有上值
** 机制：将开放上值转换为闭合上值，避免悬空指针
** 时机：离开作用域时，确保闭包正确捕获变量
** 用途：块结束、函数返回时的上值管理
*/
OP_CLOSE,

/*
** [函数] 闭包创建指令
** 格式：A Bx
** 操作：R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
**
** 功能：创建闭包，绑定函数原型和上值
** 参数：KPROTO[Bx]是函数原型，R(A)...R(A+n)是上值数组
** 机制：将函数原型与当前环境的变量绑定成闭包
** 用途：函数定义、嵌套函数创建
*/
OP_CLOSURE,

/*
** ====================================================================
** [函数] 可变参数指令
** ====================================================================
*/

/*
** [函数] 可变参数指令
** 格式：A B
** 操作：R(A), R(A+1), ..., R(A+B-1) = vararg
**
** 功能：获取可变参数到指定寄存器
** 机制：从函数的vararg区域复制参数到寄存器
** 特殊：B=0表示获取所有可变参数
** 用途：...操作符的实现，可变参数函数
*/
OP_VARARG
} OpCode;


/*
** [核心] 操作码总数
**
** 功能：定义虚拟机支持的操作码总数
** 计算：OP_VARARG的值加1（因为枚举从0开始）
** 用途：数组大小定义、循环边界、验证检查
** 限制：最多64个操作码（6位操作码字段的限制）
*/
#define NUM_OPCODES	(cast(int, OP_VARARG) + 1)

/*
** ====================================================================
** [重要] 指令行为特殊说明
** ====================================================================
**
** 以下说明描述了一些指令的特殊行为和实现细节：
**
** (*) OP_CALL指令中：
**     - 如果B == 0，则B = top（使用栈顶作为参数边界）
**     - C是返回值数量减1，可以为0
**     - 当C == 0时，OP_CALL设置top为last_result+1
**     - 这样下一个开放指令（OP_CALL、OP_RETURN、OP_SETLIST）可以使用top
**
** (*) OP_VARARG指令中：
**     - 如果B == 0，则使用实际的vararg数量并设置top
**     - 行为类似于C == 0的OP_CALL
**
** (*) OP_RETURN指令中：
**     - 如果B == 0，则返回到top为止的所有值
**
** (*) OP_SETLIST指令中：
**     - 如果B == 0，则B = top（使用栈顶值）
**     - 如果C == 0，则下一条指令包含真正的C值
**
** (*) 比较指令说明：
**     - A参数指定测试应该接受什么条件（true或false）
**     - 这种设计使得同一指令可以处理两种相反的条件
**
** (*) 跳转优化：
**     - 所有跳过指令（pc++）假设下一条指令是跳转指令
**     - 这种约定简化了控制流的编译和优化
**
** 这些特殊行为是Lua虚拟机高效实现的关键，它们：
** 1. 减少了指令数量
** 2. 提高了执行效率  
** 3. 简化了编译器实现
** 4. 支持Lua的动态特性
*/


/*
** ====================================================================
** [核心] 指令属性掩码定义
** ====================================================================
**
** 指令属性编码格式：
** 位0-1: 操作模式 (OpMode)
** 位2-3: C参数模式 (OpArgMask)  
** 位4-5: B参数模式 (OpArgMask)
** 位6:   指令是否设置寄存器A
** 位7:   操作符是否为测试指令
**
** 这种紧凑编码使得单个字节就能描述指令的所有重要属性，
** 为虚拟机的指令解析和优化提供了高效的元数据访问。
*/

/*
** [核心] 操作参数模式枚举
**
** 定义指令参数的使用方式和含义：
**
** OpArgN - 参数未使用
**          该位置的参数被忽略，不参与指令执行
**
** OpArgU - 参数已使用  
**          该参数在指令执行中被使用，但具体含义依指令而定
**
** OpArgR - 参数是寄存器或跳转偏移
**          可以是寄存器索引或相对跳转的偏移量
**
** OpArgK - 参数是常量或寄存器/常量
**          支持RK编码，可以是寄存器引用或常量引用
*/
enum OpArgMask {
  OpArgN,  /* 参数未使用 */
  OpArgU,  /* 参数已使用 */
  OpArgR,  /* 参数是寄存器或跳转偏移 */
  OpArgK   /* 参数是常量或寄存器/常量 */
};

/*
** [数据] 操作码模式数组声明
**
** luaP_opmodes数组包含每个操作码的属性信息，
** 数组索引对应OpCode枚举值，每个元素是上述格式的字节值。
*/
LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];

/*
** ====================================================================
** [实用] 指令属性查询宏
** ====================================================================
*/

/*
** [查询] 获取指令操作模式
** @param m: 操作码
** @return: OpMode枚举值 (iABC, iABx, iAsBx)
*/
#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))

/*
** [查询] 获取B参数模式
** @param m: 操作码
** @return: OpArgMask枚举值
*/
#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))

/*
** [查询] 获取C参数模式
** @param m: 操作码  
** @return: OpArgMask枚举值
*/
#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))

/*
** [查询] 测试指令是否设置A寄存器
** @param m: 操作码
** @return: 非零表示设置A寄存器
*/
#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))

/*
** [查询] 测试指令是否为测试指令
** @param m: 操作码  
** @return: 非零表示是测试指令（比较、条件跳转等）
*/
#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))


/*
** ====================================================================
** [数据] 调试和诊断支持
** ====================================================================
*/

/*
** [数据] 操作码名称数组声明
**
** luaP_opnames数组包含所有操作码的字符串名称，
** 主要用于调试、反汇编和错误报告。
**
** 数组特点：
** - 索引对应OpCode枚举值
** - 包含NUM_OPCODES+1个元素，最后一个元素为NULL
** - 字符串常量，不可修改
** - 按字母顺序与OpCode枚举保持一致
**
** 使用场景：
** - 虚拟机调试器显示指令名称
** - 字节码反汇编工具
** - 错误消息中的指令标识
** - 性能分析工具的指令统计
*/
LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];

/*
** ====================================================================
** [配置] 性能优化常量
** ====================================================================
*/

/*
** [优化] SETLIST指令批处理大小
**
** 功能：定义SETLIST指令累积多少个列表项后执行一次批量设置
** 值：50个元素
**
** 性能考虑：
** - 较大的值减少SETLIST指令的执行次数
** - 较小的值减少内存使用和单次操作的开销
** - 50是经过测试的平衡值
**
** 应用场景：
** - 表构造器 {1,2,3,...,n} 的优化
** - 大数组初始化的性能提升
** - 减少表扩容次数
**
** 实现细节：
** 编译器将表构造器中的连续元素分批，每LFIELDS_PER_FLUSH个
** 元素生成一条SETLIST指令，最后剩余的元素单独处理。
*/
#define LFIELDS_PER_FLUSH	50

#endif
