/**
 * @file lopcodes.h
 * @brief Lua虚拟机操作码定义：Lua 5.1虚拟机指令集架构的核心定义文件
 * 
 * 详细说明：
 * 本文件定义了Lua 5.1虚拟机的完整指令集架构，包括操作码枚举、指令格式、
 * 参数编码/解码宏以及相关的常量定义。这是Lua虚拟机执行引擎的基础组件，
 * 为字节码解释器提供了标准化的指令表示和操作接口。
 * 
 * 系统架构定位：
 * - 虚拟机层：作为Lua VM的指令集定义层
 * - 编译器后端：为代码生成器提供目标指令格式
 * - 解释器前端：为字节码解释器提供指令解析接口
 * - 调试支持：为调试器和反汇编器提供指令元信息
 * 
 * 技术特点：
 * - 基于32位定长指令格式，优化解码性能
 * - 采用三种指令格式（ABC、ABx、AsBx）支持不同参数需求
 * - 使用位域操作实现高效的参数编码/解码
 * - 支持寄存器-常量混合寻址模式（RK操作数）
 * - 提供完整的指令属性元数据支持
 * 
 * 指令集设计理念：
 * - 简洁性：指令数量适中（38个操作码），避免过度复杂
 * - 正交性：指令功能相互独立，减少特殊情况处理
 * - 效率性：针对动态类型语言特点优化的指令设计
 * - 可扩展性：预留指令编码空间，支持未来扩展
 * 
 * 内存布局和性能：
 * - 32位对齐的指令格式，提升缓存命中率
 * - 位域操作避免除法和乘法，提升解码速度
 * - 紧凑的操作码编码，减少指令缓存压力
 * - 支持跳转偏移的有符号编码，优化分支性能
 * 
 * 虚拟机设计特点：
 * - 基于寄存器的虚拟机架构（非栈式）
 * - 支持闭包和upvalue的一级对象处理
 * - 内置表操作指令，优化Lua表访问性能
 * - 支持尾调用优化的专用指令
 * - 集成垃圾回收协作的栈管理指令
 * 
 * 编译时依赖：
 * - llimits.h：基础类型定义和平台抽象
 * - lua.h：Lua API和基础常量定义
 * - C99标准：使用C99的预处理器特性
 * 
 * 使用示例：
 * @code
 * #include "lopcodes.h"
 * 
 * // 解码指令操作码
 * Instruction inst = 0x12345678;
 * OpCode op = GET_OPCODE(inst);
 * 
 * // 根据操作码获取指令格式
 * enum OpMode mode = getOpMode(op);
 * 
 * // 解码不同类型的参数
 * if (mode == iABC) {
 *     int a = GETARG_A(inst);
 *     int b = GETARG_B(inst);
 *     int c = GETARG_C(inst);
 *     // 处理ABC格式指令
 * } else if (mode == iABx) {
 *     int a = GETARG_A(inst);
 *     int bx = GETARG_Bx(inst);
 *     // 处理ABx格式指令
 * }
 * 
 * // 创建新指令
 * Instruction new_inst = CREATE_ABC(OP_ADD, 0, 1, 2);
 * 
 * // 检查RK操作数
 * int operand = GETARG_B(inst);
 * if (ISK(operand)) {
 *     int const_index = INDEXK(operand);
 *     // 使用常量表中的值
 * } else {
 *     // 使用寄存器中的值
 * }
 * @endcode
 * 
 * 性能特征：
 * - 指令解码：O(1)时间复杂度，纯位运算操作
 * - 内存占用：每条指令固定4字节，内存使用可预测
 * - 缓存友好：紧凑的指令编码提升指令缓存效率
 * - 分支预测：常用指令编码在较小数值范围，优化CPU分支预测
 * 
 * 扩展性考虑：
 * - 操作码空间：6位操作码支持最多64个指令
 * - 参数范围：A(8位)、B/C(9位)、Bx(18位)提供充足的参数范围
 * - 版本兼容：指令格式设计考虑向后兼容性
 * - 调试支持：预留指令属性位用于调试和分析工具
 * 
 * 注意事项：
 * - 指令编码假设小端字节序，在大端系统上需要特殊处理
 * - 有符号参数使用excess-K编码，需要注意数值范围转换
 * - RK操作数的常量/寄存器判断基于最高位，影响参数范围
 * - 部分指令的参数语义依赖于具体的虚拟机状态
 * 
 * @author Roberto Ierusalimschy et al.
 * @version 1.125.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lua.h, lvm.h, ldo.h
 */

#ifndef lopcodes_h
#define lopcodes_h

#include "llimits.h"

/**
 * @brief 指令格式枚举：定义Lua虚拟机的三种基本指令格式
 * 
 * 详细说明：
 * Lua虚拟机使用32位定长指令，根据参数需求不同采用三种格式：
 * - iABC：支持三个独立参数的通用格式
 * - iABx：支持一个大参数的格式（如常量索引）
 * - iAsBx：支持一个有符号大参数的格式（如跳转偏移）
 * 
 * 设计理念：
 * 三种格式的设计平衡了指令的表达能力和解码效率。ABC格式适用于
 * 大多数三操作数指令，ABx格式适用于需要大索引的操作，AsBx格式
 * 专门用于需要相对偏移的跳转指令。
 * 
 * 位域分布：
 * - iABC: [OP:6][A:8][C:9][B:9] - 总计32位
 * - iABx: [OP:6][A:8][Bx:18] - 总计32位  
 * - iAsBx: [OP:6][A:8][sBx:18] - 总计32位（sBx为有符号）
 * 
 * 使用模式：
 * - iABC：算术运算、逻辑运算、表操作等三元运算
 * - iABx：常量加载、全局变量访问、函数调用准备
 * - iAsBx：跳转指令、循环控制指令
 * 
 * 性能影响：
 * 统一的32位指令长度简化了取指和解码逻辑，提升了虚拟机的
 * 执行效率。三种格式的选择在编译时确定，运行时无需额外判断。
 * 
 * @since Lua 5.1
 * @see GET_OPCODE(), getOpMode()
 */
enum OpMode {iABC, iABx, iAsBx};

/**
 * @defgroup INSTRUCTION_LAYOUT 指令布局常量定义
 * @brief 定义Lua虚拟机指令的位域大小和位置常量
 * 
 * 这组常量定义了32位指令中各个字段的大小和位置，为指令编码/解码
 * 提供了基础参数。设计时充分考虑了参数范围需求和解码效率。
 * 
 * 位域设计原则：
 * - 操作码(OP)：6位支持64个指令，当前使用38个，预留扩展空间
 * - 参数A：8位支持256个寄存器，满足大多数函数的局部变量需求
 * - 参数B/C：9位支持512个值，其中256个寄存器+256个常量
 * - 参数Bx：18位支持262144个常量，满足大型程序的常量表需求
 * 
 * 内存对齐考虑：
 * 所有位域都按字节边界对齐，便于在不同平台上进行高效的位操作。
 * 
 * @{
 */

// 各字段的位数定义 - 决定了参数的取值范围
#define SIZE_C      9           /**< C字段位数：支持0-511的参数值 */
#define SIZE_B      9           /**< B字段位数：支持0-511的参数值 */
#define SIZE_Bx     (SIZE_C + SIZE_B)  /**< Bx字段位数：B和C字段合并为18位 */
#define SIZE_A      8           /**< A字段位数：支持0-255的寄存器编号 */

#define SIZE_OP     6           /**< 操作码位数：支持0-63的操作码 */

// 各字段在32位指令中的位置定义 - 用于位移操作
#define POS_OP      0           /**< 操作码起始位置：位0-5 */
#define POS_A       (POS_OP + SIZE_OP)    /**< A字段起始位置：位6-13 */
#define POS_C       (POS_A + SIZE_A)      /**< C字段起始位置：位14-22 */
#define POS_B       (POS_C + SIZE_C)      /**< B字段起始位置：位23-31 */
#define POS_Bx      POS_C       /**< Bx字段起始位置：与C字段相同，位14-31 */

/** @} */
/**
 * @defgroup ARGUMENT_LIMITS 参数范围限制定义
 * @brief 定义各个指令参数的最大取值范围
 * 
 * 这些常量定义了指令参数的有效取值范围，编译器在生成字节码时
 * 必须确保所有参数值都在这些范围内。超出范围的值将导致未定义行为。
 * 
 * 有符号参数编码：
 * sBx使用excess-K编码，其中K=MAXARG_sBx。这意味着：
 * - 实际值 = 编码值 - MAXARG_sBx
 * - 编码范围：0 到 2*MAXARG_sBx
 * - 实际范围：-MAXARG_sBx 到 +MAXARG_sBx
 * 
 * 条件编译说明：
 * 根据目标平台的整数位数选择不同的参数范围，确保在所有平台上
 * 都能正确处理参数值而不发生整数溢出。
 * 
 * @{
 */

#if SIZE_Bx < LUAI_BITSINT-1
// 标准情况：Bx字段小于平台整数位数，使用位移计算最大值
#define MAXARG_Bx   ((1<<SIZE_Bx)-1)     /**< Bx参数最大值：2^18-1 = 262143 */
#define MAXARG_sBx  (MAXARG_Bx>>1)       /**< sBx参数最大正值：131071 */
#else
// 特殊情况：Bx字段接近或等于平台整数位数，使用平台最大值
#define MAXARG_Bx   MAX_INT              /**< Bx参数最大值：使用平台最大整数 */
#define MAXARG_sBx  MAX_INT              /**< sBx参数最大值：使用平台最大整数 */
#endif

// 其他参数的最大值定义 - 使用位移计算
#define MAXARG_A    ((1<<SIZE_A)-1)      /**< A参数最大值：255 */
#define MAXARG_B    ((1<<SIZE_B)-1)      /**< B参数最大值：511 */
#define MAXARG_C    ((1<<SIZE_C)-1)      /**< C参数最大值：511 */

/** @} */

/**
 * @defgroup BIT_MANIPULATION 位操作辅助宏
 * @brief 用于指令编码/解码的底层位操作工具宏
 * 
 * 这些宏提供了高效的位掩码生成功能，是所有指令操作宏的基础。
 * 采用位运算而非算术运算，确保在所有平台上都有最佳性能。
 * 
 * 设计思想：
 * - MASK1创建指定位置的1位掩码，用于提取特定位域
 * - MASK0创建指定位置的0位掩码，用于清除特定位域
 * - 使用补码运算避免循环和条件判断，提升性能
 * 
 * 性能特征：
 * - 纯位运算操作，在现代CPU上执行时间为1-2个时钟周期
 * - 编译时常量折叠优化，运行时无计算开销
 * - 避免分支预测失败，提升指令流水线效率
 * 
 * @{
 */

/**
 * @brief 创建n位宽度的1位掩码，起始位置为p
 * @param n 掩码宽度（位数）
 * @param p 掩码起始位置
 * @return 返回在位置p开始的n个连续1位的掩码
 * 
 * 实现原理：
 * 1. (~(Instruction)0) 创建全1的掩码
 * 2. <<n 左移n位，低n位变为0
 * 3. ~ 取反，得到低n位为1的掩码  
 * 4. <<p 左移p位，将掩码移动到目标位置
 * 
 * 示例：MASK1(3,2) = 0b00011100 (位2-4为1)
 */
#define MASK1(n,p)  ((~((~(Instruction)0)<<n))<<p)

/**
 * @brief 创建n位宽度的0位掩码，起始位置为p
 * @param n 掩码宽度（位数）  
 * @param p 掩码起始位置
 * @return 返回在位置p开始的n个连续0位的掩码
 * 
 * 实现原理：
 * 直接对MASK1的结果取反，将1位变为0位，0位变为1位。
 * 
 * 示例：MASK0(3,2) = 0b11100011 (位2-4为0)
 */
#define MASK0(n,p)  (~MASK1(n,p))

/** @} */

/**
 * @defgroup INSTRUCTION_DECODE 指令解码宏定义
 * @brief 用于从32位指令中提取操作码和参数的高效宏
 * 
 * 这些宏提供了指令解码的核心功能，将32位指令拆分为操作码和各个参数。
 * 所有宏都经过优化，使用纯位运算实现，确保虚拟机的解释执行性能。
 * 
 * 解码过程：
 * 1. 右移到目标位域的起始位置
 * 2. 使用位掩码提取指定宽度的位
 * 3. 类型转换为适当的数据类型
 * 
 * 性能优化：
 * - 避免除法和模运算，仅使用位移和掩码
 * - 编译器内联优化，零函数调用开销
 * - 常量位移和掩码，CPU指令缓存友好
 * 
 * @{
 */

/**
 * @brief 从指令中提取操作码
 * @param i 32位指令字
 * @return OpCode枚举值，表示指令类型
 * 
 * 提取指令的低6位作为操作码。操作码决定了指令的具体功能
 * 和参数解释方式，是指令解析的第一步。
 * 
 * 位操作详解：
 * - (i)>>POS_OP: 将操作码移到最低位
 * - & MASK1(SIZE_OP,0): 提取低6位，清除高位
 * - cast(OpCode, ...): 转换为操作码枚举类型
 */
#define GET_OPCODE(i)   (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))

/**
 * @brief 设置指令的操作码
 * @param i 目标指令字（将被修改）
 * @param o 新的操作码值
 * @return 修改后的指令字
 * 
 * 将新的操作码值写入指令的低6位，保持其他位不变。
 * 这在指令优化和代码生成阶段经常使用。
 * 
 * 设置过程：
 * 1. 清除原有操作码位：& MASK0(SIZE_OP,POS_OP)
 * 2. 新操作码左移到正确位置：<<POS_OP
 * 3. 应用位掩码确保不超出范围：& MASK1(SIZE_OP,POS_OP)
 * 4. 按位或合并：| 
 */
#define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
                        ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

/** @} */

/**
 * @defgroup ARGUMENT_DECODE A参数编码/解码宏
 * @brief A参数（目标寄存器）的提取和设置操作
 * 
 * A参数通常表示指令的目标寄存器，即运算结果的存储位置。
 * A参数占用8位，支持0-255的寄存器编号，足以满足大多数函数的需求。
 * 
 * @{
 */

/**
 * @brief 从指令中提取A参数（目标寄存器编号）
 * @param i 32位指令字
 * @return int类型的寄存器编号（0-255）
 * 
 * A参数位于指令的第6-13位，通常表示指令结果的存储位置。
 * 在大多数指令中，A参数是写操作的目标寄存器。
 */
#define GETARG_A(i)    (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))

/**
 * @brief 设置指令的A参数
 * @param i 目标指令字（将被修改）
 * @param u 新的A参数值（0-255）
 * @return 修改后的指令字
 * 
 * 设置指令的目标寄存器编号。编译器在生成指令时使用此宏
 * 来指定运算结果的存储位置。
 */
#define SETARG_A(i,u)   ((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
                        ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))

/** @} */

/**
 * @defgroup BC_ARGUMENTS B/C参数编码/解码宏
 * @brief B和C参数的提取和设置操作，支持RK混合寻址
 * 
 * B和C参数各占9位，支持0-511的值范围。这些参数支持RK寻址模式：
 * - 0-255：寄存器编号（直接寻址）
 * - 256-511：常量索引（间接寻址，实际索引为值-256）
 * 
 * RK寻址的优势：
 * - 节省指令数量：一条指令可以同时处理寄存器和常量操作数
 * - 提升性能：减少指令获取和解码的开销
 * - 简化编译器：统一的操作数编码方式
 * 
 * @{
 */

/**
 * @brief 从指令中提取B参数（第一个源操作数）
 * @param i 32位指令字
 * @return int类型的操作数值（0-511）
 * 
 * B参数位于指令的第23-31位，通常作为指令的第一个源操作数。
 * 需要配合ISK()宏判断是寄存器还是常量索引。
 */
#define GETARG_B(i)    (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))

/**
 * @brief 设置指令的B参数
 * @param i 目标指令字（将被修改）
 * @param b 新的B参数值（0-511）
 * @return 修改后的指令字
 */
#define SETARG_B(i,b)   ((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
                        ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))

/**
 * @brief 从指令中提取C参数（第二个源操作数）
 * @param i 32位指令字
 * @return int类型的操作数值（0-511）
 * 
 * C参数位于指令的第14-22位，通常作为指令的第二个源操作数。
 * 同样支持RK寻址模式，需要配合ISK()宏使用。
 */
#define GETARG_C(i)    (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))

/**
 * @brief 设置指令的C参数
 * @param i 目标指令字（将被修改）
 * @param b 新的C参数值（0-511）
 * @return 修改后的指令字
 */
#define SETARG_C(i,b)   ((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
                        ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))

/** @} */

/**
 * @defgroup BX_ARGUMENTS Bx/sBx参数编码/解码宏
 * @brief 大参数（18位）的编码/解码，支持无符号和有符号两种模式
 * 
 * Bx和sBx参数占用指令的第14-31位（18位），提供更大的参数范围：
 * - Bx：无符号18位，范围0-262143，用于大索引值（如常量表索引）
 * - sBx：有符号18位，使用excess-K编码，用于相对跳转偏移
 * 
 * excess-K编码说明：
 * - K = MAXARG_sBx = 131071
 * - 编码值范围：0 到 262143
 * - 实际值范围：-131071 到 +131071
 * - 转换公式：实际值 = 编码值 - K
 * 
 * 使用场景：
 * - Bx：常量加载(LOADK)、全局变量访问(GETGLOBAL/SETGLOBAL)
 * - sBx：跳转指令(JMP)、循环控制(FORLOOP/FORPREP)
 * 
 * @{
 */

/**
 * @brief 从指令中提取Bx参数（无符号大参数）
 * @param i 32位指令字
 * @return int类型的无符号值（0-262143）
 * 
 * Bx参数由B和C字段合并而成，提供18位的无符号参数。
 * 主要用于需要大索引值的指令，如常量表访问。
 */
#define GETARG_Bx(i)   (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))

/**
 * @brief 设置指令的Bx参数
 * @param i 目标指令字（将被修改）
 * @param b 新的Bx参数值（0-262143）
 * @return 修改后的指令字
 * 
 * 设置18位的无符号大参数。注意这会同时覆盖B和C字段的位置。
 */
#define SETARG_Bx(i,b)  ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
                        ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))

/**
 * @brief 从指令中提取sBx参数（有符号大参数）
 * @param i 32位指令字
 * @return int类型的有符号值（-131071到+131071）
 * 
 * sBx参数使用excess-K编码，将无符号的Bx值转换为有符号值。
 * 主要用于需要正负偏移的跳转指令。
 * 
 * 解码过程：
 * 1. 提取Bx值（0-262143）
 * 2. 减去MAXARG_sBx(131071)得到有符号值
 * 3. 结果范围：-131071 到 +131071
 */
#define GETARG_sBx(i)  (GETARG_Bx(i)-MAXARG_sBx)

/**
 * @brief 设置指令的sBx参数
 * @param i 目标指令字（将被修改）
 * @param b 新的sBx参数值（-131071到+131071）
 * @return 修改后的指令字
 * 
 * 使用excess-K编码设置有符号大参数：
 * 1. 将有符号值加上MAXARG_sBx转换为无符号值
 * 2. 调用SETARG_Bx设置到指令中
 */
#define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))

/** @} */


/**
 * @defgroup INSTRUCTION_CREATE 指令创建宏
 * @brief 用于创建新指令的便利宏，支持ABC和ABx两种格式
 * 
 * 这些宏提供了快速创建指令的方法，将操作码和参数组合成32位指令字。
 * 在编译器的代码生成阶段大量使用，确保生成的指令格式正确。
 * 
 * 创建过程：
 * 1. 将各个参数左移到正确的位置
 * 2. 使用按位或操作将所有字段合并
 * 3. 返回完整的32位指令字
 * 
 * 性能特征：
 * - 编译时常量折叠：如果参数是常量，编译器会预计算结果
 * - 无分支操作：纯位运算，避免条件跳转
 * - 内联优化：编译器会将宏展开为高效的机器码
 * 
 * @{
 */

/**
 * @brief 创建ABC格式的指令
 * @param o 操作码（0-63）
 * @param a A参数：目标寄存器（0-255）
 * @param b B参数：第一个源操作数（0-511）
 * @param c C参数：第二个源操作数（0-511）
 * @return 完整的32位指令字
 * 
 * ABC格式是最常用的指令格式，适用于大多数三操作数指令：
 * - 算术运算：ADD, SUB, MUL, DIV, MOD, POW
 * - 比较运算：EQ, LT, LE
 * - 逻辑运算：AND, OR, NOT
 * - 表操作：GETTABLE, SETTABLE
 * 
 * 位布局：[B:9][C:9][A:8][OP:6]
 * 
 * 使用示例：
 * @code
 * // 创建加法指令：R(0) = R(1) + R(2)
 * Instruction inst = CREATE_ABC(OP_ADD, 0, 1, 2);
 * 
 * // 创建常量加法指令：R(0) = R(1) + K(5)
 * Instruction inst = CREATE_ABC(OP_ADD, 0, 1, RKASK(5));
 * @endcode
 */
#define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) \
                            | (cast(Instruction, a)<<POS_A) \
                            | (cast(Instruction, b)<<POS_B) \
                            | (cast(Instruction, c)<<POS_C))

/**
 * @brief 创建ABx格式的指令
 * @param o 操作码（0-63）
 * @param a A参数：目标寄存器（0-255）
 * @param bc Bx参数：大索引值（0-262143）
 * @return 完整的32位指令字
 * 
 * ABx格式用于需要大索引值的指令，B和C字段合并为18位的Bx字段：
 * - 常量加载：LOADK（从常量表加载值到寄存器）
 * - 全局变量：GETGLOBAL, SETGLOBAL（访问全局变量表）
 * - 函数调用：CLOSURE（创建闭包，指定函数原型索引）
 * 
 * 位布局：[Bx:18][A:8][OP:6]
 * 
 * 使用示例：
 * @code
 * // 创建常量加载指令：R(0) = K(1000)
 * Instruction inst = CREATE_ABx(OP_LOADK, 0, 1000);
 * 
 * // 创建全局变量读取指令：R(5) = _G[K(200)]
 * Instruction inst = CREATE_ABx(OP_GETGLOBAL, 5, 200);
 * @endcode
 */
#define CREATE_ABx(o,a,bc)  ((cast(Instruction, o)<<POS_OP) \
                            | (cast(Instruction, a)<<POS_A) \
                            | (cast(Instruction, bc)<<POS_Bx))

/** @} */

/**
 * @defgroup RK_ADDRESSING RK混合寻址支持宏
 * @brief 支持寄存器-常量混合寻址的工具宏
 * 
 * RK寻址是Lua虚拟机的一个重要特性，允许指令的操作数既可以是寄存器
 * 也可以是常量，通过最高位标志进行区分。这种设计显著减少了指令数量。
 * 
 * 编码规则：
 * - 寄存器操作数：最高位为0，值为寄存器编号（0-255）
 * - 常量操作数：最高位为1，低位为常量索引（0-255）
 * 
 * 优势：
 * - 指令融合：一条指令可以处理reg+reg、reg+const、const+reg三种组合
 * - 代码密度：减少指令数量，提升缓存效率
 * - 编译简化：编译器无需生成多种指令变体
 * 
 * 实现细节：
 * - BITRK = 256 (0x100)：常量标志位
 * - 寄存器范围：0-255
 * - 常量范围：256-511（实际索引0-255）
 * 
 * @{
 */

/**
 * @brief RK操作数的常量标志位
 * 
 * 该位设置在B字段的最高位（第8位），用于区分寄存器和常量操作数。
 * 值为256（二进制：100000000），对应SIZE_B-1位置的单独1位。
 */
#define BITRK       (1 << (SIZE_B - 1))

/**
 * @brief 判断操作数是否为常量
 * @param x RK操作数值（0-511）
 * @return 非零表示常量，零表示寄存器
 * 
 * 通过检查最高位来判断操作数类型：
 * - 返回0：x是寄存器编号（0-255）
 * - 返回非0：x是常量索引（256-511）
 * 
 * 使用示例：
 * @code
 * int operand = GETARG_B(instruction);
 * if (ISK(operand)) {
 *     // 操作数是常量，需要从常量表获取值
 *     int const_index = INDEXK(operand);
 *     TValue *value = &function->k[const_index];
 * } else {
 *     // 操作数是寄存器，直接访问寄存器
 *     TValue *value = &registers[operand];
 * }
 * @endcode
 */
#define ISK(x)      ((x) & BITRK)

/**
 * @brief 从RK操作数中提取常量索引
 * @param r RK操作数值（通常是256-511）
 * @return 常量表中的实际索引（0-255）
 * 
 * 清除常量标志位，得到在常量表中的实际索引。
 * 调用前应该先用ISK()确认操作数确实是常量。
 * 
 * 位操作：r & ~BITRK 清除最高位，保留低8位作为索引
 * 
 * 转换关系：
 * - 输入值256-511 → 输出索引0-255
 * - 例如：INDEXK(260) = 4
 */
#define INDEXK(r)   ((int)(r) & ~BITRK)

/**
 * @brief RK操作数的最大寄存器索引
 * 
 * 定义了可以直接作为寄存器编号使用的最大值（255）。
 * 大于此值的操作数都被解释为常量索引。
 */
#define MAXINDEXRK  (BITRK - 1)

/**
 * @brief 将常量索引编码为RK操作数
 * @param x 常量表索引（0-255）
 * @return RK编码的常量操作数（256-511）
 * 
 * 为常量索引添加常量标志位，使其可以作为RK操作数使用。
 * 编译器在生成使用常量的指令时调用此宏。
 * 
 * 编码过程：x | BITRK 设置最高位标志
 * 
 * 转换关系：
 * - 输入索引0-255 → 输出操作数256-511
 * - 例如：RKASK(4) = 260
 * 
 * 使用示例：
 * @code
 * // 生成常量加法指令：R(0) = R(1) + K(5)
 * int const_index = 5;
 * Instruction inst = CREATE_ABC(OP_ADD, 0, 1, RKASK(const_index));
 * @endcode
 */
#define RKASK(x)    ((x) | BITRK)

/** @} */

/**
 * @defgroup SPECIAL_REGISTERS 特殊寄存器常量定义
 * @brief 定义具有特殊含义的寄存器编号
 * 
 * 某些寄存器编号具有特殊含义，用于表示无效状态或特殊操作模式。
 * 这些常量提高了代码的可读性和维护性。
 * 
 * @{
 */

/**
 * @brief 无效寄存器标识符
 * 
 * 值为255（MAXARG_A），表示无效的寄存器编号。在以下情况使用：
 * - 指令不需要目标寄存器时（如跳转指令）
 * - 表示可变参数数量未知（如CALL指令的参数）
 * - 作为数组或链表的结束标记
 * - 初始化状态的默认值
 * 
 * 设计原理：
 * 选择最大的A参数值作为无效标识，这样正常的寄存器编号（0-254）
 * 都小于此值，可以用简单的比较操作进行有效性检查。
 * 
 * 使用示例：
 * @code
 * // 检查寄存器是否有效
 * if (reg_num != NO_REG) {
 *     // 处理有效寄存器
 *     process_register(reg_num);
 * }
 * 
 * // 初始化寄存器数组
 * for (int i = 0; i < MAX_REGS; i++) {
 *     reg_status[i] = NO_REG;  // 标记为未使用
 * }
 * @endcode
 */
#define NO_REG      MAXARG_A

/** @} */

/**
 * @brief Lua虚拟机操作码枚举：完整的指令集定义
 * 
 * 详细说明：
 * 本枚举定义了Lua 5.1虚拟机的完整指令集，共38个操作码。每个操作码
 * 对应虚拟机可以执行的一种基本操作。指令集设计遵循RISC原则，追求
 * 简洁性和正交性，避免功能重叠的复杂指令。
 * 
 * 指令分类：
 * - 数据移动：MOVE, LOADK, LOADBOOL, LOADNIL
 * - 变量访问：GETUPVAL, GETGLOBAL, GETTABLE, SETUPVAL, SETGLOBAL, SETTABLE
 * - 表操作：NEWTABLE, SELF
 * - 算术运算：ADD, SUB, MUL, DIV, MOD, POW, UNM
 * - 逻辑运算：NOT, LEN
 * - 字符串操作：CONCAT
 * - 控制流：JMP, EQ, LT, LE, TEST, TESTSET
 * - 函数调用：CALL, TAILCALL, RETURN
 * - 循环控制：FORLOOP, FORPREP, TFORLOOP
 * - 表初始化：SETLIST
 * - 栈管理：CLOSE
 * - 闭包创建：CLOSURE
 * - 可变参数：VARARG
 * 
 * 设计特点：
 * - 基于寄存器的架构：减少栈操作，提升性能
 * - 支持RK寻址：操作数可以是寄存器或常量
 * - 内置类型检查：动态类型语言的特化指令
 * - 闭包支持：一级函数对象的高效实现
 * - 表优化：针对Lua核心数据结构的专用指令
 * 
 * 指令格式约定：
 * - R(x)：寄存器x中的值
 * - K(x)：常量表中索引x的值  
 * - RK(x)：如果ISK(x)则K(INDEXK(x))，否则R(x)
 * - Gbl：全局变量表
 * - UpValue：上值数组（闭包变量）
 * 
 * 性能考虑：
 * - 常用指令编码在较小数值，提升指令缓存效率
 * - 指令功能正交化，减少解释器的分支数量
 * - 内置优化语义，如尾调用、数值循环等
 * 
 * @since Lua 5.1
 * @see lvm.c, ldo.c（具体执行实现）
 */
typedef enum {
    /*==================================================================
     * 数据移动指令组
     * 用于在寄存器、常量表和栈之间移动数据
     *==================================================================*/
    
    /**
     * @brief 寄存器复制指令
     * 
     * 格式：MOVE A B
     * 操作：R(A) := R(B)
     * 
     * 将寄存器B的值复制到寄存器A。这是最基本的数据移动指令，
     * 在局部变量赋值、函数参数传递等场景中频繁使用。
     * 
     * 性能特点：
     * - O(1)时间复杂度，纯指针或值复制
     * - 针对不同数据类型优化的复制实现
     * - 支持引用计数和垃圾回收的正确处理
     * 
     * 使用场景：
     * - 局部变量赋值：local a = b
     * - 函数参数准备
     * - 表达式求值的中间结果传递
     * - 编译器优化中的寄存器重命名
     */
    OP_MOVE,
    
    /**
     * @brief 常量加载指令
     * 
     * 格式：LOADK A Bx
     * 操作：R(A) := K(Bx)
     * 
     * 从常量表中加载常量值到寄存器A。Bx是18位的常量表索引，
     * 支持访问大型常量表（最多262144个常量）。
     * 
     * 常量类型支持：
     * - 数值常量：整数和浮点数
     * - 字符串常量：预编译时创建的字符串对象
     * - 布尔常量：true和false
     * - nil常量：表示空值
     * 
     * 优化特点：
     * - 常量表在函数编译时构建，运行时只读
     * - 字符串常量使用内部字符串池，避免重复创建
     * - 数值常量直接嵌入，无需额外内存分配
     * 
     * 编译器使用：
     * - 字面量表达式：local x = 42, local s = "hello"
     * - 预计算的常量表达式结果
     * - 大整数和精确小数的表示
     */
    OP_LOADK,
    
    /**
     * @brief 布尔值加载指令
     * 
     * 格式：LOADBOOL A B C
     * 操作：R(A) := (Bool)B; if (C) pc++
     * 
     * 加载布尔值到寄存器A，并可选择性地跳过下一条指令。
     * B参数：0表示false，非0表示true
     * C参数：非0时跳过下一条指令
     * 
     * 设计目的：
     * 这个指令结合了值加载和条件跳转，专门为布尔表达式优化。
     * 可以避免生成额外的跳转指令，提升条件表达式的执行效率。
     * 
     * 典型用法：
     * - 短路求值：and/or表达式的优化实现
     * - 条件表达式：x = condition and true_val or false_val
     * - 比较运算的结果设置
     * 
     * 跳转语义：
     * 当C非0时，程序计数器自动加1，跳过下一条指令。
     * 这通常用于跳过else分支的代码。
     */
    OP_LOADBOOL,
    
    /**
     * @brief nil值范围加载指令
     * 
     * 格式：LOADNIL A B
     * 操作：R(A) := ... := R(B) := nil
     * 
     * 将寄存器A到B（包含）范围内的所有寄存器设置为nil。
     * 这是一个批量操作指令，提升了nil初始化的效率。
     * 
     * 应用场景：
     * - 局部变量初始化：local a, b, c（未赋值的变量为nil）
     * - 数组元素清理：清除表中的连续元素
     * - 函数栈帧初始化：为新函数清理寄存器
     * 
     * 性能优势：
     * - 批量操作减少指令数量
     * - 内存访问局部性良好
     * - 避免重复的类型设置操作
     * 
     * 实现细节：
     * 虚拟机使用高效的内存设置函数（如memset）来实现
     * 批量nil赋值，比逐个赋值快得多。
     */
    OP_LOADNIL,
    
    /**
     * @brief 上值读取指令
     * 
     * 格式：GETUPVAL A B
     * 操作：R(A) := UpValue[B]
     * 
     * 从上值数组中读取闭包变量到寄存器A。上值是闭包捕获的
     * 外层函数局部变量，实现了Lua的词法作用域。
     * 
     * 上值机制：
     * - 开放上值：引用仍在栈上的局部变量
     * - 封闭上值：已复制到堆上的变量副本
     * - 上值链：多层嵌套闭包的变量共享
     * 
     * 性能考虑：
     * - 上值访问比局部变量慢，但比全局变量快
     * - 上值表大小通常很小，缓存友好
     * - 支持上值的直接修改和引用传递
     * 
     * 编译器生成：
     * - 内嵌函数访问外层变量：function() return x end
     * - 闭包参数传递
     * - 模块内私有变量的访问
     */
    OP_GETUPVAL,

    /*==================================================================
     * 变量访问指令组
     * 用于访问全局变量和表元素
     *==================================================================*/
    
    /**
     * @brief 全局变量读取指令
     * 
     * 格式：GETGLOBAL A Bx
     * 操作：R(A) := Gbl[K(Bx)]
     * 
     * 从全局变量表中读取变量值到寄存器A。K(Bx)是变量名（字符串常量），
     * 全局变量表通常是环境表（_ENV或_G）。
     * 
     * 实现机制：
     * - 全局变量实际存储在一个特殊的表中
     * - 变量名作为键，变量值作为值
     * - 支持元表的__index元方法
     * 
     * 性能特点：
     * - 比局部变量访问慢，涉及哈希表查找
     * - 字符串键的哈希计算开销
     * - 可能触发元方法调用
     * 
     * 使用场景：
     * - 访问标准库函数：print, type, pairs等
     * - 模块间的变量共享
     * - 动态变量名访问
     */
    OP_GETGLOBAL,
    
    /**
     * @brief 表元素读取指令
     * 
     * 格式：GETTABLE A B C
     * 操作：R(A) := R(B)[RK(C)]
     * 
     * 从表R(B)中读取键RK(C)对应的值到寄存器A。这是Lua中
     * 表访问操作的核心指令，支持数组索引和哈希访问。
     * 
     * 表访问语义：
     * - 数组部分：整数键的高效连续访问
     * - 哈希部分：任意类型键的哈希表访问
     * - 元表支持：__index元方法的自动调用
     * 
     * RK操作数优势：
     * - C可以是寄存器：动态键访问
     * - C可以是常量：静态键访问，如obj.field
     * - 减少常量加载指令的需要
     * 
     * 性能优化：
     * - 整数键的数组访问优化路径
     * - 字符串键的快速哈希查找
     * - 元表链的递归查找缓存
     * 
     * 典型用法：
     * - 数组访问：arr[i]
     * - 对象字段：obj.field, obj["field"]
     * - 字典查找：dict[key]
     */
    OP_GETTABLE,

    /*==================================================================
     * 变量赋值指令组
     * 用于修改全局变量和表元素
     *==================================================================*/
    
    /**
     * @brief 全局变量赋值指令
     * 
     * 格式：SETGLOBAL A Bx
     * 操作：Gbl[K(Bx)] := R(A)
     * 
     * 将寄存器A的值赋值给全局变量K(Bx)。如果变量不存在，
     * 则在全局表中创建新的键值对。
     * 
     * 赋值语义：
     * - 新变量创建：自动在全局表中添加条目
     * - 变量修改：更新现有全局变量的值
     * - 元表支持：__newindex元方法的触发
     * 
     * 权限控制：
     * - 某些环境可能限制全局变量的创建
     * - 只读全局变量的写保护
     * - 严格模式下的未声明变量检查
     * 
     * 性能影响：
     * - 哈希表的插入或更新操作
     * - 可能触发表的扩展和重哈希
     * - 元方法调用的额外开销
     */
    OP_SETGLOBAL,
    
    /**
     * @brief 上值赋值指令
     * 
     * 格式：SETUPVAL A B
     * 操作：UpValue[B] := R(A)
     * 
     * 将寄存器A的值赋值给上值B。这实现了闭包对外层
     * 局部变量的修改操作。
     * 
     * 上值修改语义：
     * - 开放上值：直接修改栈上的原始变量
     * - 封闭上值：修改堆上的变量副本
     * - 共享语义：多个闭包共享同一上值的修改
     * 
     * 内存管理：
     * - 上值的引用计数维护
     * - 垃圾回收时的正确性保证
     * - 写屏障的触发（如果需要）
     * 
     * 并发考虑：
     * - 上值修改的原子性（在并发环境中）
     * - 多个协程间的上值共享安全
     */
    OP_SETUPVAL,
    
    /**
     * @brief 表元素赋值指令
     * 
     * 格式：SETTABLE A B C
     * 操作：R(A)[RK(B)] := RK(C)
     * 
     * 将值RK(C)赋值给表R(A)的键RK(B)。这是Lua表修改
     * 操作的核心指令，支持各种类型的键值赋值。
     * 
     * 赋值类型：
     * - 数组赋值：t[1] = value（整数键）
     * - 哈希赋值：t["key"] = value（字符串键）
     * - 动态赋值：t[expr] = value（表达式键）
     * 
     * 表结构调整：
     * - 数组部分的自动扩展
     * - 哈希部分的重哈希操作
     * - 空值赋值时的空间回收
     * 
     * 元表交互：
     * - __newindex元方法的自动调用
     * - 只读表的写保护实现
     * - 代理表的透明转发
     * 
     * 性能优化：
     * - 整数键的快速数组路径
     * - 字符串键的高效哈希更新
     * - 批量赋值时的表扩展预分配
     */
    OP_SETTABLE,

    /*==================================================================
     * 表创建和操作指令组
     *==================================================================*/
    
    /**
     * @brief 新表创建指令
     * 
     * 格式：NEWTABLE A B C
     * 操作：R(A) := {} (size = B,C)
     * 
     * 创建一个新的空表并存储到寄存器A。B和C参数指定表的初始大小：
     * - B：数组部分的初始大小
     * - C：哈希部分的初始大小
     * 
     * 大小编码：
     * B和C使用特殊的编码方式来表示大尺寸：
     * - 0-127：直接表示大小
     * - 128+：表示为2^(x-127)的形式
     * 
     * 预分配优势：
     * - 避免表的频繁扩展操作
     * - 减少内存分配和复制开销
     * - 提升后续元素插入的性能
     * 
     * 编译器优化：
     * 编译器分析表构造器的内容，预估合适的初始大小：
     * - 数组构造器：{1, 2, 3, 4}
     * - 哈希构造器：{a=1, b=2}
     * - 混合构造器：{1, 2, a=3, b=4}
     */
    OP_NEWTABLE,

    /**
     * @brief 方法调用准备指令（self操作）
     * 
     * 格式：SELF A B C
     * 操作：R(A+1) := R(B); R(A) := R(B)[RK(C)]
     * 
     * 为方法调用准备参数，实现obj:method()语法糖。
     * 这个指令结合了表查找和self参数设置两个操作。
     * 
     * 操作步骤：
     * 1. 保存对象引用：R(A+1) := R(B)（作为self参数）
     * 2. 获取方法函数：R(A) := R(B)[RK(C)]（方法函数）
     * 
     * 语法糖转换：
     * obj:method(args) 等价于 obj.method(obj, args)
     * 
     * 性能优化：
     * 将两个操作合并为一条指令，减少指令数量和寄存器使用：
     * - 避免额外的MOVE指令
     * - 减少寄存器压力
     * - 提升方法调用的整体性能
     * 
     * 使用场景：
     * - 对象方法调用：str:find(pattern)
     * - 表方法链：table:insert():sort()
     * - 用户定义类的方法调用
     */
    OP_SELF,

    /*==================================================================
     * 算术运算指令组
     * 支持基本的数学运算，包括二元和一元运算
     *==================================================================*/
    
    /**
     * @brief 加法运算指令
     * 
     * 格式：ADD A B C
     * 操作：R(A) := RK(B) + RK(C)
     * 
     * 执行加法运算，支持数值加法和字符串连接。
     * 操作数可以是寄存器值或常量，提供灵活的运算模式。
     * 
     * 类型支持：
     * - 整数加法：高效的整数运算路径
     * - 浮点加法：IEEE 754标准的浮点运算
     * - 混合运算：整数和浮点数的自动转换
     * 
     * 元方法支持：
     * 当操作数不是数值时，尝试调用__add元方法：
     * - 用户定义类型的加法语义
     * - 向量、矩阵等数学对象的运算
     * - 字符串类型的特殊处理
     * 
     * 性能优化：
     * - 数值类型的快速路径识别
     * - 整数溢出的检测和处理
     * - 浮点异常的标准处理
     */
    OP_ADD,
    
    /**
     * @brief 减法运算指令
     * 
     * 格式：SUB A B C
     * 操作：R(A) := RK(B) - RK(C)
     * 
     * 执行减法运算，从第一个操作数中减去第二个操作数。
     * 支持各种数值类型和用户定义的减法语义。
     * 
     * 运算特点：
     * - 非交换运算：操作数顺序影响结果
     * - 类型转换：自动处理整数和浮点数混合运算
     * - 下溢检测：处理数值下溢的边界情况
     * 
     * 元方法调用：
     * 对于非数值类型，调用__sub元方法实现自定义减法。
     */
    OP_SUB,
    
    /**
     * @brief 乘法运算指令
     * 
     * 格式：MUL A B C
     * 操作：R(A) := RK(B) * RK(C)
     * 
     * 执行乘法运算，支持高效的数值乘法和用户定义的乘法语义。
     * 
     * 优化实现：
     * - 整数乘法：使用CPU的快速整数乘法指令
     * - 浮点乘法：遵循IEEE 754标准
     * - 溢出处理：整数溢出时自动转换为浮点数
     * 
     * 特殊值处理：
     * - 零乘法：快速零值检测
     * - 无穷大：IEEE浮点无穷大的传播
     * - NaN处理：非数值的正确传播
     */
    OP_MUL,
    
    /**
     * @brief 除法运算指令
     * 
     * 格式：DIV A B C
     * 操作：R(A) := RK(B) / RK(C)
     * 
     * 执行除法运算，结果总是浮点数（遵循Lua 5.1语义）。
     * 
     * 除法语义：
     * - 真除法：整数除法也产生浮点结果
     * - 零除检测：除零时产生无穷大或NaN
     * - 精度保持：使用双精度浮点运算
     * 
     * 特殊情况：
     * - 0/0 → NaN
     * - x/0 → ±Infinity（根据x的符号）
     * - Infinity/Infinity → NaN
     */
    OP_DIV,
    
    /**
     * @brief 模运算指令（取余）
     * 
     * 格式：MOD A B C
     * 操作：R(A) := RK(B) % RK(C)
     * 
     * 执行模运算，计算第一个操作数除以第二个操作数的余数。
     * Lua使用向下取整的模运算定义。
     * 
     * 模运算定义：
     * a % b = a - floor(a/b) * b
     * 
     * 符号规则：
     * - 结果的符号与除数相同
     * - 支持负数的模运算
     * - 浮点模运算的精确实现
     * 
     * 应用场景：
     * - 循环索引：index % array_size
     * - 哈希函数：hash % table_size
     * - 周期性计算：time % period
     */
    OP_MOD,
    
    /**
     * @brief 幂运算指令
     * 
     * 格式：POW A B C
     * 操作：R(A) := RK(B) ^ RK(C)
     * 
     * 执行幂运算，计算底数的指数次幂。使用数学库的pow函数实现。
     * 
     * 运算特点：
     * - 高精度：使用双精度浮点运算
     * - 右结合：a^b^c 等价于 a^(b^c)
     * - 特殊值：正确处理0^0、负数开方等情况
     * 
     * 性能考虑：
     * - 整数指数的优化算法
     * - 负指数的倒数处理
     * - 复数结果的错误处理（Lua不支持复数）
     */
    OP_POW,
    
    /**
     * @brief 一元负号运算指令
     * 
     * 格式：UNM A B
     * 操作：R(A) := -R(B)
     * 
     * 执行一元负号运算，对操作数取负值。
     * 
     * 类型处理：
     * - 整数取负：检测溢出（-MIN_INT的情况）
     * - 浮点取负：简单的符号位翻转
     * - 元方法：__unm元方法的调用
     * 
     * 特殊值：
     * - -0：保持负零的IEEE语义
     * - -Infinity：产生负无穷大
     * - -NaN：保持NaN值
     */
    OP_UNM,
    
    /**
     * @brief 逻辑非运算指令
     * 
     * 格式：NOT A B
     * 操作：R(A) := not R(B)
     * 
     * 执行逻辑非运算，根据Lua的真值语义进行求值。
     * 
     * Lua真值规则：
     * - false和nil为假
     * - 所有其他值（包括0和空字符串）为真
     * 
     * 结果类型：
     * - 总是返回布尔值（true或false）
     * - 不涉及元方法调用
     * - 高效的类型检查实现
     */
    OP_NOT,
    
    /**
     * @brief 长度运算指令
     * 
     * 格式：LEN A B
     * 操作：R(A) := length of R(B)
     * 
     * 计算对象的长度，支持字符串和表的长度运算。
     * 
     * 长度定义：
     * - 字符串：字节数（不是字符数）
     * - 表：数组部分的最大有效索引
     * - 其他类型：调用__len元方法
     * 
     * 表长度语义：
     * 表的长度是最大的正整数索引n，使得t[n]不为nil且t[n+1]为nil。
     * 如果表有"洞"（nil值），长度可能不唯一。
     * 
     * 性能优化：
     * - 字符串长度缓存：避免重复计算
     * - 表长度缓存：在某些情况下缓存表长度
     * - 元方法调用的开销最小化
     */
    OP_LEN,

    /*==================================================================
     * 字符串操作指令组
     *==================================================================*/
    
    /**
     * @brief 字符串连接指令
     * 
     * 格式：CONCAT A B C
     * 操作：R(A) := R(B).. ... ..R(C)
     * 
     * 将寄存器B到C范围内的所有值连接成一个字符串。
     * 这是一个可变参数的连接操作，支持高效的多字符串连接。
     * 
     * 连接规则：
     * - 字符串：直接连接
     * - 数值：自动转换为字符串后连接
     * - 其他类型：尝试调用tostring()或__tostring元方法
     * 
     * 性能优化：
     * - 预计算总长度：避免多次内存重分配
     * - 单次内存分配：为结果字符串分配足够空间
     * - 字符串内部化：结果字符串加入字符串池
     * 
     * 内存管理：
     * 大量字符串连接可能触发垃圾回收，虚拟机使用
     * 缓冲区技术来减少临时字符串的创建。
     */
    OP_CONCAT,

    /*==================================================================
     * 控制流指令组
     * 包括跳转和条件分支指令
     *==================================================================*/
    
    /**
     * @brief 无条件跳转指令
     * 
     * 格式：JMP sBx
     * 操作：pc += sBx
     * 
     * 无条件跳转到相对偏移sBx指定的位置。sBx是有符号偏移量，
     * 支持向前和向后跳转。
     * 
     * 跳转范围：
     * - 前向跳转：sBx > 0，跳过后面的指令
     * - 后向跳转：sBx < 0，回到前面的指令
     * - 最大范围：±131071条指令
     * 
     * 应用场景：
     * - 循环结构：while、for、repeat循环的跳转
     * - 条件结构：if-else的分支跳转
     * - 函数结尾：跳转到函数返回点
     * - 异常处理：错误处理的跳转
     * 
     * 性能特点：
     * - 零开销：纯程序计数器操作
     * - 分支预测：现代CPU的分支预测优化
     * - 指令缓存：跳转目标的缓存局部性
     */
    OP_JMP,

    /*==================================================================
     * 比较运算指令组
     * 支持相等、小于、小于等于比较，结合条件跳转
     *==================================================================*/
    
    /**
     * @brief 相等比较指令
     * 
     * 格式：EQ A B C
     * 操作：if ((RK(B) == RK(C)) ~= A) then pc++
     * 
     * 比较两个值是否相等，根据比较结果和A的值决定是否跳过下一条指令。
     * 
     * 比较语义：
     * - 值相等：相同类型且值相等
     * - 引用相等：对于表、函数等引用类型
     * - 元方法：__eq元方法的自动调用
     * 
     * 跳转逻辑：
     * - A=0：相等时跳过下一条指令
     * - A=1：不等时跳过下一条指令
     * 
     * 类型比较规则：
     * - 不同类型：总是不相等（除了数值）
     * - 数值类型：整数和浮点数可以相等
     * - 字符串：按字节序列比较
     * - 表/函数：按引用比较
     */
    OP_EQ,
    
    /**
     * @brief 小于比较指令
     * 
     * 格式：LT A B C
     * 操作：if ((RK(B) < RK(C)) ~= A) then pc++
     * 
     * 比较第一个操作数是否小于第二个操作数。
     * 
     * 比较规则：
     * - 数值：标准的数值比较
     * - 字符串：字典序比较
     * - 其他类型：__lt元方法调用
     * 
     * 错误处理：
     * 不兼容类型的比较会抛出运行时错误，
     * 除非定义了相应的元方法。
     */
    OP_LT,
    
    /**
     * @brief 小于等于比较指令
     * 
     * 格式：LE A B C
     * 操作：if ((RK(B) <= RK(C)) ~= A) then pc++
     * 
     * 比较第一个操作数是否小于或等于第二个操作数。
     * 
     * 实现策略：
     * 如果没有__le元方法，则使用!(RK(C) < RK(B))来实现，
     * 即通过__lt元方法的逆向调用。
     */
    OP_LE,

    /*==================================================================
     * 逻辑测试指令组
     * 支持复杂的条件表达式和短路求值
     *==================================================================*/
    
    /**
     * @brief 逻辑测试指令
     * 
     * 格式：TEST A C
     * 操作：if not (R(A) <=> C) then pc++
     * 
     * 测试寄存器A的值的真假性，根据C的值决定跳转条件。
     * 
     * 测试逻辑：
     * - C=0：如果R(A)为假则跳过下一条指令
     * - C=1：如果R(A)为真则跳过下一条指令
     * 
     * 应用场景：
     * - 条件语句：if expr then ... end
     * - 短路求值：and/or表达式的优化
     * - 循环条件：while expr do ... end
     */
    OP_TEST,
    
    /**
     * @brief 测试并设置指令
     * 
     * 格式：TESTSET A B C
     * 操作：if (R(B) <=> C) then R(A) := R(B) else pc++
     * 
     * 结合了测试和赋值的复合操作，专门为短路求值优化。
     * 
     * 操作逻辑：
     * 1. 测试R(B)的真假性
     * 2. 如果结果与C匹配，则将R(B)赋值给R(A)
     * 3. 否则跳过下一条指令
     * 
     * 短路求值应用：
     * - and表达式：x and y
     * - or表达式：x or y
     * - 条件赋值：result = condition and true_val or false_val
     */
    OP_TESTSET,

    /*==================================================================
     * 函数调用指令组
     * 支持普通调用、尾调用和返回操作
     *==================================================================*/
    
    /**
     * @brief 函数调用指令
     * 
     * 格式：CALL A B C
     * 操作：R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
     * 
     * 调用函数R(A)，参数为R(A+1)到R(A+B-1)，结果存储到R(A)开始的C-1个寄存器。
     * 
     * 参数编码：
     * - B=0：使用栈顶到R(A+1)的所有值作为参数
     * - B>0：使用B-1个参数
     * - C=0：保留所有返回值到栈顶
     * - C>0：保留C-1个返回值
     * 
     * 调用流程：
     * 1. 设置新的函数栈帧
     * 2. 传递参数到新栈帧
     * 3. 执行函数代码
     * 4. 处理返回值
     * 5. 恢复调用者栈帧
     * 
     * 性能优化：
     * - 尾调用检测：避免栈帧累积
     * - 内联优化：小函数的内联展开
     * - 参数传递优化：寄存器直接传递
     */
    OP_CALL,
    
    /**
     * @brief 尾调用指令
     * 
     * 格式：TAILCALL A B C
     * 操作：return R(A)(R(A+1), ... ,R(A+B-1))
     * 
     * 执行尾调用优化，直接用被调用函数的结果替换当前函数的返回。
     * 
     * 尾调用优化：
     * - 栈帧复用：不创建新的栈帧
     * - 参数移动：将参数移到当前栈帧底部
     * - 直接跳转：跳转到目标函数，不返回到当前函数
     * 
     * 优势：
     * - 常量栈空间：递归调用不会增长栈
     * - 性能提升：减少函数调用开销
     * - 内存节省：避免栈帧累积
     * 
     * 应用场景：
     * - 尾递归：factorial(n-1, acc*n)
     * - 状态机：state_function()
     * - 连续传递风格（CPS）
     */
    OP_TAILCALL,
    
    /**
     * @brief 函数返回指令
     * 
     * 格式：RETURN A B
     * 操作：return R(A), ... ,R(A+B-2)
     * 
     * 从当前函数返回，返回值为R(A)到R(A+B-2)。
     * 
     * 返回值处理：
     * - B=0：返回从R(A)到栈顶的所有值
     * - B=1：无返回值（只返回）
     * - B>1：返回B-1个值
     * 
     * 返回流程：
     * 1. 准备返回值
     * 2. 清理当前栈帧
     * 3. 恢复调用者栈帧
     * 4. 将返回值传递给调用者
     * 5. 继续执行调用者代码
     * 
     * 特殊情况：
     * - 主函数返回：结束整个程序
     * - 协程返回：挂起协程执行
     * - 错误返回：通过错误处理机制返回
     */
    OP_RETURN,

    /*==================================================================
     * 循环控制指令组
     * 支持数值for循环和通用for循环
     *==================================================================*/
    
    /**
     * @brief 数值for循环指令
     * 
     * 格式：FORLOOP A sBx
     * 操作：R(A) += R(A+2); if R(A) <?= R(A+1) then { pc += sBx; R(A+3) = R(A) }
     * 
     * 执行数值for循环的迭代步骤。寄存器布局：
     * - R(A)：当前计数值（初始值、当前值）
     * - R(A+1)：终止值
     * - R(A+2)：步长值
     * - R(A+3)：循环变量（用户可见）
     * 
     * 循环逻辑：
     * 1. 将步长加到当前计数值：R(A) += R(A+2)
     * 2. 检查循环条件：
     *    - 步长>0：R(A) <= R(A+1)
     *    - 步长<0：R(A) >= R(A+1)
     * 3. 如果条件满足：
     *    - 设置循环变量：R(A+3) = R(A)
     *    - 跳转到循环体：pc += sBx
     * 
     * 性能优化：
     * - 整数快速路径：纯整数循环的优化实现
     * - 边界检查：溢出和下溢的正确处理
     * - 类型稳定：避免循环中的类型转换
     */
    OP_FORLOOP,
    
    /**
     * @brief 数值for循环准备指令
     * 
     * 格式：FORPREP A sBx
     * 操作：R(A) -= R(A+2); pc += sBx
     * 
     * 为数值for循环做准备，初始化循环计数器。
     * 
     * 准备步骤：
     * 1. 类型检查：确保初值、终值、步长都是数值
     * 2. 预减步长：R(A) -= R(A+2)（为第一次FORLOOP做准备）
     * 3. 跳转到循环条件检查：pc += sBx
     * 
     * 为什么预减：
     * FORLOOP指令首先执行加法，然后检查条件。
     * 预减保证第一次迭代时使用正确的初始值。
     * 
     * 错误处理：
     * 如果初值、终值或步长不是数值，抛出类型错误。
     */
    OP_FORPREP,

    /**
     * @brief 通用for循环指令
     * 
     * 格式：TFORLOOP A C
     * 操作：R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
     *       if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
     * 
     * 执行通用for循环（迭代器循环）的一次迭代。寄存器布局：
     * - R(A)：迭代器函数
     * - R(A+1)：状态变量
     * - R(A+2)：控制变量
     * - R(A+3)到R(A+2+C)：循环变量
     * 
     * 迭代步骤：
     * 1. 调用迭代器：R(A)(R(A+1), R(A+2))
     * 2. 接收返回值：R(A+3), ..., R(A+2+C)
     * 3. 检查第一个返回值：
     *    - 如果R(A+3) ~= nil：继续循环，更新控制变量
     *    - 如果R(A+3) == nil：结束循环，跳过下一条指令
     * 
     * 应用场景：
     * - pairs(table)：遍历表的所有键值对
     * - ipairs(array)：遍历数组元素
     * - 自定义迭代器：用户定义的迭代函数
     */
    OP_TFORLOOP,

    /*==================================================================
     * 表初始化指令组
     *==================================================================*/
    
    /**
     * @brief 表列表设置指令
     * 
     * 格式：SETLIST A B C
     * 操作：R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
     * 
     * 批量设置表的数组部分元素，用于表构造器的高效初始化。
     * FPF = LFIELDS_PER_FLUSH = 50。
     * 
     * 参数含义：
     * - A：目标表的寄存器
     * - B：要设置的元素数量（B=0表示到栈顶的所有元素）
     * - C：批次编号（从1开始）
     * 
     * 批量设置：
     * 表构造器 {1,2,3,...,100} 会被分解为多个SETLIST指令，
     * 每个指令处理最多50个元素。
     * 
     * 索引计算：
     * 第一批（C=1）：索引1到50
     * 第二批（C=2）：索引51到100
     * 以此类推...
     * 
     * 性能优化：
     * - 批量操作：减少指令数量
     * - 连续内存：利用数组部分的连续性
     * - 预分配：表的大小预估和预分配
     * 
     * 特殊情况：
     * 如果C=0，下一条指令包含真实的C值（超过8位范围）。
     */
    OP_SETLIST,

    /*==================================================================
     * 栈管理指令组
     *==================================================================*/
    
    /**
     * @brief 关闭upvalue指令
     * 
     * 格式：CLOSE A
     * 操作：close all variables in the stack up to (>=) R(A)
     * 
     * 关闭栈上位置A及以上的所有开放upvalue，将它们从栈变量
     * 转换为堆变量，确保闭包的正确性。
     * 
     * upvalue状态转换：
     * - 开放upvalue：指向栈上的局部变量
     * - 封闭upvalue：拥有堆上的变量副本
     * 
     * 关闭时机：
     * - 局部变量超出作用域
     * - 函数返回
     * - 块结束（do-end、if-then等）
     * 
     * 正确性保证：
     * 确保所有引用该局部变量的闭包都能继续正确访问变量值，
     * 即使原始变量已离开栈。
     * 
     * 性能影响：
     * upvalue关闭涉及内存分配和数据复制，但对于闭包的
     * 正确语义是必需的。
     */
    OP_CLOSE,

    /*==================================================================
     * 闭包创建指令组
     *==================================================================*/
    
    /**
     * @brief 闭包创建指令
     * 
     * 格式：CLOSURE A Bx
     * 操作：R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
     * 
     * 创建一个新的闭包对象，使用函数原型KPROTO[Bx]和当前环境中的upvalue。
     * 
     * 闭包创建过程：
     * 1. 获取函数原型：KPROTO[Bx]
     * 2. 创建新的函数对象
     * 3. 设置upvalue数组：
     *    - 继承父函数的upvalue
     *    - 捕获当前函数的局部变量
     * 4. 将闭包存储到R(A)
     * 
     * upvalue设置：
     * 紧跟在CLOSURE指令后面的是一系列伪指令，指定每个upvalue的来源：
     * - 0 index：从当前函数的upvalue[index]继承
     * - 1 index：从当前函数的寄存器[index]捕获
     * 
     * 性能考虑：
     * - 闭包创建的开销相对较高
     * - upvalue的懒惰关闭优化
     * - 函数原型的共享减少内存使用
     */
    OP_CLOSURE,

    /*==================================================================
     * 可变参数指令组
     *==================================================================*/
    
    /**
     * @brief 可变参数获取指令
     * 
     * 格式：VARARG A B
     * 操作：R(A), R(A+1), ..., R(A+B-1) = vararg
     * 
     * 获取函数的可变参数（...），将它们复制到指定的寄存器范围。
     * 
     * 参数处理：
     * - B=0：获取所有可变参数到栈顶
     * - B>0：获取B-1个可变参数
     * 
     * 可变参数存储：
     * 可变参数存储在函数栈帧的特殊区域，超出了固定参数和
     * 局部变量的范围。
     * 
     * 应用场景：
     * - 函数参数转发：function(...) return other_func(...) end
     * - 参数收集：local args = {...}
     * - 参数展开：print(...)
     * 
     * 性能特点：
     * - 参数复制的开销
     * - 动态参数数量的处理
     * - 与固定参数的统一处理
     */
    OP_VARARG
} OpCode;


/**
 * @brief 操作码总数常量
 * 
 * 计算虚拟机支持的操作码总数，用于数组大小分配和循环边界检查。
 * 值为OP_VARARG+1，当前为38个操作码。
 * 
 * 使用场景：
 * - 操作码属性表的大小定义
 * - 指令解析循环的边界检查
 * - 调试工具的指令遍历
 * - 性能分析的指令计数
 */
#define NUM_OPCODES (cast(int, OP_VARARG) + 1)

/**
 * @brief 操作数类型枚举：定义指令参数的使用模式
 * 
 * 详细说明：
 * 本枚举定义了指令参数的四种使用模式，用于描述每个操作码的
 * 参数语义。这些信息存储在luaP_opmodes数组中，供虚拟机和
 * 调试工具使用。
 * 
 * 参数分析用途：
 * - 编译器优化：死代码消除、寄存器分配
 * - 调试工具：指令反汇编、参数验证
 * - 静态分析：数据流分析、依赖关系
 * - 性能分析：寄存器使用统计、指令热点
 * 
 * 设计理念：
 * 通过标准化的参数类型描述，为工具开发和编译器优化
 * 提供统一的指令元信息接口。
 * 
 * @since Lua 5.1
 * @see luaP_opmodes[], getBMode(), getCMode()
 */
enum OpArgMask {
    /**
     * @brief 参数未使用
     * 
     * 表示该参数位置在当前指令中没有被使用，其值被忽略。
     * 
     * 应用场景：
     * - 单操作数指令的未使用参数位
     * - 特殊格式指令的保留字段
     * - 简化指令的冗余参数
     * 
     * 编译器处理：
     * 编译器可以在这些位置放置任意值，通常使用0。
     */
    OpArgN,
    
    /**
     * @brief 参数被使用
     * 
     * 表示该参数位置被使用，但具体用途需要查看指令的详细定义。
     * 这是一个通用的"已使用"标记。
     * 
     * 应用场景：
     * - 特殊格式的参数（如SETLIST的C参数）
     * - 不符合寄存器/常量分类的参数
     * - 复合意义的参数字段
     */
    OpArgU,
    
    /**
     * @brief 寄存器或跳转偏移
     * 
     * 表示该参数是寄存器编号或跳转偏移量。
     * 
     * 寄存器参数：
     * - 直接引用虚拟机寄存器
     * - 值范围通常在0-255之间
     * - 用于局部变量和临时值
     * 
     * 跳转偏移：
     * - 相对于当前指令的偏移量
     * - 用于控制流改变指令
     * - 支持前向和后向跳转
     * 
     * 应用实例：
     * - MOVE指令的A、B参数（寄存器）
     * - JMP指令的sBx参数（跳转偏移）
     */
    OpArgR,
    
    /**
     * @brief 常量或寄存器/常量（RK操作数）
     * 
     * 表示该参数支持RK寻址模式，可以是：
     * - 寄存器编号（0-255）
     * - 常量索引（256-511，实际索引0-255）
     * 
     * RK模式优势：
     * - 指令融合：避免单独的常量加载指令
     * - 编码紧凑：在9位参数中同时支持两种寻址
     * - 性能提升：减少指令数量和寄存器压力
     * 
     * 应用实例：
     * - 算术指令的B、C参数：ADD R(A) := RK(B) + RK(C)
     * - 比较指令的B、C参数：EQ A B C
     * - 表访问指令的C参数：GETTABLE A B C
     * 
     * 判断方法：
     * 使用ISK()宏判断是否为常量，INDEXK()提取常量索引。
     */
    OpArgK
};

/**
 * @brief 指令属性表声明
 * 
 * 该数组存储每个操作码的属性信息，每个元素是一个字节，
 * 按位编码不同的属性信息：
 * 
 * 位域分布：
 * - 位0-1：指令格式（OpMode）
 * - 位2-3：C参数类型（OpArgMask）
 * - 位4-5：B参数类型（OpArgMask）
 * - 位6：是否设置A寄存器
 * - 位7：是否是测试指令
 * 
 * 使用方法：
 * 通过相关的宏函数访问属性：getOpMode(), getBMode(), getCMode()等。
 * 
 * 外部定义：
 * 该数组在lopcodes.c中定义，包含所有操作码的完整属性信息。
 */
LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];

/**
 * @defgroup OPCODE_ATTRIBUTES 操作码属性访问宏
 * @brief 用于访问指令属性的便利宏
 * 
 * 这些宏从luaP_opmodes数组中提取特定的属性信息，
 * 为编译器和调试工具提供指令元信息的访问接口。
 * 
 * @{
 */

/**
 * @brief 获取指令格式
 * @param m 操作码（OpCode类型）
 * @return 指令格式（enum OpMode）
 * 
 * 从属性字节的低2位提取指令格式信息。
 */
#define getOpMode(m)    (cast(enum OpMode, luaP_opmodes[m] & 3))

/**
 * @brief 获取B参数类型
 * @param m 操作码（OpCode类型）
 * @return B参数的使用模式（enum OpArgMask）
 * 
 * 从属性字节的第4-5位提取B参数的类型信息。
 */
#define getBMode(m)     (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))

/**
 * @brief 获取C参数类型
 * @param m 操作码（OpCode类型）
 * @return C参数的使用模式（enum OpArgMask）
 * 
 * 从属性字节的第2-3位提取C参数的类型信息。
 */
#define getCMode(m)     (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))

/**
 * @brief 测试指令是否设置A寄存器
 * @param m 操作码（OpCode类型）
 * @return 非零表示指令会修改A寄存器
 * 
 * 检查属性字节的第6位，判断指令是否会向A寄存器写入值。
 * 这对于数据流分析和寄存器分配优化很重要。
 */
#define testAMode(m)    (luaP_opmodes[m] & (1 << 6))

/**
 * @brief 测试指令是否是测试指令
 * @param m 操作码（OpCode类型）
 * @return 非零表示这是一个测试/条件指令
 * 
 * 检查属性字节的第7位，判断指令是否执行条件测试。
 * 测试指令通常会影响程序控制流。
 * 
 * 测试指令包括：
 * - 比较指令：EQ, LT, LE
 * - 逻辑测试：TEST, TESTSET
 * - 条件跳转的相关指令
 */
#define testTMode(m)    (luaP_opmodes[m] & (1 << 7))

/** @} */

/**
 * @brief 操作码名称数组声明
 * 
 * 该数组包含所有操作码的字符串名称，用于调试和错误报告。
 * 数组大小为NUM_OPCODES+1，最后一个元素为NULL终止符。
 * 
 * 用途：
 * - 调试器的指令反汇编显示
 * - 错误消息的指令名称输出
 * - 性能分析工具的指令统计
 * - 开发工具的指令浏览功能
 * 
 * 数组内容示例：
 * luaP_opnames[OP_MOVE] = "MOVE"
 * luaP_opnames[OP_LOADK] = "LOADK"
 * ...
 * 
 * 外部定义：
 * 该数组在lopcodes.c中定义，包含所有操作码的字符串表示。
 */
LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];

/**
 * @brief 表构造器批处理大小常量
 * 
 * 定义了SETLIST指令每次处理的最大字段数量。表构造器中的
 * 数组元素会被分批处理，每批最多50个元素。
 * 
 * 设计考虑：
 * - 指令长度限制：避免单条指令处理过多元素
 * - 寄存器使用：平衡寄存器需求和批处理效率
 * - 缓存效率：适度的批处理大小提升缓存命中率
 * 
 * 应用场景：
 * - 大型数组字面量：{1,2,3,...,200}
 * - 表初始化优化：预分配和批量设置
 * - 编译器代码生成：SETLIST指令的生成策略
 * 
 * 历史注释：
 * 这个值在Lua的不同版本中可能有所调整，以优化表构造的性能。
 */
#define LFIELDS_PER_FLUSH   50

#endif
