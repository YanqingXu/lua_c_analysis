/**
 * @file lundump.h
 * @brief Lua字节码处理接口：实现预编译Lua脚本的序列化和反序列化
 * 
 * 详细说明：
 * 这个头文件定义了Lua字节码处理系统的核心接口，负责预编译Lua脚本
 * 的二进制表示的加载、保存和管理。字节码系统使得Lua脚本可以预编译
 * 为二进制格式，从而加快加载速度并保护源代码。系统支持完整的函数
 * 原型序列化，包括指令序列、常量表、调试信息等所有编译时生成的
 * 数据结构。
 * 
 * 系统架构定位：
 * - 位于Lua编译系统的输出层，处理编译结果的持久化
 * - 与解析器(lparser)协作，接收编译生成的函数原型
 * - 与虚拟机(lvm)集成，提供可执行的字节码
 * - 与I/O系统(lzio)配合，实现高效的流式读写
 * 
 * 技术特点：
 * - 二进制格式：紧凑高效的序列化格式
 * - 版本控制：确保字节码与虚拟机版本的兼容性
 * - 流式处理：支持大文件的增量加载和保存
 * - 完整性保证：包含头部校验和格式验证
 * - 调试支持：可选的详细调试信息输出
 * - 跨平台兼容：处理字节序和数据对齐问题
 * 
 * 依赖关系：
 * - lobject.h: Lua对象系统，提供Proto等核心类型
 * - lzio.h: 缓冲I/O系统，提供流式读写支持
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - I/O支持：文件和内存流操作
 * - 字节序处理：支持大端和小端系统
 * - 缓冲区管理：动态内存分配和管理
 * 
 * 使用示例：
 * @code
 * #include "lundump.h"
 * #include "lua.h"
 * 
 * // 加载预编译的字节码文件
 * lua_State *L = luaL_newstate();
 * 
 * // 从文件加载字节码
 * FILE *f = fopen("script.luac", "rb");
 * if (f != NULL) {
 *     // 创建ZIO流
 *     ZIO z;
 *     luaZ_init(L, &z, getF, f);
 *     
 *     // 创建缓冲区
 *     Mbuffer buff;
 *     luaZ_initbuffer(L, &buff);
 *     
 *     // 加载函数原型
 *     Proto *p = luaU_undump(L, &z, &buff, "script.luac");
 *     
 *     if (p != NULL) {
 *         // 创建闭包并执行
 *         Closure *cl = luaF_newLclosure(L, p, 0);
 *         setclvalue(L, L->top, cl);
 *         incr_top(L);
 *         
 *         // 执行字节码
 *         lua_call(L, 0, 0);
 *     }
 *     
 *     luaZ_freebuffer(L, &buff);
 *     fclose(f);
 * }
 * 
 * // 保存字节码到文件
 * int writer(lua_State *L, const void *p, size_t sz, void *ud) {
 *     FILE *f = (FILE *)ud;
 *     return (fwrite(p, sz, 1, f) != 1) && (sz != 0);
 * }
 * 
 * // 编译并保存脚本
 * if (luaL_loadfile(L, "script.lua") == 0) {
 *     // 获取函数原型
 *     Proto *p = clvalue(L->top - 1)->l.p;
 *     
 *     FILE *f = fopen("script.luac", "wb");
 *     if (f != NULL) {
 *         // 保存字节码（不保留调试信息）
 *         luaU_dump(L, p, writer, f, 1);
 *         fclose(f);
 *     }
 * }
 * 
 * lua_close(L);
 * @endcode
 * 
 * 字节码格式架构：
 * - 文件头：版本信息、格式标识、平台特征
 * - 函数原型：指令序列、常量表、调试信息
 * - 嵌套结构：支持函数内部定义的子函数
 * - 元数据：行号信息、变量名、源文件名
 * 
 * 性能特征：
 * - 加载速度：比源码解析快5-10倍
 * - 文件大小：通常比源码小20-50%
 * - 内存效率：直接映射到虚拟机结构
 * - 启动优化：减少解析和编译开销
 * 
 * 安全考虑：
 * - 版本检查：防止不兼容的字节码执行
 * - 格式验证：检测文件损坏和篡改
 * - 边界检查：防止缓冲区溢出攻击
 * - 资源限制：控制内存和栈使用
 * 
 * 兼容性处理：
 * - 字节序转换：支持大端和小端系统
 * - 对齐处理：适应不同平台的对齐要求
 * - 版本管理：维护向前和向后兼容性
 * 
 * 注意事项：
 * - 字节码与Lua版本强相关，不能跨版本使用
 * - 调试信息的存在会显著增加文件大小
 * - 字节码文件可能包含敏感的源码结构信息
 * - 加载过程可能触发垃圾收集
 * 
 * @author Roberto Ierusalimschy  
 * @version 1.37.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see lobject.h, lzio.h, lparser.h
 */

#ifndef lundump_h
#define lundump_h

#include "lobject.h"
#include "lzio.h"

/**
 * @brief 加载字节码：从流中反序列化一个函数原型
 * 
 * 详细说明：
 * 这个函数是字节码加载系统的核心，负责从二进制流中读取并重建
 * 完整的函数原型。加载过程包括指令序列、常量表、调试信息、
 * 子函数等所有编译时生成的数据结构的完整恢复。
 * 
 * 加载流程：
 * 1. 读取并验证文件头信息
 * 2. 检查版本兼容性和格式正确性
 * 3. 递归加载函数原型的所有组件
 * 4. 重建指令序列和操作码
 * 5. 恢复常量表（数字、字符串、布尔值、nil）
 * 6. 处理调试信息（行号、局部变量、upvalue名称）
 * 7. 递归加载嵌套的子函数原型
 * 
 * 数据验证：
 * - 文件头校验：确保是有效的Lua字节码文件
 * - 版本检查：验证与当前虚拟机的兼容性
 * - 格式验证：检查数据结构的完整性
 * - 边界检查：防止恶意构造的文件攻击
 * 
 * 内存管理：
 * - 使用Lua的内存分配器分配所有结构
 * - 自动注册到垃圾收集器
 * - 加载失败时自动清理已分配的资源
 * - 支持增量垃圾收集模式
 * 
 * 错误处理：
 * - 格式错误：返回NULL并设置错误信息
 * - 内存不足：通过Lua错误机制抛出异常
 * - I/O错误：传播底层流的错误状态
 * - 版本不匹配：报告兼容性错误
 * 
 * 性能优化：
 * - 流式读取：避免将整个文件加载到内存
 * - 延迟分配：按需分配数据结构
 * - 缓冲管理：使用高效的缓冲区操作
 * - 内存布局：优化缓存友好性
 * 
 * @param L Lua状态机指针，用于内存分配和错误处理
 * @param Z 输入流指针，包含字节码数据
 * @param buff 缓冲区指针，用于临时数据存储
 * @param name 源文件名称，用于错误报告和调试
 * @return 成功时返回加载的函数原型指针，失败时返回NULL
 * 
 * @note 这是从lundump.c实现的核心加载函数
 * @warning 加载可能失败，调用者需要检查返回值
 * @see luaU_dump(), luaL_loadfile()
 */
LUAI_FUNC Proto* luaU_undump(lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);

/**
 * @brief 生成文件头：创建字节码文件的标准头部信息
 * 
 * 详细说明：
 * 这个函数生成Lua字节码文件的标准头部，包含版本标识、格式信息、
 * 平台特征等元数据。头部信息用于验证文件的有效性和兼容性，
 * 是字节码文件的身份标识和验证基础。
 * 
 * 头部结构：
 * - 魔数：Lua字节码的唯一标识符
 * - 版本号：Lua解释器的版本信息
 * - 格式标识：官方格式标记
 * - 平台信息：字节序、指针大小、数值格式
 * - 校验数据：用于验证平台兼容性
 * 
 * 平台特征：
 * - 字节序：大端(big-endian)或小端(little-endian)
 * - 指针大小：32位或64位系统
 * - 数值格式：整数和浮点数的表示方式
 * - 对齐要求：结构体成员的对齐策略
 * 
 * 兼容性检查：
 * - 版本匹配：确保字节码与虚拟机版本一致
 * - 格式验证：检查是否为标准格式
 * - 平台适配：验证数据类型的兼容性
 * - 完整性校验：检测文件损坏或篡改
 * 
 * 头部大小：
 * - 固定大小：LUAC_HEADERSIZE字节
 * - 紧凑格式：最小化头部开销
 * - 标准化：所有Lua实现使用相同格式
 * 
 * 使用场景：
 * - 字节码文件的创建
 * - 兼容性验证
 * - 调试工具的实现
 * - 第三方加载器的开发
 * 
 * @param h 头部缓冲区指针，必须至少有LUAC_HEADERSIZE字节空间
 * 
 * @note 这是从lundump.c实现的头部生成函数
 * @warning 缓冲区h必须有足够的空间存储完整头部
 * @see LUAC_HEADERSIZE, LUAC_VERSION, LUAC_FORMAT
 */
LUAI_FUNC void luaU_header(char* h);

/**
 * @brief 转储字节码：将函数原型序列化为二进制格式
 * 
 * 详细说明：
 * 这个函数将编译生成的函数原型序列化为紧凑的二进制格式，
 * 包括指令序列、常量表、调试信息等所有运行时需要的数据。
 * 序列化后的字节码可以保存到文件或通过网络传输。
 * 
 * 序列化内容：
 * 1. 文件头：版本和格式信息
 * 2. 函数签名：参数数量、可变参数标志
 * 3. 指令序列：虚拟机字节码指令
 * 4. 常量表：数字、字符串、布尔值等常量
 * 5. 函数表：嵌套函数的原型
 * 6. 调试信息：行号、变量名、源文件名（可选）
 * 
 * 压缩选项：
 * - strip=0：保留完整调试信息
 * - strip=1：移除调试信息，减小文件大小
 * - 选择性保留：可配置保留哪些调试数据
 * 
 * 输出控制：
 * - 使用lua_Writer回调函数输出数据
 * - 支持文件、内存、网络等各种输出目标
 * - 流式输出：避免大量内存占用
 * - 错误传播：输出错误会终止序列化
 * 
 * 数据格式：
 * - 小端字节序：统一的数据表示
 * - 变长编码：优化整数和大小的存储
 * - 对齐处理：确保跨平台兼容性
 * - 紧凑格式：最小化序列化开销
 * 
 * 性能考虑：
 * - 单次遍历：一次性完成所有序列化
 * - 内存效率：不需要额外的中间缓冲
 * - 缓存友好：顺序访问数据结构
 * - 最小开销：直接从内部结构序列化
 * 
 * @param L Lua状态机指针，用于错误处理
 * @param f 要序列化的函数原型指针
 * @param w 输出函数指针，负责实际的数据写入
 * @param data 传递给输出函数的用户数据
 * @param strip 是否移除调试信息（1=移除，0=保留）
 * @return 成功时返回0，失败时返回非零值
 * 
 * @note 这是从ldump.c实现的序列化函数
 * @warning 输出函数的错误会导致序列化失败
 * @see lua_Writer, luaU_undump()
 */
LUAI_FUNC int luaU_dump(lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);

/* 条件编译：仅在luac编译器中包含打印功能 */
#ifdef luac_c

/**
 * @brief 打印字节码：输出函数原型的可读表示
 * 
 * 详细说明：
 * 这个调试函数将函数原型的内容以人类可读的格式输出，
 * 主要用于字节码的分析、调试和教学。输出包括指令的
 * 反汇编、常量表的内容、调试信息等详细信息。
 * 
 * 输出内容：
 * - 函数签名：名称、参数、源文件位置
 * - 指令列表：操作码、操作数、行号对应
 * - 常量表：所有常量的类型和值
 * - 局部变量：名称、作用域、寄存器分配
 * - Upvalue信息：外部变量的引用关系
 * - 子函数：递归打印嵌套函数
 * 
 * 详细模式：
 * - full=0：简化输出，只显示关键信息
 * - full=1：详细输出，包含所有可用信息
 * - 格式化：易于阅读的缩进和分组
 * 
 * 应用场景：
 * - 字节码分析：理解编译器的输出
 * - 性能调优：识别热点和优化机会
 * - 教学演示：展示Lua的内部结构
 * - 调试工具：开发字节码级调试器
 * 
 * 输出格式：
 * - 指令格式：地址 操作码 操作数 [行号]
 * - 常量格式：索引 类型 值
 * - 变量格式：名称 寄存器 生存期
 * - 层次结构：清晰的嵌套关系
 * 
 * @param f 要打印的函数原型指针
 * @param full 详细程度标志（0=简化，1=详细）
 * 
 * @note 这是从print.c实现的调试打印函数
 * @warning 仅在定义luac_c时可用
 * @see luac编译器工具
 */
LUAI_FUNC void luaU_print(const Proto* f, int full);

#endif

/* 二进制文件格式常量 */

/**
 * @brief Lua字节码版本：标识当前的字节码格式版本
 * 
 * 详细说明：
 * 这个常量定义了当前Lua版本的字节码格式标识符。版本标识
 * 用于确保字节码文件与虚拟机的兼容性，防止版本不匹配
 * 导致的运行时错误。
 * 
 * 版本策略：
 * - 主版本变化：字节码格式完全不兼容
 * - 次版本变化：可能的格式微调
 * - 补丁版本：通常保持格式兼容
 * 
 * 兼容性：
 * - 精确匹配：字节码版本必须与虚拟机版本完全一致
 * - 向前兼容：新版本可能支持旧版本字节码
 * - 向后兼容：一般不支持，因为缺少新特性
 * 
 * 使用场景：
 * - 文件头验证：检查字节码文件的有效性
 * - 版本检查：确保加载兼容的字节码
 * - 错误诊断：报告版本不匹配问题
 * 
 * @note 这是Lua 5.1版本的标识符
 * @see luaU_header(), 文件头格式
 */
#define LUAC_VERSION        0x51

/**
 * @brief 官方格式标识：标记为Lua官方字节码格式
 * 
 * 详细说明：
 * 这个常量标识当前使用的是Lua官方定义的标准字节码格式。
 * 格式标识用于区分官方实现和第三方修改版本，确保
 * 字节码的标准化和互操作性。
 * 
 * 格式标准：
 * - 官方格式：保证与标准Lua实现的兼容性
 * - 第三方格式：可能包含扩展或修改
 * - 实验格式：用于测试和开发
 * 
 * 兼容性保证：
 * - 标准格式：所有符合标准的Lua实现都能读取
 * - 跨平台：在不同操作系统和架构间兼容
 * - 工具链：支持标准的开发和调试工具
 * 
 * 使用场景：
 * - 格式验证：确认字节码格式的标准性
 * - 兼容性检查：验证与工具链的兼容性
 * - 质量保证：确保符合官方规范
 * 
 * @note 值为0表示官方标准格式
 * @see LUAC_VERSION, 字节码标准
 */
#define LUAC_FORMAT         0

/**
 * @brief 文件头大小：字节码文件头部的固定大小
 * 
 * 详细说明：
 * 这个常量定义了Lua字节码文件头部的固定大小（字节数）。
 * 头部包含了版本信息、格式标识、平台特征等元数据，
 * 这些信息对于正确加载和验证字节码文件至关重要。
 * 
 * 头部组成：
 * - 魔数：4字节，Lua字节码标识
 * - 版本：1字节，LUAC_VERSION
 * - 格式：1字节，LUAC_FORMAT  
 * - 字节序：1字节，大端/小端标识
 * - 整数大小：1字节，int类型的字节数
 * - size_t大小：1字节，size_t类型的字节数
 * - 指令大小：1字节，Instruction类型的字节数
 * - 数字大小：1字节，lua_Number类型的字节数
 * - 数字格式：1字节，浮点数格式标识
 * 
 * 设计原则：
 * - 固定大小：便于快速读取和验证
 * - 自描述：包含解析所需的所有类型信息
 * - 紧凑格式：最小化头部开销
 * - 兼容性：支持不同平台的特征检测
 * 
 * 使用场景：
 * - 缓冲区分配：为头部读取分配足够空间
 * - 快速验证：一次性读取所有头部信息
 * - 兼容性检查：验证平台和版本匹配
 * - 文件格式：定义标准的文件布局
 * 
 * @note 12字节的固定头部大小
 * @see luaU_header(), 头部格式规范
 */
#define LUAC_HEADERSIZE     12

#endif
