/*
** [核心] Lua 字节码反序列化头文件
**
** 功能概述：
** 本头文件定义了 Lua 字节码的加载、转储和处理接口。提供预编译 Lua 代码块的
** 序列化和反序列化功能，支持字节码的读取、写入、验证和调试输出。
**
** 主要功能模块：
** - 字节码加载：从二进制流中反序列化 Lua 函数原型
** - 字节码转储：将 Lua 函数原型序列化为二进制格式
** - 头部处理：生成和验证字节码文件头部信息
** - 调试输出：提供字节码的可读性输出和分析
** - 版本控制：处理不同版本字节码的兼容性
**
** 字节码格式规范：
** Lua 字节码采用紧凑的二进制格式存储：
** - 文件头部：包含版本信息、格式标识、平台特征等
** - 函数原型：包含指令序列、常量表、调试信息等
** - 嵌套结构：支持函数内部定义的子函数
** - 压缩优化：使用变长编码和数据压缩技术
**
** 反序列化算法原理：
** - 流式读取：逐步从输入流中读取字节码数据
** - 类型重建：根据类型标记重建 Lua 对象
** - 引用解析：处理对象间的引用关系
** - 内存管理：与 Lua GC 系统集成的内存分配
** - 错误恢复：检测和处理损坏的字节码文件
**
** 版本兼容性机制：
** - 版本标识：每个字节码文件包含版本信息
** - 格式检查：验证字节码格式的兼容性
** - 平台适配：处理不同平台的字节序和对齐
** - 向后兼容：支持旧版本字节码的加载
** - 升级转换：提供版本间的转换机制
**
** 安全性考虑：
** - 格式验证：严格验证字节码文件的完整性
** - 边界检查：防止缓冲区溢出和越界访问
** - 类型安全：确保反序列化对象的类型正确性
** - 资源限制：防止恶意字节码消耗过多资源
** - 沙箱隔离：支持在受限环境中安全执行
**
** 性能优化：
** - 零拷贝：最小化数据复制操作
** - 延迟加载：按需加载字节码的不同部分
** - 缓存机制：复用已加载的函数原型
** - 内存池：使用内存池减少分配开销
** - 并行处理：支持多线程环境下的并发加载
**
** 版本信息：$Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
** 版权声明：参见 lua.h 中的版权声明
*/

#ifndef lundump_h
#define lundump_h

// 核心依赖头文件
#include "lobject.h"  // Lua 对象系统
#include "lzio.h"     // Lua 输入输出抽象层

/*
** ========================================================================
** [函数声明] 字节码处理核心函数
** ========================================================================
**
** 字节码处理系统概述：
** Lua 字节码处理系统提供完整的序列化和反序列化功能，支持预编译代码的
** 存储、传输和加载。系统设计注重性能、安全性和跨平台兼容性。
**
** 处理流程：
** 1. 编译阶段：Lua 源代码编译为字节码
** 2. 序列化阶段：字节码转换为二进制格式
** 3. 存储/传输：二进制数据的持久化或网络传输
** 4. 反序列化阶段：二进制数据重建为字节码
** 5. 执行阶段：字节码在 Lua 虚拟机中执行
**
** 错误处理策略：
** - 格式错误：检测并报告字节码格式问题
** - 版本不匹配：处理版本兼容性问题
** - 内存不足：优雅处理内存分配失败
** - 数据损坏：检测和报告数据完整性问题
*/

/*
** [反序列化] 字节码加载函数
**
** 功能描述：
** 从输入流中加载一个预编译的 Lua 代码块，将二进制字节码反序列化为
** 可执行的函数原型对象。
**
** 参数说明：
** @param L - lua_State*：Lua 状态机指针，用于内存管理和错误处理
** @param Z - ZIO*：输入流抽象，提供字节码数据的读取接口
** @param buff - Mbuffer*：内存缓冲区，用于临时数据存储和处理
** @param name - const char*：代码块名称，用于错误报告和调试信息
**
** 返回值：
** @return Proto*：成功时返回函数原型指针，失败时返回 NULL
**
** 反序列化过程：
** 1. 头部验证：检查文件头部的版本和格式信息
** 2. 平台检查：验证字节序、整数大小等平台特征
** 3. 原型重建：递归重建函数原型及其嵌套函数
** 4. 常量加载：重建常量表中的各种类型对象
** 5. 指令解码：加载和验证字节码指令序列
** 6. 调试信息：可选地加载源码位置和变量名信息
**
** 安全验证：
** - 魔数检查：验证文件头部的魔数标识
** - 版本兼容：确保字节码版本与虚拟机兼容
** - 格式完整：检查数据结构的完整性和一致性
** - 边界安全：防止读取超出缓冲区边界
**
** 内存管理：
** - 自动分配：根据需要自动分配内存空间
** - GC 集成：与 Lua 垃圾回收器集成管理
** - 异常安全：加载失败时自动清理已分配资源
**
** 错误处理：
** 加载失败时会抛出 Lua 错误，包含详细的错误信息和位置。
**
** 使用示例：
** ZIO z;
** Mbuffer buff;
** Proto *p = luaU_undump(L, &z, &buff, "chunk.luac");
*/
LUAI_FUNC Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);

/*
** [头部生成] 字节码文件头部生成函数
**
** 功能描述：
** 生成标准的 Lua 字节码文件头部，包含版本信息、格式标识、
** 平台特征等元数据。
**
** 参数说明：
** @param h - char*：输出缓冲区，用于存储生成的头部数据
**
** 返回值：
** @return void：无返回值，结果写入提供的缓冲区
**
** 头部结构：
** 字节码文件头部包含以下信息（总共 LUAC_HEADERSIZE 字节）：
** 1. 魔数标识：Lua 字节码的唯一标识符
** 2. 版本号：Lua 版本信息（LUAC_VERSION）
** 3. 格式标识：字节码格式版本（LUAC_FORMAT）
** 4. 平台特征：字节序、整数大小、指针大小等
** 5. 浮点格式：浮点数的表示格式
** 6. 校验数据：用于验证头部完整性的校验值
**
** 平台特征编码：
** - 字节序：大端序或小端序标识
** - 整数大小：int 类型的字节数
** - 指针大小：指针类型的字节数
** - lua_Number：Lua 数字类型的大小和格式
** - 指令大小：虚拟机指令的字节数
**
** 兼容性保证：
** 生成的头部确保在相同平台和版本的 Lua 实现间兼容，
** 不同平台间可能需要额外的转换处理。
**
** 使用场景：
** - 字节码文件生成：创建 .luac 文件时
** - 网络传输：准备字节码的网络传输
** - 缓存系统：生成字节码缓存的头部
**
** 使用示例：
** char header[LUAC_HEADERSIZE];
** luaU_header(header);
** // 将 header 写入文件或流
*/
LUAI_FUNC void luaU_header (char* h);

/*
** [序列化] 字节码转储函数
**
** 功能描述：
** 将 Lua 函数原型序列化为二进制字节码格式，支持可选的调试信息剥离。
**
** 参数说明：
** @param L - lua_State*：Lua 状态机指针
** @param f - const Proto*：要转储的函数原型
** @param w - lua_Writer：写入函数，用于输出字节码数据
** @param data - void*：写入函数的用户数据参数
** @param strip - int：是否剥离调试信息（非零表示剥离）
**
** 返回值：
** @return int：成功返回0，失败返回非零错误码
**
** 序列化过程：
** 1. 头部写入：生成并写入字节码文件头部
** 2. 原型序列化：递归序列化函数原型结构
** 3. 常量转储：序列化常量表中的所有对象
** 4. 指令编码：将字节码指令编码为二进制格式
** 5. 调试信息：根据 strip 参数决定是否包含调试信息
** 6. 嵌套函数：递归处理内部定义的子函数
**
** 数据压缩：
** - 变长编码：对整数使用变长编码减少空间
** - 字符串去重：相同字符串只存储一次
** - 指令优化：移除冗余的调试指令
** - 常量合并：合并相同的常量值
**
** 调试信息处理：
** - strip = 0：保留完整的调试信息
** - strip ≠ 0：剥离源码位置、变量名等调试信息
** - 大小优化：剥离调试信息可显著减少文件大小
**
** 写入器接口：
** lua_Writer 函数负责实际的数据写入，支持：
** - 文件写入：直接写入磁盘文件
** - 内存写入：写入内存缓冲区
** - 网络写入：通过网络发送数据
** - 压缩写入：结合压缩算法减少数据量
**
** 错误处理：
** 转储过程中的错误会通过返回值报告，常见错误包括：
** - 写入失败：磁盘空间不足或网络错误
** - 内存不足：无法分配必要的临时缓冲区
** - 数据损坏：函数原型结构不一致
**
** 使用示例：
** int result = luaU_dump(L, proto, writer_func, &output_data, 1);
** if (result != 0) {
**     // 处理转储错误
** }
*/
LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);

/*
** [调试输出] 字节码打印函数（条件编译）
**
** 功能描述：
** 提供字节码的可读性输出，用于调试和分析字节码结构。
** 仅在编译 luac 工具时可用。
**
** 参数说明：
** @param f - const Proto*：要打印的函数原型
** @param full - int：是否输出完整信息（非零表示详细输出）
**
** 返回值：
** @return void：无返回值，结果输出到标准输出
**
** 输出内容：
** - 函数基本信息：参数数量、局部变量数量、上值数量
** - 指令序列：反汇编的字节码指令
** - 常量表：所有常量的值和类型
** - 调试信息：源码位置、变量名（如果可用）
** - 嵌套函数：递归输出内部定义的函数
**
** 详细模式：
** - full = 0：输出基本的函数信息和指令
** - full ≠ 0：输出完整的调试信息和详细分析
**
** 使用场景：
** - 字节码分析：理解编译器生成的字节码
** - 性能调优：分析指令序列的效率
** - 调试工具：开发字节码相关的调试工具
** - 教学研究：学习 Lua 虚拟机的工作原理
**
** 编译条件：
** 此函数仅在定义了 luac_c 宏时可用，通常只在 luac 编译器中使用。
*/
#ifdef luac_c
LUAI_FUNC void luaU_print (const Proto* f, int full);
#endif

/*
** ========================================================================
** [版本控制] 字节码格式版本和标识符
** ========================================================================
**
** 版本控制系统概述：
** Lua 字节码使用严格的版本控制确保兼容性和安全性。每个字节码文件
** 都包含版本信息，加载时会进行严格的版本检查。
**
** 版本演进：
** - 主版本：重大格式变更，不向后兼容
** - 次版本：功能增强，保持向后兼容
** - 格式版本：内部格式调整，影响序列化
**
** 兼容性策略：
** - 严格匹配：默认要求完全匹配的版本
** - 向后兼容：支持加载旧版本字节码
** - 转换升级：提供版本间的转换机制
** - 错误报告：清晰的版本不匹配错误信息
*/

/*
** [版本标识] Lua 字节码版本号
**
** 功能说明：
** 定义当前 Lua 实现支持的字节码版本号，用于版本兼容性检查。
**
** 版本编码：
** - 0x51：表示 Lua 5.1 版本的字节码格式
** - 高4位：主版本号（5）
** - 低4位：次版本号（1）
**
** 兼容性检查：
** 加载字节码时会检查此版本号，确保字节码与当前 Lua 实现兼容。
** 版本不匹配会导致加载失败并报告错误。
**
** 历史版本：
** - 0x50：Lua 5.0 版本
** - 0x51：Lua 5.1 版本
** - 0x52：Lua 5.2 版本（后续版本）
**
** 使用场景：
** - 字节码头部：写入字节码文件头部
** - 版本验证：加载时检查版本兼容性
** - 工具识别：字节码分析工具的版本识别
*/
#define LUAC_VERSION		0x51

/*
** [格式标识] 字节码格式版本
**
** 功能说明：
** 定义字节码的内部格式版本，用于区分相同 Lua 版本下的不同格式变体。
**
** 格式含义：
** - 0：官方标准格式，保证跨平台兼容性
** - 非0：自定义或实验性格式，可能不兼容
**
** 用途说明：
** - 标准兼容：确保使用官方标准的字节码格式
** - 实验支持：支持实验性的格式变体
** - 工具集成：字节码工具的格式识别
**
** 兼容性：
** 只有格式标识为 0 的字节码才保证跨平台和跨实现的兼容性。
** 非标准格式可能只在特定环境中可用。
*/
#define LUAC_FORMAT		0

/*
** [头部大小] 字节码文件头部大小
**
** 功能说明：
** 定义字节码文件头部的固定大小（以字节为单位）。
**
** 大小说明：
** - 12字节：包含所有必要的元数据信息
** - 固定大小：便于快速读取和验证
** - 平台无关：在所有支持的平台上都是12字节
**
** 头部内容：
** 12字节的头部包含：
** 1. 魔数（4字节）：Lua 字节码标识
** 2. 版本号（1字节）：LUAC_VERSION
** 3. 格式标识（1字节）：LUAC_FORMAT
** 4. 平台特征（6字节）：字节序、类型大小等
**
** 使用场景：
** - 缓冲区分配：为头部数据分配固定大小缓冲区
** - 读取验证：快速读取和验证头部信息
** - 跳过头部：在某些处理中跳过头部数据
**
** 兼容性：
** 头部大小在所有 Lua 5.1 实现中都是固定的12字节，
** 确保了字节码文件的跨平台兼容性。
*/
#define LUAC_HEADERSIZE		12

#endif
