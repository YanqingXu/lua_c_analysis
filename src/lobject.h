/**
 * @file lobject.h
 * @brief Lua对象类型定义：Lua虚拟机类型系统的核心头文件
 * 
 * 详细说明：
 * 这个头文件是Lua虚拟机类型系统的基础，定义了所有Lua数据类型的内部表示、
 * 操作接口和内存布局。它实现了一个基于tagged union的动态类型系统，
 * 支持垃圾回收、类型安全检查和高效的运行时类型判断。这是理解Lua
 * 内部工作机制的关键文件。
 * 
 * 系统架构定位：
 * 作为Lua虚拟机的类型系统核心，本头文件为整个Lua解释器提供了数据类型的
 * 统一表示。所有的Lua值、对象创建、类型检查、内存管理都基于这里定义的
 * 数据结构和接口。它是连接高级Lua语义和底层C实现的关键桥梁。
 * 
 * 技术特点：
 * - Tagged Union设计：高效的动态类型表示，最小化内存开销
 * - 统一GC接口：所有可回收对象共享相同的垃圾回收头结构
 * - 类型安全宏：编译时和运行时的类型检查保障
 * - 内存对齐优化：确保数据结构在不同平台上的最优性能
 * - 模块化设计：清晰的类型层次和组合关系
 * 
 * 核心概念：
 * - TValue：Lua中所有值的统一表示（tagged union）
 * - GCObject：所有可垃圾回收对象的基类
 * - CommonHeader：统一的GC对象头，支持标记清除算法
 * - 类型标签：用于运行时类型识别和分发
 * 
 * 依赖关系：
 * - 标准C库：stdarg.h（可变参数处理）
 * - Lua基础：llimits.h（平台限制和基础类型）、lua.h（公共API）
 * - 平台相关：依赖编译器的结构体对齐和union支持
 * 
 * 编译要求：
 * - C标准版本：C89/C90兼容，支持union和位域
 * - 内存对齐：依赖L_Umaxalign确保最大对齐要求
 * - 头文件保护：使用标准的包含保护机制
 * 
 * 使用示例：
 * @code
 * // 创建和操作Lua值
 * TValue val;
 * setnvalue(&val, 3.14);          // 设置为数字
 * if (ttisnumber(&val)) {         // 类型检查
 *     lua_Number n = nvalue(&val); // 提取数值
 * }
 * 
 * // 字符串操作
 * TString *str = luaS_new(L, "hello");
 * TValue strval;
 * setsvalue(L, &strval, str);     // 设置字符串值
 * @endcode
 * 
 * 内存安全考虑：
 * 所有对象都通过统一的GC系统管理，避免内存泄漏。类型标签确保类型安全，
 * 防止类型混淆。对齐要求保证在所有平台上的内存访问安全。调试宏提供
 * 额外的一致性检查，帮助发现潜在问题。
 * 
 * 性能特征：
 * - 紧凑表示：TValue结构最小化内存占用
 * - 高效检查：类型判断宏编译为简单的比较操作
 * - 缓存友好：相关数据在内存中紧密排布
 * - 零开销抽象：宏展开后没有额外的函数调用开销
 * 
 * 线程安全性：
 * 类型定义本身是线程安全的，但对象的修改需要适当的同步机制。
 * 垃圾回收操作需要在单线程环境中进行，或使用适当的同步原语。
 * 
 * 扩展性考虑：
 * 设计支持新类型的添加，通过扩展类型标签和相应的操作宏。
 * 对象头结构的统一性使得垃圾回收器可以统一处理所有对象类型。
 * 
 * 注意事项：
 * - 类型标签的范围和含义必须与实现保持一致
 * - 对齐要求可能因平台而异，需要谨慎处理
 * - 调试宏在发布版本中可能被禁用
 * 
 * @author Roberto Ierusalimschy and Lua Team
 * @version 5.1.5
 * @date 2008/08/06
 * @since Lua 5.0
 * @see lua.h, lgc.h, lstate.h
 */

#ifndef lobject_h
#define lobject_h

#include <stdarg.h>

#include "llimits.h"
#include "lua.h"


/**
 * =====================================================================
 * Lua类型标签系统 - 动态类型识别的基础
 * =====================================================================
 */

/**
 * @brief 最后一个用户可见类型标签：标记Lua脚本可见的类型范围
 * 
 * 详细说明：
 * 这个常量定义了Lua脚本中可见的最后一个类型标签。Lua提供了多种基本
 * 数据类型（nil、boolean、number、string、function、userdata、thread、table），
 * 这些类型都有对应的标签用于运行时类型识别。LAST_TAG标记了这个可见
 * 类型范围的边界。
 * 
 * 用途：
 * - 类型范围检查：确定某个类型是否为用户可见类型
 * - 数组大小计算：用于分配类型相关的数组和表格
 * - 类型遍历：在需要遍历所有用户类型时使用
 */
#define LAST_TAG	LUA_TTHREAD

/**
 * @brief 用户可见类型的总数：包括所有Lua脚本可操作的类型
 * 
 * 计算公式是LAST_TAG + 1，因为类型标签从0开始编号。这个值用于
 * 分配与类型数量相关的数组，如元方法表、类型名称表等。
 */
#define NUM_TAGS	(LAST_TAG+1)

/**
 * =====================================================================
 * 内部类型标签 - 虚拟机内部使用的扩展类型
 * =====================================================================
 * 
 * 这些类型标签用于Lua虚拟机内部，对Lua脚本不可见。它们扩展了基本
 * 类型系统，为虚拟机的内部操作提供更精确的类型信息。
 */

/**
 * @brief 函数原型类型标签：表示编译后的函数原型对象
 * 
 * 函数原型包含了函数的字节码、常量表、调试信息等编译时生成的数据。
 * 这是函数对象的模板，可以被多个闭包共享。
 */
#define LUA_TPROTO	(LAST_TAG+1)

/**
 * @brief 上值类型标签：表示闭包的上值对象
 * 
 * 上值是闭包捕获的外部变量的容器，支持变量的共享和生命周期管理。
 * 它们可以处于开放状态（指向栈上的值）或关闭状态（包含独立的值）。
 */
#define LUA_TUPVAL	(LAST_TAG+2)

/**
 * @brief 死键类型标签：表示哈希表中的已删除键
 * 
 * 在哈希表删除操作中，为了维护探测序列的连续性，被删除的键会被标记
 * 为死键而不是立即移除。这个特殊标签用于标识这种状态。
 */
#define LUA_TDEADKEY	(LAST_TAG+3)


/**
 * =====================================================================
 * 垃圾回收对象系统 - 统一的内存管理基础结构
 * =====================================================================
 */

/**
 * @brief 垃圾回收对象联合：所有可回收对象的统一容器
 * 
 * 详细说明：
 * 这个前向声明定义了一个联合类型，用于统一表示所有可被垃圾回收的对象。
 * 通过这种设计，垃圾回收器可以用统一的方式处理不同类型的对象，
 * 而不需要知道具体的对象类型。
 * 
 * 设计理念：
 * - 类型擦除：在GC层面抽象掉具体的对象类型
 * - 统一接口：为所有GC对象提供一致的操作接口
 * - 内存效率：避免多重继承的内存开销
 */
typedef union GCObject GCObject;

/**
 * @brief 垃圾回收对象公共头：宏形式的统一对象头定义
 * 
 * 详细说明：
 * 这个宏定义了所有可垃圾回收对象都必须包含的公共头部字段。使用宏的形式
 * 而不是结构体继承，是为了在C语言中实现类似面向对象的设计，同时保持
 * 最大的内存布局控制能力。
 * 
 * 字段说明：
 * - next: 指向GC链表中下一个对象的指针，用于垃圾回收器的对象遍历
 * - tt: 类型标签，标识对象的具体类型，用于类型分发和操作选择
 * - marked: 垃圾回收标记字节，包含对象的GC状态信息（白、灰、黑等）
 * 
 * 设计优势：
 * - 零开销：相比虚函数表，没有额外的间接访问开销
 * - 灵活布局：每个对象类型可以自由安排内存布局
 * - 类型安全：通过类型标签提供运行时类型信息
 * - GC支持：统一的标记和链接机制支持各种GC算法
 * 
 * 使用模式：
 * 所有需要垃圾回收的结构体都应该将这个宏作为第一个字段包含进来，
 * 确保公共头在对象的起始位置，便于类型转换和统一操作。
 */
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

/**
 * @brief 垃圾回收对象头结构：结构体形式的公共头定义
 * 
 * 详细说明：
 * 这个结构体提供了CommonHeader的具体化版本，主要用于需要独立操作
 * 对象头的场景。它与宏定义完全等价，但提供了更明确的类型信息。
 * 
 * 用途：
 * - 类型转换：将GCObject指针转换为具体的头结构
 * - 头部操作：对对象头进行独立的读写操作
 * - 调试支持：提供更清晰的调试信息和类型检查
 * 
 * 内存布局：
 * 确保与使用CommonHeader宏的结构体具有相同的内存布局，
 * 使得指针转换和访问操作都是安全的。
 */
typedef struct GCheader {
    CommonHeader;
} GCheader;




/**
 * =====================================================================
 * Lua值系统 - 动态类型的数据容器
 * =====================================================================
 */

/**
 * @brief Lua值联合：所有可能值类型的统一存储容器
 * 
 * 详细说明：
 * 这个联合体定义了Lua中所有可能的值类型的存储方式。通过使用联合，
 * 可以在同一块内存空间中存储不同类型的数据，实现内存的高效利用。
 * 
 * 字段说明：
 * - gc: 指向垃圾回收对象的指针（字符串、表、函数、userdata、线程）
 * - p: 通用指针，用于存储light userdata等非GC对象
 * - n: 数值类型，存储Lua的数字（通常为double）
 * - b: 布尔类型，存储true/false值（使用int以保证效率）
 * 
 * 设计考虑：
 * - 内存对齐：确保所有字段都有适当的对齐要求
 * - 类型安全：配合类型标签使用，防止类型混淆
 * - 性能优化：避免不必要的内存分配和指针间接访问
 * - 可移植性：使用标准C类型，确保跨平台兼容性
 */
typedef union {
    GCObject *gc;     /* 垃圾回收对象指针：字符串、表、函数等 */
    void *p;          /* 轻量级用户数据指针：C指针 */
    lua_Number n;     /* 数值：整数或浮点数 */
    int b;            /* 布尔值：0表示false，非0表示true */
} Value;

/**
 * @brief tagged value字段宏：定义TValue结构的核心字段
 * 
 * 详细说明：
 * 这个宏定义了tagged value结构的标准字段组合。使用宏的形式提供了
 * 更大的灵活性，允许在不同的上下文中以不同的方式使用这些字段。
 * 
 * 字段组成：
 * - value: Value联合，存储实际的数据
 * - tt: 类型标签（type tag），标识value中数据的类型
 * 
 * 设计优势：
 * - 一致性：确保所有使用tagged value的地方都有相同的字段布局
 * - 可维护性：字段定义的变更可以集中管理
 * - 扩展性：便于在需要时添加新的字段或修改现有字段
 */
#define TValuefields	Value value; int tt

/**
 * @brief Lua值结构：动态类型系统的核心实现
 * 
 * 详细说明：
 * TValue是Lua实现动态类型系统的核心数据结构。它将值数据和类型信息
 * 紧密结合，使得每个Lua值都是自描述的，即包含了足够的信息来确定
 * 如何正确地操作这个值。
 * 
 * 工作机制：
 * 1. 类型检查：通过tt字段确定value中存储的数据类型
 * 2. 值提取：根据类型从value联合中提取相应类型的数据
 * 3. 类型转换：在需要时进行适当的类型转换
 * 4. 垃圾回收：对于GC对象，通过gc指针进行内存管理
 * 
 * 使用模式：
 * - 栈操作：Lua虚拟机栈中的每个元素都是TValue
 * - 表存储：表中的键和值都使用TValue表示
 * - 函数参数：函数调用的参数和返回值都是TValue
 * - 全局变量：所有Lua变量在内部都表示为TValue
 * 
 * 性能特征：
 * - 内存紧凑：类型和值信息存储在连续的内存中
 * - 访问高效：类型检查和值访问都是O(1)操作
 * - 缓存友好：相关数据存储在同一个缓存行中
 */
typedef struct lua_TValue {
    TValuefields;     /* 值和类型标签的标准字段组合 */
} TValue;


/**
 * =====================================================================
 * 类型检查宏系统 - 高效的运行时类型判断
 * =====================================================================
 */

/**
 * @brief nil类型检查：判断值是否为nil
 * 
 * 详细说明：
 * nil是Lua中表示"无值"或"空值"的特殊类型。这个宏通过检查类型标签
 * 来快速判断一个TValue是否包含nil值。
 * 
 * 使用场景：
 * - 变量初始化检查
 * - 表中键值是否存在的判断
 * - 函数参数的可选性检查
 * - 条件语句中的真假判断（nil为假）
 */
#define ttisnil(o)	(ttype(o) == LUA_TNIL)

/**
 * @brief 布尔类型检查：判断值是否为布尔类型
 * 
 * 在Lua中，布尔类型包括true和false两个值。这个宏用于检查
 * 一个值是否属于布尔类型，而不关心具体是true还是false。
 */
#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)

/**
 * @brief 数值类型检查：判断值是否为数字
 * 
 * Lua中的数字类型通常是双精度浮点数，这个宏用于检查
 * 一个值是否可以进行数学运算。
 */
#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)

/**
 * @brief 字符串类型检查：判断值是否为字符串
 * 
 * 字符串是Lua中的基本数据类型之一，这个宏用于检查
 * 一个值是否为字符串类型。
 */
#define ttisstring(o)	(ttype(o) == LUA_TSTRING)

/**
 * @brief 表类型检查：判断值是否为表
 * 
 * 表是Lua中唯一的复合数据结构，这个宏用于检查
 * 一个值是否为表类型。
 */
#define ttistable(o)	(ttype(o) == LUA_TTABLE)

/**
 * @brief 函数类型检查：判断值是否为函数
 * 
 * 这个宏检查值是否为Lua函数（包括Lua函数和C函数）。
 */
#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)

/**
 * @brief 用户数据类型检查：判断值是否为完整用户数据
 * 
 * 完整用户数据是由Lua管理内存的用户自定义数据类型。
 */
#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)

/**
 * @brief 线程类型检查：判断值是否为线程（协程）
 * 
 * 线程类型用于实现Lua的协程功能。
 */
#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)

/**
 * @brief 轻量级用户数据检查：判断值是否为轻量级用户数据
 * 
 * 轻量级用户数据是指向C数据的指针，不受垃圾回收管理。
 */
#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)

/**
 * =====================================================================
 * 值访问宏系统 - 高效的数据提取和类型转换
 * =====================================================================
 */

/**
 * @brief 类型标签访问：获取TValue的类型标签
 * 
 * 这个宏直接访问TValue结构中的类型标签字段，是所有类型检查
 * 和值访问操作的基础。
 */
#define ttype(o)	((o)->tt)

/**
 * @brief 垃圾回收对象访问：安全地获取GC对象指针
 * 
 * 详细说明：
 * 这个宏用于从TValue中提取垃圾回收对象的指针。它使用check_exp
 * 进行运行时类型检查，确保只有可垃圾回收的对象才会被访问。
 * 
 * 适用类型：字符串、表、函数、完整用户数据、线程等。
 */
#define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)

/**
 * @brief 轻量级用户数据访问：获取C指针值
 * 
 * 轻量级用户数据存储的是原始的C指针，不受垃圾回收管理。
 * 这个宏确保只有轻量级用户数据类型才会返回指针值。
 */
#define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)

/**
 * @brief 数值访问：获取数字值
 * 
 * 从TValue中提取lua_Number类型的数值。lua_Number通常定义
 * 为double，用于表示Lua中的所有数字。
 */
#define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)

/**
 * @brief 原始字符串访问：获取TString对象指针
 * 
 * 这个宏返回指向完整TString结构的指针，包含字符串的元数据
 * （如长度、哈希值等）。
 */
#define rawtsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)

/**
 * @brief 字符串值访问：获取字符串的实际数据部分
 * 
 * 从TString结构中提取实际的字符串数据部分，返回指向TString
 * 中的字符串值字段的指针。
 */
#define tsvalue(o)	(&rawtsvalue(o)->tsv)

/**
 * @brief 原始用户数据访问：获取Udata对象指针
 * 
 * 返回指向完整Udata结构的指针，包含用户数据的元数据。
 */
#define rawuvalue(o)	check_exp(ttisuserdata(o), &(o)->value.gc->u)

/**
 * @brief 用户数据值访问：获取用户数据的实际数据部分
 * 
 * 从Udata结构中提取实际的用户数据部分。
 */
#define uvalue(o)	(&rawuvalue(o)->uv)

/**
 * @brief 闭包访问：获取函数闭包对象
 * 
 * 从TValue中提取函数对象，可能是Lua闭包或C闭包。
 */
#define clvalue(o)	check_exp(ttisfunction(o), &(o)->value.gc->cl)

/**
 * @brief 表访问：获取表对象
 * 
 * 从TValue中提取表对象的指针，用于表操作。
 */
#define hvalue(o)	check_exp(ttistable(o), &(o)->value.gc->h)

/**
 * @brief 布尔值访问：获取布尔值
 * 
 * 从TValue中提取布尔值，返回int类型（0表示false，非0表示true）。
 */
#define bvalue(o)	check_exp(ttisboolean(o), (o)->value.b)

/**
 * @brief 线程访问：获取线程（协程）对象
 * 
 * 从TValue中提取线程对象，用于协程操作。
 */
#define thvalue(o)	check_exp(ttisthread(o), &(o)->value.gc->th)

/**
 * @brief 假值检查：判断值在逻辑上是否为假
 * 
 * 详细说明：
 * 在Lua中，只有nil和false被认为是假值，其他所有值（包括0、空字符串）
 * 都被认为是真值。这个宏实现了Lua的真假判断逻辑。
 * 
 * 判断规则：
 * - nil值返回真（表示是假值）
 * - false布尔值返回真（表示是假值）  
 * - 其他所有值返回假（表示是真值）
 */
#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))

/**
 * =====================================================================
 * 内部调试宏系统 - 开发时的一致性检查
 * =====================================================================
 */

/**
 * @brief 一致性检查：验证对象的类型标签一致性
 * 
 * 详细说明：
 * 这个宏用于内部调试，检查TValue中的类型标签是否与其指向的
 * GC对象的类型标签保持一致。这种检查有助于发现类型系统中的错误。
 * 
 * 检查逻辑：
 * - 对于非GC对象，不进行检查
 * - 对于GC对象，验证TValue的类型标签与GC对象头中的类型标签相同
 * 
 * 注意：这个宏只在调试模式下生效，发布版本中会被优化掉。
 */
#define checkconsistency(obj) \
  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))

/**
 * @brief 存活性检查：验证对象的垃圾回收状态
 * 
 * 这个宏检查对象是否处于有效的垃圾回收状态，防止访问已被回收的对象。
 */
#define checkliveness(g,obj) \
  lua_assert(!iscollectable(obj) || \
  ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))


/**
 * =====================================================================
 * 值设置宏系统 - 类型安全的TValue赋值操作
 * =====================================================================
 */

/**
 * @brief 设置nil值：将TValue设置为nil类型
 * 
 * 这是最简单的值设置操作，只需要设置类型标签，因为nil没有关联的数据。
 */
#define setnilvalue(obj) ((obj)->tt=LUA_TNIL)

/**
 * @brief 设置数值：将TValue设置为数字类型
 * 
 * 详细说明：
 * 这个宏安全地将一个数值赋给TValue。它使用临时变量i_o来避免
 * 参数被多次求值的副作用，这是宏编程中的常见技巧。
 * 
 * 参数：
 * - obj: 目标TValue指针
 * - x: 要设置的数值（lua_Number类型）
 * 
 * 操作顺序：
 * 1. 创建临时指针避免副作用
 * 2. 设置数值到value.n字段
 * 3. 设置类型标签为LUA_TNUMBER
 */
#define setnvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }

/**
 * @brief 设置轻量级用户数据：将TValue设置为C指针
 * 
 * 轻量级用户数据存储原始的C指针，不受垃圾回收管理。
 * 这种类型适合存储不需要内存管理的C数据指针。
 */
#define setpvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }

/**
 * @brief 设置布尔值：将TValue设置为布尔类型
 * 
 * 在Lua中，布尔值使用int类型存储，0表示false，非0表示true。
 */
#define setbvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }

/**
 * @brief 设置字符串值：将TValue设置为字符串类型
 * 
 * 详细说明：
 * 字符串是垃圾回收对象，因此这个宏除了设置值和类型外，还会进行
 * 存活性检查以确保对象处于有效的GC状态。
 * 
 * 参数：
 * - L: Lua状态机指针，用于访问全局状态
 * - obj: 目标TValue指针
 * - x: 字符串对象指针
 */
#define setsvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; \
    checkliveness(G(L),i_o); }

/**
 * @brief 设置完整用户数据：将TValue设置为用户数据类型
 * 
 * 完整用户数据是由Lua管理内存的用户自定义数据，需要进行GC管理。
 */
#define setuvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; \
    checkliveness(G(L),i_o); }

/**
 * @brief 设置线程值：将TValue设置为线程（协程）类型
 * 
 * 线程对象用于实现Lua的协程功能，也是垃圾回收对象。
 */
#define setthvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; \
    checkliveness(G(L),i_o); }

/**
 * @brief 设置函数值：将TValue设置为函数类型
 * 
 * 函数可以是Lua闭包或C闭包，都是垃圾回收对象。
 */
#define setclvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; \
    checkliveness(G(L),i_o); }

/**
 * @brief 设置表值：将TValue设置为表类型
 * 
 * 表是Lua中的复合数据结构，用于实现数组、字典等功能。
 */
#define sethvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; \
    checkliveness(G(L),i_o); }

/**
 * @brief 设置原型值：将TValue设置为函数原型类型
 * 
 * 详细说明：
 * 函数原型是Lua编译器产生的字节码表示，包含函数的指令序列、
 * 常量表、调试信息等。这是一个内部类型，通常不直接暴露给用户。
 */
#define setptvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; \
    checkliveness(G(L),i_o); }

/**
 * =====================================================================
 * 对象复制和类型转换系统
 * =====================================================================
 */

/**
 * @brief 对象复制：将一个TValue的完整内容复制到另一个TValue
 * 
 * 详细说明：
 * 这是最通用的对象赋值宏，它复制源对象的值和类型信息到目标对象。
 * 对于垃圾回收对象，还会进行存活性检查以确保对象引用的有效性。
 * 
 * 参数：
 * - L: Lua状态机，用于GC相关检查
 * - obj1: 目标TValue指针
 * - obj2: 源TValue指针
 * 
 * 操作步骤：
 * 1. 创建临时指针避免参数副作用
 * 2. 复制值数据（整个Value联合）
 * 3. 复制类型标签
 * 4. 对GC对象进行存活性验证
 */
#define setobj(L,obj1,obj2) \
  { const TValue *o2=(obj2); TValue *o1=(obj1); \
    o1->value = o2->value; o1->tt=o2->tt; \
    checkliveness(G(L),o1); }

/**
 * =====================================================================
 * 专用赋值宏系统 - 针对不同内存区域的优化版本
 * =====================================================================
 * 
 * 说明：
 * 下面的宏提供了针对不同内存区域（栈、表、新对象等）的专用赋值操作。
 * 这种设计允许在不同场景下进行特定的优化，比如跳过某些检查或使用
 * 不同的内存屏障策略。
 */

/**
 * @brief 栈到栈赋值：在同一个栈内的元素间复制
 * 
 * 在同一个栈内复制时，可以假设内存管理状态是一致的。
 */
#define setobjs2s	setobj

/**
 * @brief 到栈赋值：从其他区域复制到栈
 * 
 * 将值从非栈区域（如表、全局变量等）复制到栈上。
 */
#define setobj2s	setobj
#define setsvalue2s	setsvalue
#define sethvalue2s	sethvalue
#define setptvalue2s	setptvalue

/**
 * @brief 表内赋值：在同一个表内的元素间复制
 * 
 * 表内赋值可能涉及哈希表的重组和写屏障。
 */
#define setobjt2t	setobj

/**
 * @brief 到表赋值：从其他区域复制到表
 * 
 * 向表中插入或更新值时使用，可能触发表的扩容和重哈希。
 */
#define setobj2t	setobj

/**
 * @brief 到新对象赋值：复制到新分配的对象
 * 
 * 新对象的赋值不需要考虑旧值的清理问题。
 */
#define setobj2n	setobj
#define setsvalue2n	setsvalue

/**
 * @brief 设置类型标签：直接修改对象的类型标签
 * 
 * 这个宏允许直接修改TValue的类型标签，主要用于类型转换或
 * 特殊的内部操作。使用时需要确保值数据与新类型匹配。
 */
#define setttype(obj, tt) (ttype(obj) = (tt))

/**
 * @brief 可回收性检查：判断对象是否需要垃圾回收
 * 
 * 详细说明：
 * 这个宏通过检查类型标签来判断对象是否是垃圾回收对象。
 * 在Lua的类型系统中，数字、布尔值、nil和轻量级用户数据不需要GC，
 * 而字符串、表、函数、完整用户数据和线程需要GC管理。
 * 
 * 判断规则：
 * 类型标签 >= LUA_TSTRING 的对象都是可垃圾回收的对象。
 * 这利用了类型常量的定义顺序。
 */
#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)

/**
 * =====================================================================
 * 栈索引类型定义
 * =====================================================================
 */

/**
 * @brief 栈索引类型：指向栈元素的指针类型
 * 
 * 详细说明：
 * StkId是Lua虚拟机栈操作的基础类型，它是指向TValue的指针。
 * 通过使用专门的类型名，代码的意图更加清晰，同时便于进行
 * 类型相关的优化和调试。
 * 
 * 用途：
 * - 函数参数传递：标识栈上的参数位置
 * - 栈帧管理：定位函数的局部变量和临时值
 * - 虚拟机指令：作为指令操作数的目标和源
 * - API接口：C API中栈操作的索引类型
 */
typedef TValue *StkId;  /* 栈元素索引：指向栈中TValue的指针 */


/**
 * =====================================================================
 * 字符串对象系统 - 不可变字符串的高效实现
 * =====================================================================
 */

/**
 * @brief 字符串对象：Lua中字符串的内部表示
 * 
 * 详细说明：
 * TString是Lua字符串的内部表示，采用了union结构来优化内存对齐。
 * Lua中的字符串是不可变的，这允许进行各种优化，如字符串interning
 * （字符串驻留）和哈希缓存。
 * 
 * 设计特点：
 * - 不可变性：字符串一旦创建就不能修改，保证了数据一致性
 * - 哈希缓存：预计算并缓存哈希值，加速表查找和比较操作
 * - 引用计数：通过垃圾回收管理生命周期
 * - 内存对齐：使用L_Umaxalign确保最佳的内存访问性能
 * 
 * 内存布局：
 * 字符串数据紧跟在TString结构之后，形成一个连续的内存块，
 * 这种设计减少了内存碎片并提高了缓存局部性。
 */
typedef union TString {
    /**
     * @brief 对齐填充：确保字符串的最大对齐
     * 
     * 这个字段确保整个union具有平台要求的最大对齐，
     * 从而优化内存访问性能。
     */
    L_Umaxalign dummy;  /* 确保字符串的最大内存对齐 */
    
    /**
     * @brief 字符串值结构：包含字符串的元数据
     */
    struct {
        CommonHeader;           /* 垃圾回收对象的公共头部 */
        lu_byte reserved;       /* 保留字段：用于将来的扩展或特殊标记 */
        unsigned int hash;      /* 哈希值：预计算的字符串哈希，用于快速比较和查找 */
        size_t len;            /* 长度：字符串的字节长度（不包括终止符） */
    } tsv;
} TString;

/**
 * @brief 获取字符串数据：从TString对象中提取C字符串指针
 * 
 * 详细说明：
 * 这个宏返回指向字符串实际数据的指针。字符串数据存储在TString
 * 结构体之后的内存中，因此通过指针算术（+1）可以直接访问。
 * 
 * 内存布局：
 * [TString结构] [字符串数据...] ['\0']
 *               ^
 *               这个宏返回这个位置的指针
 */
#define getstr(ts)	cast(const char *, (ts) + 1)

/**
 * @brief 获取字符串值：从TValue中提取字符串的C字符串表示
 * 
 * 这个宏组合了rawtsvalue和getstr，提供了从TValue直接获取
 * C字符串指针的便捷方法。
 */
#define svalue(o)       getstr(rawtsvalue(o))

/**
 * =====================================================================
 * 用户数据对象系统 - 自定义数据类型的容器
 * =====================================================================
 */

/**
 * @brief 用户数据对象：包装C数据结构的Lua对象
 * 
 * 详细说明：
 * Udata是Lua中用户数据的内部表示，它允许将任意的C数据结构
 * 包装成Lua对象。与轻量级用户数据不同，完整的用户数据受到
 * 垃圾回收管理，并且可以拥有元表和环境。
 * 
 * 应用场景：
 * - C库绑定：将C结构体暴露给Lua代码
 * - 资源管理：确保C资源的正确释放
 * - 面向对象编程：通过元表实现方法调用
 * - 数据封装：隐藏C实现细节
 */
typedef union Udata {
    /**
     * @brief 对齐填充：确保用户数据的最大对齐
     * 
     * 保证用户数据具有适当的内存对齐，这对某些C结构体
     * （如包含double或指针的结构）是必需的。
     */
    L_Umaxalign dummy;  /* 确保本地用户数据的最大内存对齐 */
    
    /**
     * @brief 用户数据值结构：包含用户数据的元数据
     */
    struct {
        CommonHeader;               /* 垃圾回收对象的公共头部 */
        struct Table *metatable;    /* 元表：定义用户数据的操作和行为 */
        struct Table *env;          /* 环境：用户数据的作用域环境 */
        size_t len;                /* 数据长度：用户数据的字节大小 */
    } uv;
} Udata;

/**
 * =====================================================================
 * 函数原型系统 - 编译后Lua函数的字节码表示
 * =====================================================================
 */

/**
 * @brief 函数原型：Lua函数编译后的字节码表示
 * 
 * 详细说明：
 * Proto结构包含了Lua函数编译后的所有信息，包括字节码指令、
 * 常量表、调试信息等。这是Lua虚拟机执行的基础数据结构。
 * 
 * 编译过程：
 * Lua源码 -> 词法分析 -> 语法分析 -> 代码生成 -> Proto对象
 * 
 * 执行过程：
 * Proto对象被包装在闭包中，然后由虚拟机解释执行其中的字节码。
 */
typedef struct Proto {
    CommonHeader;                   /* 垃圾回收对象的公共头部 */
    TValue *k;                     /* 常量表：函数使用的常量值数组 */
    Instruction *code;             /* 指令序列：函数的字节码指令数组 */
    struct Proto **p;              /* 内部函数：在函数内定义的子函数原型 */
    int *lineinfo;                 /* 行号信息：字节码到源码行号的映射 */
    struct LocVar *locvars;        /* 局部变量：局部变量的调试信息 */
    TString **upvalues;            /* 上值名称：闭包变量的名称数组 */
    TString  *source;              /* 源文件：函数所在的源文件名 */
    int sizeupvalues;              /* 上值数量：upvalues数组的大小 */
    int sizek;                     /* 常量数量：常量表k的大小 */
    int sizecode;                  /* 指令数量：code数组的大小 */
    int sizelineinfo;             /* 行号信息数量：lineinfo数组的大小 */
    int sizep;                    /* 子函数数量：内部函数原型数组p的大小 */
    int sizelocvars;              /* 局部变量数量：locvars数组的大小 */
    int linedefined;              /* 定义行号：函数在源码中的起始行号 */
    int lastlinedefined;          /* 结束行号：函数在源码中的结束行号 */
    GCObject *gclist;             /* 垃圾回收链表：用于GC遍历的链接指针 */
    lu_byte nups;                 /* 上值数量：函数引用的外部变量个数 */
    lu_byte numparams;            /* 参数数量：函数的固定参数个数 */
    lu_byte is_vararg;            /* 可变参数标志：函数是否接受可变数量的参数 */
    lu_byte maxstacksize;         /* 最大栈大小：函数执行时需要的最大栈空间 */
} Proto;

/**
 * =====================================================================
 * 可变参数系统 - 新式可变参数的标志位
 * =====================================================================
 */

/**
 * @brief 可变参数掩码：用于标识函数的可变参数特性
 * 
 * 详细说明：
 * 这些常量定义了函数可变参数系统的不同特性。Lua 5.1引入了新的
 * 可变参数语法（...），这些标志位用于标识函数如何处理可变参数。
 */

/**
 * @brief 有参数标志：函数有实际的可变参数
 * 
 * 当函数被调用时接收到了实际的可变参数时设置此标志。
 */
#define VARARG_HASARG		1

/**
 * @brief 是可变参数函数：函数声明时使用了...语法
 * 
 * 标识函数在定义时声明为可变参数函数（使用...语法）。
 */
#define VARARG_ISVARARG		2

/**
 * @brief 需要参数：函数内部需要访问可变参数
 * 
 * 当函数体内部实际使用了可变参数（如通过select()或arg表）时设置。
 */
#define VARARG_NEEDSARG		4


/**
 * =====================================================================
 * 局部变量调试信息系统
 * =====================================================================
 */

/**
 * @brief 局部变量信息：用于调试的局部变量描述
 * 
 * 详细说明：
 * LocVar结构存储了函数中局部变量的调试信息。这些信息在运行时
 * 通常不被使用，但对调试器、错误报告和反射功能非常重要。
 * 
 * 生命周期管理：
 * 通过startpc和endpc字段精确定义了变量的作用域，这允许调试器
 * 在正确的时机显示或隐藏变量，提供准确的调试体验。
 */
typedef struct LocVar {
    TString *varname;             /* 变量名称：局部变量的标识符 */
    int startpc;                  /* 起始PC：变量开始有效的字节码位置 */
    int endpc;                    /* 结束PC：变量失效的字节码位置（不包含） */
} LocVar;

/**
 * =====================================================================
 * 上值（闭包变量）系统 - 词法作用域的核心实现
 * =====================================================================
 */

/**
 * @brief 上值对象：实现闭包捕获的外部变量
 * 
 * 详细说明：
 * UpVal是Lua实现闭包的关键数据结构。当内部函数引用外部函数的
 * 局部变量时，这些变量会被"提升"为上值，从而在外部函数返回后
 * 仍然保持可访问性。
 * 
 * 状态转换：
 * 1. 开放状态（Open）：上值指向栈上的活跃变量
 * 2. 关闭状态（Closed）：上值拥有变量的副本，变量已从栈中移除
 * 
 * 生命周期：
 * - 创建：当内部函数首次引用外部变量时
 * - 开放：当外部变量仍在栈上时，上值指向栈位置
 * - 关闭：当外部函数返回时，将栈上的值复制到上值内部
 * - 销毁：当所有引用此上值的闭包都被回收时
 * 
 * 共享机制：
 * 多个闭包可以共享同一个上值，这确保了变量修改的一致性。
 */
typedef struct UpVal {
    CommonHeader;                 /* 垃圾回收对象的公共头部 */
    TValue *v;                   /* 值指针：指向栈位置或自身的value字段 */
    union {
        /**
         * @brief 关闭状态：上值包含变量的实际值
         * 
         * 当外部函数返回，栈上的变量不再存在时，上值会保存
         * 变量的副本。此时v指针会指向这个value字段。
         */
        TValue value;            /* 实际值：关闭时存储的变量值 */
        
        /**
         * @brief 开放状态：上值通过双向链表组织
         * 
         * 开放的上值会被组织成双向链表，便于垃圾回收器
         * 和闭包管理器进行统一管理。
         */
        struct {
            struct UpVal *prev;  /* 前一个上值：双向链表的前驱指针 */
            struct UpVal *next;  /* 后一个上值：双向链表的后继指针 */
        } l;
    } u;
} UpVal;


/**
 * =====================================================================
 * 闭包对象系统 - 函数与环境的绑定实体
 * =====================================================================
 */

/**
 * @brief 闭包公共头：所有闭包类型的共同字段
 * 
 * 详细说明：
 * 这个宏定义了C闭包和Lua闭包都需要的公共字段。使用宏的形式
 * 确保了两种闭包类型具有相同的内存布局起始部分。
 * 
 * 字段说明：
 * - CommonHeader: 垃圾回收对象的标准头部
 * - isC: 标识是否为C函数（1表示C函数，0表示Lua函数）
 * - nupvalues: 上值数量，即闭包捕获的外部变量个数
 * - gclist: 垃圾回收链表指针，用于GC遍历
 * - env: 环境表，定义函数执行时的全局环境
 */
#define ClosureHeader \
	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \
	struct Table *env

/**
 * @brief C闭包：包装C函数的闭包对象
 * 
 * 详细说明：
 * CClosure用于将C函数包装成Lua闭包。C函数的上值存储为TValue数组，
 * 这允许C函数访问Lua数据，实现C和Lua之间的数据交互。
 * 
 * 使用场景：
 * - C库绑定：将C函数导出给Lua使用
 * - 性能优化：关键算法用C实现
 * - 系统接口：访问操作系统功能
 * - 数据处理：处理大量数据的高效函数
 */
typedef struct CClosure {
    ClosureHeader;                /* 闭包的公共头部字段 */
    lua_CFunction f;             /* C函数指针：指向实际的C函数 */
    TValue upvalue[1];           /* 上值数组：C函数可访问的Lua值（可变长度） */
} CClosure;

/**
 * @brief Lua闭包：包装Lua函数的闭包对象
 * 
 * 详细说明：
 * LClosure用于表示Lua函数的闭包。它包含函数原型和上值数组，
 * 实现了词法作用域和闭包捕获功能。
 * 
 * 工作机制：
 * 1. 函数原型包含字节码和元数据
 * 2. 上值数组存储捕获的外部变量
 * 3. 环境表定义全局变量查找范围
 * 
 * 性能特征：
 * - 上值访问是O(1)操作
 * - 支持上值共享，节省内存
 * - 支持尾调用优化
 */
typedef struct LClosure {
    ClosureHeader;               /* 闭包的公共头部字段 */
    struct Proto *p;             /* 函数原型：包含字节码和元数据 */
    UpVal *upvals[1];           /* 上值指针数组：指向捕获的外部变量（可变长度） */
} LClosure;

/**
 * @brief 闭包联合：统一表示C闭包和Lua闭包
 * 
 * 详细说明：
 * 这个联合允许用统一的指针类型处理不同种类的闭包。
 * 通过检查isC字段可以确定具体的闭包类型。
 * 
 * 类型判断：
 * - closure->c.isC != 0: C闭包，使用c字段访问
 * - closure->c.isC == 0: Lua闭包，使用l字段访问
 */
typedef union Closure {
    CClosure c;                  /* C闭包：C函数的闭包表示 */
    LClosure l;                  /* Lua闭包：Lua函数的闭包表示 */
} Closure;

/**
 * =====================================================================
 * 函数类型检查宏
 * =====================================================================
 */

/**
 * @brief C函数检查：判断值是否为C函数
 * 
 * 检查一个TValue是否包含C函数闭包。
 */
#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)

/**
 * @brief Lua函数检查：判断值是否为Lua函数
 * 
 * 检查一个TValue是否包含Lua函数闭包。
 */
#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)

/**
 * =====================================================================
 * 表对象系统 - Lua的通用数据结构
 * =====================================================================
 */

/**
 * @brief 表键联合：表中键的统一表示
 * 
 * 详细说明：
 * TKey用于表示哈希表中的键。它结合了TValue的功能和链表节点的特性，
 * 实现了高效的哈希表操作。
 * 
 * 设计特点：
 * - 键值一体：键本身就是一个完整的TValue
 * - 链表支持：通过next指针实现冲突解决
 * - 内存紧凑：键和链接信息存储在连续内存中
 */
typedef union TKey {
    struct {
        TValuefields;            /* 键的值和类型信息 */
        struct Node *next;       /* 链表指针：指向下一个具有相同哈希值的节点 */
    } nk;
    /**
     * @brief TValue视图：将键作为普通TValue访问
     * 
     * 这个字段允许将TKey作为标准的TValue来操作，
     * 便于进行值比较和类型检查。
     */
    TValue tvk;
} TKey;

/**
 * @brief 哈希表节点：键值对的存储单元
 * 
 * 详细说明：
 * Node是哈希表中的基本存储单元，每个节点包含一个键值对。
 * 所有的表操作最终都会操作这些节点。
 * 
 * 内存布局：
 * 节点数组形成哈希表的骨架，通过哈希函数将键映射到数组索引，
 * 然后通过链表解决哈希冲突。
 * 
 * 访问模式：
 * - 查找：计算键的哈希值，找到对应的节点，然后沿着冲突链查找
 * - 插入：找到空节点或链表末尾，插入新的键值对
 * - 删除：将节点标记为死键，但保持链表结构完整
 */
typedef struct Node {
    TValue i_val;               /* 值：该节点存储的Lua值 */
    TKey i_key;                 /* 键：该节点的键，包含链表信息 */
} Node;


/**
 * @brief 表对象：Lua的核心数据结构
 * 
 * 详细说明：
 * Table是Lua中唯一的复合数据结构，它同时实现了数组和哈希表的功能。
 * 这种混合设计使得Lua表既能高效处理数值索引，又能灵活处理任意键值。
 * 
 * 双重结构设计：
 * 1. 数组部分：用于存储连续的数值索引（1, 2, 3, ...）
 * 2. 哈希部分：用于存储其他类型的键和非连续的数值索引
 * 
 * 自适应优化：
 * 表会根据使用模式动态调整数组和哈希部分的大小，
 * 以获得最佳的内存使用率和访问性能。
 * 
 * 元表机制：
 * 通过metatable字段支持操作符重载和面向对象编程。
 */
typedef struct Table {
    CommonHeader;                /* 垃圾回收对象的公共头部 */
    lu_byte flags;              /* 元方法标志：1<<p 表示元方法p不存在，用于优化元方法查找 */
    lu_byte lsizenode;          /* 节点数组大小的对数：log2(node数组大小) */
    struct Table *metatable;    /* 元表：定义表的操作行为和方法 */
    TValue *array;              /* 数组部分：存储数值索引的连续数组 */
    Node *node;                 /* 哈希部分：存储非数值索引的哈希表节点数组 */
    Node *lastfree;             /* 空闲位置标记：指向最后一个空闲位置之前的位置 */
    GCObject *gclist;           /* 垃圾回收链表：用于GC遍历的链接指针 */
    int sizearray;              /* 数组大小：array数组的实际大小 */
} Table;

/**
 * =====================================================================
 * 哈希表操作宏系统
 * =====================================================================
 */

/**
 * @brief 模运算宏：针对2的幂次方的优化取模运算
 * 
 * 详细说明：
 * 这个宏实现了高效的取模运算，利用了size总是2的幂次方这一特性。
 * 对于2的幂次方，取模运算可以优化为位与运算。
 * 
 * 优化原理：
 * 当size = 2^n时，x % size = x & (size - 1)
 * 例如：x % 8 = x & 7，因为8 = 2^3，7 = 0111(二进制)
 * 
 * 参数：
 * - s: 被取模的数值
 * - size: 模数，必须是2的幂次方
 */
#define lmod(s,size) \
	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))

/**
 * @brief 2的幂次方计算：计算2^x的值
 * 
 * 用于从对数值计算实际的大小值。
 */
#define twoto(x)	(1<<(x))

/**
 * @brief 节点数组大小：计算表的哈希部分大小
 * 
 * 从表的lsizenode字段计算出实际的节点数组大小。
 */
#define sizenode(t)	(twoto((t)->lsizenode))

/**
 * =====================================================================
 * 全局nil对象
 * =====================================================================
 */

/**
 * @brief nil对象引用：指向全局唯一的nil值对象
 * 
 * 详细说明：
 * luaO_nilobject是一个指向全局nil对象的指针。所有需要nil值的地方
 * 都使用这个统一的对象，避免了重复创建nil值，节省内存并提高效率。
 * 
 * 使用场景：
 * - 表初始化：新建表的元素默认指向nil对象
 * - 默认返回值：函数没有返回值时返回nil
 * - 变量初始化：未赋值的变量默认为nil
 * - 错误处理：某些操作失败时返回nil
 */
#define luaO_nilobject		(&luaO_nilobject_)

/**
 * @brief 全局nil对象实例：系统唯一的nil值对象
 * 
 * 这是一个外部声明，实际的定义在lobject.c中。
 * 使用LUAI_DATA宏确保正确的链接属性。
 */
LUAI_DATA const TValue luaO_nilobject_;

/**
 * =====================================================================
 * 数学工具函数和字符串处理函数
 * =====================================================================
 */

/**
 * @brief 向上取整对数：计算不小于log2(x)的最小整数
 * 
 * 详细说明：
 * 这个宏用于计算容纳x个元素所需的2的幂次方大小。
 * 例如：ceillog2(5) = 3，因为需要2^3=8的容量来容纳5个元素。
 * 
 * 应用场景：
 * - 哈希表大小计算：确定合适的哈希表容量
 * - 内存分配：计算2的幂次方的内存块大小
 * - 数组扩容：确定新的数组容量
 */
#define ceillog2(x)	(luaO_log2((x)-1) + 1)

/**
 * =====================================================================
 * 外部函数声明 - lobject.c中实现的核心函数
 * =====================================================================
 */

/**
 * @brief 对数计算：计算无符号整数的以2为底的对数
 * 
 * 返回不大于log2(x)的最大整数，用于各种大小计算。
 */
LUAI_FUNC int luaO_log2 (unsigned int x);

/**
 * @brief 整数到浮点字节转换：将整数转换为浮点数的字节表示
 * 
 * 用于紧凑存储小的浮点数，节省内存空间。
 */
LUAI_FUNC int luaO_int2fb (unsigned int x);

/**
 * @brief 浮点字节到整数转换：将浮点数的字节表示转换回整数
 * 
 * luaO_int2fb的逆操作，用于从紧凑表示恢复原始值。
 */
LUAI_FUNC int luaO_fb2int (int x);

/**
 * @brief 原始相等比较：比较两个TValue是否完全相等
 * 
 * 详细说明：
 * 这个函数执行深度的值比较，不涉及元方法。它比较值的类型和内容，
 * 确保两个TValue在所有方面都完全相同。
 * 
 * 比较规则：
 * - 类型必须完全匹配
 * - 对于数字，执行数值比较
 * - 对于字符串，比较字符串内容
 * - 对于对象，比较对象指针（引用相等）
 */
LUAI_FUNC int luaO_rawequalObj (const TValue *t1, const TValue *t2);

/**
 * @brief 字符串到数字转换：将字符串解析为Lua数字
 * 
 * 详细说明：
 * 这个函数尝试将字符串转换为lua_Number类型。它支持各种数字格式，
 * 包括整数、浮点数和科学记数法。
 * 
 * 参数：
 * - s: 要转换的字符串
 * - result: 输出参数，存储转换结果
 * 
 * 返回值：
 * - 非零：转换成功，result包含有效数字
 * - 零：转换失败，字符串不是有效数字
 */
LUAI_FUNC int luaO_str2d (const char *s, lua_Number *result);

/**
 * @brief 可变参数格式化字符串：使用va_list进行字符串格式化
 * 
 * 详细说明：
 * 这个函数类似于vsprintf，但专门为Lua设计。它支持Lua特有的
 * 格式化选项，并将结果推入Lua栈。
 * 
 * 参数：
 * - L: Lua状态机
 * - fmt: 格式化字符串
 * - argp: 可变参数列表
 * 
 * 返回值：
 * 指向格式化后字符串的指针（字符串已推入栈中）
 */
LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                       va_list argp);

/**
 * @brief 格式化字符串：便捷的字符串格式化函数
 * 
 * 这是luaO_pushvfstring的便捷包装，支持直接传递可变参数。
 */
LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);

/**
 * @brief 生成代码块标识：创建源文件的简短标识字符串
 * 
 * 详细说明：
 * 这个函数从源文件路径生成一个简短的标识字符串，用于错误消息
 * 和调试信息。它会适当截断长路径，保留最重要的部分。
 * 
 * 参数：
 * - out: 输出缓冲区
 * - source: 源文件路径
 * - len: 输出缓冲区大小
 * 
 * 用途：
 * - 错误报告：在错误消息中显示源文件信息
 * - 调试信息：提供函数和错误的位置信息
 * - 栈跟踪：在调用栈中显示文件信息
 */
LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);

#endif

