/*
** ====================================================================
** Lua 虚拟机状态管理头文件 (lstate.h)
** ====================================================================
**
** 模块职责:
** 本文件定义了 Lua 虚拟机的核心状态结构，包括全局状态和线程状态。
** 这些结构是整个 Lua 运行时系统的基础，管理着内存、栈、垃圾收集等关键资源。
**
** 主要功能:
** 1. [状态管理] 全局状态和线程状态的数据结构定义
** 2. [栈管理] 函数调用栈和值栈的组织结构
** 3. [垃圾收集] GC相关的对象管理和状态跟踪
** 4. [调用链] 函数调用信息和上下文管理
** 5. [字符串池] 全局字符串表的管理结构
** 6. [钩子系统] 调试钩子和事件处理机制
** 7. [错误处理] 异常恢复和错误传播机制
**
** 设计特点:
** - 分层架构：全局状态 + 多线程状态的两层设计
** - 资源共享：多个线程共享全局资源，减少内存占用
** - 增量GC：支持增量垃圾收集的状态跟踪
** - 栈式调用：基于栈的函数调用和参数传递
** - 统一对象：所有GC对象的统一管理接口
**
** 核心概念:
** - lua_State: 单个线程的执行状态
** - global_State: 所有线程共享的全局状态
** - CallInfo: 函数调用的上下文信息
** - stringtable: 全局字符串池
** - GCObject: 所有可回收对象的统一表示
**
** 重要说明:
** 此文件定义的结构直接影响 Lua 的性能和内存使用效率。
** 任何修改都需要考虑与垃圾收集、栈管理、调用约定的兼容性。
*/

// #ifndef lstate_h
// #define lstate_h

#include "lua.h"
#include "lobject.h"
#include "ltm.h"
#include "lzio.h"


/*
** ====================================================================
** [前向声明] 外部依赖和类型声明
** ====================================================================
*/

/*
** [外部依赖] 长跳转结构前向声明
**
** struct lua_longjmp 在 ldo.c 中定义，用于实现 Lua 的错误处理机制。
** 这里使用前向声明避免循环依赖，实际结构定义在实现文件中。
**
** 用途：
** - 错误恢复和异常处理
** - protected call 的实现基础
** - 协程切换中的状态保存
*/
struct lua_longjmp;

/*
** ====================================================================
** [快速访问] 状态结构快速访问宏
** ====================================================================
*/

/*
** [快速访问] 获取全局表宏
**
** 功能：快速获取线程的全局表引用
** @param L: lua_State* 线程状态指针
** @return: TValue* 全局表的值指针
**
** 实现说明：
** 每个线程都有自己的全局表副本（l_gt字段），这个宏提供
** 快速访问入口，避免函数调用的开销。
**
** 使用场景：
** - 全局变量的读写操作
** - 模块加载和环境设置
** - _G 表的访问实现
*/
#define gt(L)    (&L->l_gt)

/*
** [快速访问] 获取注册表宏
**
** 功能：快速获取全局注册表的引用
** @param L: lua_State* 线程状态指针
** @return: TValue* 注册表的值指针
**
** 实现说明：
** 注册表存储在全局状态中，所有线程共享同一个注册表。
** 这个宏通过 G(L) 获取全局状态，然后访问其中的注册表。
**
** 使用场景：
** - C API 中的引用存储
** - 模块私有数据保存
** - 跨调用的数据传递
*/
#define registry(L)    (&G(L)->l_registry)


/*
** ====================================================================
** [配置] 栈和调用管理的大小常量
** ====================================================================
*/

/*
** [栈管理] 额外栈空间常量
**
** 功能：定义处理元方法调用和其他额外操作所需的栈空间
** 值：5个栈槽
**
** 用途说明：
** - 元方法调用需要额外的参数空间
** - 错误处理时的临时值存储
** - 内部函数调用的安全边界
** - 栈溢出检查的缓冲区
**
** 设计考虑：
** 这个值是经过仔细计算的安全边界，确保在执行复杂操作
** （如元方法调用、错误处理）时不会发生栈溢出。
*/
#define EXTRA_STACK   5

/*
** [调用管理] 基本调用信息数组大小
**
** 功能：定义初始的 CallInfo 数组大小
** 值：8个调用信息条目
**
** 动态扩展：
** - 初始分配8个条目，满足大多数程序需求
** - 深度递归时自动扩展数组
** - 平衡内存使用和扩展开销
**
** 性能影响：
** - 较小值：节省内存但可能频繁扩展
** - 较大值：减少扩展但浪费内存
** - 8是经验值，适合大多数应用场景
*/
#define BASIC_CI_SIZE           8

/*
** [栈管理] 基本栈大小常量
**
** 功能：定义线程的初始栈大小
** 值：2 * LUA_MINSTACK
**
** 计算依据：
** - LUA_MINSTACK 是 Lua API 保证的最小栈空间
** - 乘以2提供额外的安全边界
** - 支持嵌套调用和临时值存储
**
** 扩展机制：
** - 栈不足时自动扩展
** - 按需分配，避免内存浪费
** - 保持栈指针的有效性
*/
#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)



/*
** ====================================================================
** [核心] 字符串表结构定义
** ====================================================================
*/

/*
** [核心] 全局字符串表结构
**
** 功能：实现 Lua 的字符串内部化（string interning）机制
** 
** 设计原理：
** Lua 中所有字符串都是内部化的，即相同内容的字符串在内存中
** 只存在一份拷贝。这个表存储了所有的字符串对象。
**
** 内部化优势：
** 1. 内存节省：相同字符串只存储一次
** 2. 比较优化：字符串比较变成指针比较
** 3. 哈希缓存：字符串哈希值只计算一次
** 4. 垃圾收集：统一管理所有字符串的生命周期
**
** 哈希策略：
** - 使用开放寻址哈希表
** - 动态调整表大小避免过度冲突
** - 支持增量的垃圾收集遍历
*/
typedef struct stringtable
{
    /*
    ** [存储] 哈希表数组
    **
    ** 存储指向 GCObject 的指针数组，每个元素要么是 NULL，
    ** 要么指向一个字符串对象。冲突通过开放寻址解决。
    */
    GCObject **hash;
    
    /*
    ** [统计] 已使用槽位数量
    **
    ** 记录哈希表中非空槽位的数量，用于：
    ** - 计算负载因子
    ** - 决定何时调整表大小
    ** - 垃圾收集时的遍历优化
    */
    lu_int32 nuse;
    
    /*
    ** [容量] 哈希表总大小
    **
    ** 哈希表数组的总长度，必须是2的幂次，便于：
    ** - 快速的模运算（使用位掩码）
    ** - 简化哈希值到索引的映射
    ** - 高效的表大小调整算法
    */
    int size;
} stringtable;


/*
** ====================================================================
** [核心] 函数调用信息结构定义
** ====================================================================
*/

/*
** [核心] 函数调用上下文信息
**
** 功能：存储每个函数调用的完整上下文信息
**
** 设计原理：
** 每当发生函数调用时，都会创建一个 CallInfo 结构来保存调用的
** 所有相关信息。这些信息形成一个调用栈，支持函数的嵌套调用、
** 递归调用和协程切换。
**
** 调用栈管理：
** - 调用时：分配新的 CallInfo，设置参数和环境
** - 执行中：维护当前函数的状态信息
** - 返回时：恢复调用者的状态，清理当前 CallInfo
** - 异常时：用于栈回溯和错误报告
**
** 内存布局：
** CallInfo 结构紧凑设计，减少调用开销和内存占用。
** 在频繁的函数调用中，这种优化非常重要。
*/
typedef struct CallInfo
{
    /*
    ** [栈管理] 当前函数的栈基地址
    **
    ** 指向当前函数在值栈中的起始位置。函数的所有局部变量
    ** 和临时值都相对于这个基地址进行索引。
    **
    ** 重要性：
    ** - 局部变量访问的基准点
    ** - 参数传递的起始位置
    ** - 栈指针计算的参考值
    */
    StkId base;
    
    /*
    ** [函数引用] 函数对象在栈中的位置
    **
    ** 指向被调用函数对象在栈中的位置。这个位置在调用过程中
    ** 保持不变，用于访问函数的元信息和上值。
    **
    ** 用途：
    ** - 访问函数的原型信息
    ** - 获取函数的上值列表
    ** - 区分 Lua 函数和 C 函数
    */
    StkId func;
    
    /*
    ** [栈管理] 当前栈顶位置
    **
    ** 指向当前函数栈空间的顶部，即下一个可用的栈位置。
    ** 这个值在函数执行过程中动态变化。
    **
    ** 动态特性：
    ** - 压入值时栈顶上移
    ** - 弹出值时栈顶下移
    ** - 函数调用时作为参数传递区域的边界
    */
    StkId top;
    
    /*
    ** [执行状态] 保存的程序计数器
    **
    ** 对于 Lua 函数，保存当前执行到的字节码指令位置。
    ** 对于 C 函数，这个字段通常不使用。
    **
    ** 关键作用：
    ** - 函数挂起时保存执行位置
    ** - 协程切换时的状态保存
    ** - 错误报告中的位置信息
    ** - 调试器的断点和单步执行
    */
    const Instruction *savedpc;
    
    /*
    ** [返回管理] 期望的返回值数量
    **
    ** 记录调用者期望从这个函数获得多少个返回值。
    ** 这个信息用于控制返回值的数量和栈的清理。
    **
    ** 特殊值：
    ** - LUA_MULTRET：接受所有返回值
    ** - 正整数：期望的具体返回值数量
    ** - 0：不需要返回值
    */
    int nresults;
    
    /*
    ** [优化] 尾调用计数
    **
    ** 记录在当前调用条目下执行的尾调用数量。
    ** 尾调用优化会复用当前栈帧，不增加调用深度。
    **
    ** 统计意义：
    ** - 调试时显示真实的调用层次
    ** - 性能分析中的尾调用优化统计
    ** - 错误报告中的调用链重建
    */
    int tailcalls;
} CallInfo;



/*
** ====================================================================
** [实用] 调用信息快速访问宏
** ====================================================================
*/

/*
** [快速访问] 获取当前函数宏
**
** 功能：从线程状态中获取当前正在执行的函数对象
** @param L: lua_State* 线程状态指针
** @return: Closure* 当前函数的闭包指针
**
** 实现说明：
** 通过当前调用信息（L->ci）的 func 字段获取函数，然后使用
** clvalue 宏将栈值转换为闭包指针。
**
** 使用场景：
** - 获取当前函数的上值
** - 检查函数类型（Lua函数 vs C函数）
** - 访问函数的原型信息
*/
#define curr_func(L)    (clvalue(L->ci->func))

/*
** [实用] 从调用信息获取函数宏
**
** 功能：从指定的调用信息中获取函数对象
** @param ci: CallInfo* 调用信息指针
** @return: Closure* 函数的闭包指针
**
** 实现说明：
** 类似 curr_func，但操作指定的调用信息而非当前调用信息。
** 用于遍历调用栈或操作特定调用层级。
**
** 使用场景：
** - 调用栈遍历
** - 错误报告中的函数信息收集
** - 调试器的栈帧分析
*/
#define ci_func(ci)     (clvalue((ci)->func))

/*
** [类型检查] 检查函数是否为Lua函数宏
**
** 功能：判断调用信息中的函数是否为Lua函数（非C函数）
** @param ci: CallInfo* 调用信息指针
** @return: int 非零表示是Lua函数，0表示是C函数
**
** 实现原理：
** C函数的 isC 标志为真，Lua函数的 isC 标志为假。
** 通过取反操作，将结果转换为更直观的布尔值。
**
** 重要性：
** - Lua函数和C函数的处理方式不同
** - 影响栈管理、错误处理、调试等多个方面
** - 是虚拟机执行逻辑的重要分支点
*/
#define f_isLua(ci)     (!ci_func(ci)->c.isC)

/*
** [类型检查] 综合的Lua函数检查宏
**
** 功能：检查调用信息是否包含有效的Lua函数
** @param ci: CallInfo* 调用信息指针
** @return: int 非零表示是有效的Lua函数调用
**
** 双重检查：
** 1. ttisfunction：确保栈值确实是函数类型
** 2. f_isLua：确保函数是Lua函数而非C函数
**
** 安全性：
** 这种双重检查确保了类型安全，避免了在错误的调用信息
** 上执行Lua特定的操作。
**
** 使用场景：
** - 虚拟机指令执行前的类型验证
** - 调试器的安全检查
** - 错误处理中的状态验证
*/
#define isLua(ci)       (ttisfunction((ci)->func) && f_isLua(ci))


/*
** ====================================================================
** [核心] 全局状态结构定义
** ====================================================================
*/

/*
** [核心] 全局状态结构
**
** 功能：存储所有线程共享的全局资源和状态信息
**
** 设计理念：
** Lua 支持多线程（协程），但所有线程共享某些全局资源，如：
** - 字符串池
** - 内存分配器
** - 垃圾收集器状态
** - 全局注册表
** - 元表信息
**
** 生命周期：
** 全局状态在 Lua 主状态创建时建立，在所有相关线程销毁后释放。
** 它是整个 Lua 虚拟机实例的根对象。
**
** 线程安全：
** 注意：Lua 本身不是线程安全的，多个操作系统线程不应同时
** 操作同一个全局状态，除非有适当的同步机制。
*/
typedef struct global_State
{
    /*
    ** ====================================================================
    ** [字符串管理] 全局字符串池
    ** ====================================================================
    */
    
    /*
    ** [字符串] 全局字符串哈希表
    **
    ** 存储所有内部化字符串的哈希表。Lua 中的字符串都是内部化的，
    ** 相同内容的字符串在内存中只存在一份。
    **
    ** 内部化优势：
    ** - 内存节省：避免重复字符串
    ** - 比较优化：字符串比较变成指针比较
    ** - 哈希缓存：每个字符串只计算一次哈希值
    */
    stringtable strt;
    
    /*
    ** ====================================================================
    ** [内存管理] 内存分配和管理
    ** ====================================================================
    */
    
    /*
    ** [内存] 内存重分配函数指针
    **
    ** 指向用户提供的内存分配函数，所有内存操作都通过此函数。
    ** 这种设计允许用户自定义内存管理策略。
    **
    ** 函数签名：void* (*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize)
    ** - ud: 用户数据指针
    ** - ptr: 要重分配的内存指针（NULL表示新分配）
    ** - osize: 原始大小
    ** - nsize: 新大小（0表示释放）
    */
    lua_Alloc frealloc;
    
    /*
    ** [内存] 内存分配器的用户数据
    **
    ** 传递给内存分配函数的用户数据指针。允许内存分配器
    ** 维护自己的状态信息。
    */
    void *ud;
    
    /*
    ** ====================================================================
    ** [垃圾收集] GC状态和对象管理
    ** ====================================================================
    */
    
    /*
    ** [GC] 当前白色标记
    **
    ** 垃圾收集器使用三色标记算法：
    ** - 白色：未访问的对象（候选回收对象）
    ** - 灰色：已访问但子对象未全部访问的对象
    ** - 黑色：已访问且子对象全部访问的对象
    **
    ** 当前白色在每次GC周期中交替，用于区分新旧对象。
    */
    lu_byte currentwhite;
    
    /*
    ** [GC] 垃圾收集器当前状态
    **
    ** GC状态机的当前状态，包括：
    ** - GCSpause: 暂停状态，等待下一轮GC
    ** - GCSpropagate: 标记传播阶段
    ** - GCSsweepstring: 清扫字符串阶段
    ** - GCSsweep: 清扫其他对象阶段
    ** - GCSfinalize: 最终化阶段
    */
    lu_byte gcstate;
    
    /*
    ** [GC] 字符串表清扫位置
    **
    ** 在增量垃圾收集中，记录字符串表清扫的当前位置。
    ** 允许GC在多个步骤中完成字符串的清扫工作。
    */
    int sweepstrgc;
    
    /*
    ** [GC] 所有可回收对象的根链表
    **
    ** 所有需要垃圾收集的对象都链接在这个链表中。
    ** 这是GC遍历所有对象的起点。
    */
    GCObject *rootgc;
    
    /*
    ** [GC] 对象清扫的当前位置
    **
    ** 在增量垃圾收集中，记录对象清扫的当前位置。
    ** 指向 rootgc 链表中当前正在清扫的位置。
    */
    GCObject **sweepgc;
    
    /*
    ** [GC] 灰色对象链表
    **
    ** 存储所有灰色对象的链表。灰色对象是已经被标记但其
    ** 引用的对象还没有全部被标记的对象。
    */
    GCObject *gray;
    
    /*
    ** [GC] 需要重新扫描的对象链表
    **
    ** 某些对象（如弱表）在标记阶段可能需要多次扫描，
    ** 这个链表存储这些需要原子处理的对象。
    */
    GCObject *grayagain;
    
    /*
    ** [GC] 弱引用表链表
    **
    ** 存储所有包含弱引用的表。这些表需要特殊处理，
    ** 在标记阶段结束后清理无效的弱引用。
    */
    GCObject *weak;
    
    /*
    ** [GC] 待最终化的用户数据链表
    **
    ** 存储需要调用 __gc 元方法的用户数据对象。
    ** 这些对象在垃圾收集后需要执行清理代码。
    */
    GCObject *tmudata;
    
    /*
    ** ====================================================================
    ** [缓冲管理] 临时缓冲区
    ** ====================================================================
    */
    
    /*
    ** [缓冲] 字符串连接临时缓冲区
    **
    ** 用于字符串连接操作的动态缓冲区。避免在字符串连接
    ** 过程中频繁的内存分配，提高性能。
    */
    Mbuffer buff;
    
    /*
    ** ====================================================================
    ** [GC控制] 垃圾收集控制参数
    ** ====================================================================
    */
    
    /*
    ** [GC] 垃圾收集阈值
    **
    ** 当分配的内存超过此阈值时，触发下一轮垃圾收集。
    ** 动态调整以平衡内存使用和GC开销。
    */
    lu_mem GCthreshold;
    
    /*
    ** [GC] 当前总分配字节数
    **
    ** 记录通过 Lua 内存分配器分配的总内存量。
    ** 用于内存统计和GC触发条件判断。
    */
    lu_mem totalbytes;
    
    /*
    ** [GC] 实际使用内存的估计值
    **
    ** 估计当前实际使用的内存量（排除垃圾对象）。
    ** 用于更精确的GC调度和内存统计。
    */
    lu_mem estimate;
    
    /*
    ** [GC] 垃圾收集债务
    **
    ** 记录GC"落后进度"的程度。当程序分配内存的速度
    ** 超过GC清理的速度时，债务会增加。
    */
    lu_mem gcdept;
    
    /*
    ** [GC] 垃圾收集暂停参数
    **
    ** 控制连续GC周期之间的暂停时间。较大的值意味着
    ** 更少的GC频率但更高的内存使用。
    */
    int gcpause;
    
    /*
    ** [GC] 垃圾收集步进倍数
    **
    ** 控制增量GC的"粒度"。较大的值意味着每次GC步骤
    ** 做更多工作，但可能导致更明显的延迟。
    */
    int gcstepmul;
    
    /*
    ** ====================================================================
    ** [错误处理] 全局错误处理
    ** ====================================================================
    */
    
    /*
    ** [错误] 恐慌函数指针
    **
    ** 当发生无法处理的错误时调用的函数。这是最后的
    ** 错误处理机制，通常用于记录错误并终止程序。
    */
    lua_CFunction panic;
    
    /*
    ** ====================================================================
    ** [全局资源] 共享的全局资源
    ** ====================================================================
    */
    
    /*
    ** [注册表] 全局注册表
    **
    ** 一个特殊的表，用于存储需要在C代码和Lua代码之间
    ** 共享的数据。所有线程共享同一个注册表。
    */
    TValue l_registry;
    
    /*
    ** [线程] 主线程引用
    **
    ** 指向主线程（第一个创建的线程）的指针。主线程
    ** 有特殊的地位，它的生命周期决定整个Lua状态的生命周期。
    */
    struct lua_State *mainthread;
    
    /*
    ** [上值] 所有开放上值的链表头
    **
    ** 双向链表的头节点，链接所有当前开放的上值。
    ** 开放上值是指向栈上变量的上值，需要特殊管理。
    */
    UpVal uvhead;
    
    /*
    ** [元表] 基本类型的元表数组
    **
    ** 存储所有基本类型（数字、字符串、表等）的元表。
    ** 数组索引对应 TValue 的类型标签。
    */
    struct Table *mt[NUM_TAGS];
    
    /*
    ** [元方法] 标签方法名称数组
    **
    ** 存储所有元方法名称的字符串。这些字符串在系统
    ** 初始化时创建，避免运行时的重复创建和查找。
    */
    TString *tmname[TM_N];
} global_State;


/*
** ====================================================================
** [核心] 线程状态结构定义
** ====================================================================
*/

/*
** [核心] Lua 线程状态结构
**
** 功能：表示单个 Lua 线程（协程）的完整执行状态
**
** 设计理念：
** lua_State 是 Lua 中线程的完整表示。每个线程都有独立的：
** - 执行栈
** - 调用栈
** - 程序计数器
** - 局部状态
**
** 但所有线程共享全局状态中的资源。这种设计支持轻量级的
** 协程实现，允许在多个执行上下文之间高效切换。
**
** 内存管理：
** lua_State 本身是一个 GC 对象，具有 CommonHeader。
** 这意味着线程可以被垃圾收集，支持自动的资源清理。
**
** 生命周期：
** - 创建：通过 luaE_newthread 或协程API创建
** - 执行：运行字节码或C函数
** - 挂起：保存状态，等待恢复
** - 销毁：由垃圾收集器自动回收
*/
struct lua_State
{
    /*
    ** [GC头部] 垃圾收集通用头部
    **
    ** 包含垃圾收集所需的元信息：
    ** - 对象类型标记
    ** - GC标记位
    ** - 链表指针
    ** - 其他GC相关标志
    */
    CommonHeader;
    
    /*
    ** ====================================================================
    ** [执行状态] 线程执行状态信息
    ** ====================================================================
    */
    
    /*
    ** [状态] 线程当前状态
    **
    ** 记录线程的当前执行状态：
    ** - LUA_OK: 正常状态
    ** - LUA_YIELD: 已挂起（协程）
    ** - LUA_ERRRUN: 运行时错误
    ** - LUA_ERRSYNTAX: 语法错误
    ** - LUA_ERRMEM: 内存错误
    ** - LUA_ERRERR: 错误处理中的错误
    */
    lu_byte status;
    
    /*
    ** ====================================================================
    ** [栈管理] 值栈管理
    ** ====================================================================
    */
    
    /*
    ** [栈] 当前栈顶指针
    **
    ** 指向栈中第一个空闲位置。这是栈操作的关键指针：
    ** - 压栈：在top位置存储值，然后top++
    ** - 出栈：top--，然后访问top位置的值
    ** - 边界：top必须在stack和stack_last之间
    */
    StkId top;
    
    /*
    ** [栈] 当前函数基地址
    **
    ** 指向当前函数在栈中的基地址。所有局部变量都相对于
    ** 这个地址进行索引。在函数调用时会发生变化。
    */
    StkId base;
    
    /*
    ** [共享] 全局状态指针
    **
    ** 指向所有线程共享的全局状态。通过这个指针访问：
    ** - 内存分配器
    ** - 垃圾收集器
    ** - 字符串表
    ** - 全局注册表
    ** - 元表信息
    */
    global_State *l_G;
    
    /*
    ** ====================================================================
    ** [调用管理] 函数调用栈管理
    ** ====================================================================
    */
    
    /*
    ** [调用] 当前调用信息指针
    **
    ** 指向当前函数的调用信息。调用信息包含函数的所有
    ** 上下文，如栈基地址、返回值要求等。
    */
    CallInfo *ci;
    
    /*
    ** [执行] 保存的程序计数器
    **
    ** 当前函数的程序计数器。对于Lua函数，指向下一条
    ** 要执行的字节码指令。对于C函数，通常不使用。
    */
    const Instruction *savedpc;
    
    /*
    ** [栈] 栈的最后可用位置
    **
    ** 指向栈的最后一个可用位置。用于栈溢出检查：
    ** 当top接近stack_last时，需要扩展栈空间。
    */
    StkId stack_last;
    
    /*
    ** [栈] 栈的基地址
    **
    ** 指向整个栈空间的起始位置。栈是一个连续的内存区域，
    ** 从stack开始，到stack_last结束。
    */
    StkId stack;
    
    /*
    ** [调用] 调用信息数组的结束位置
    **
    ** 指向调用信息数组末尾之后的位置。用于检查调用栈
    ** 是否需要扩展。
    */
    CallInfo *end_ci;
    
    /*
    ** [调用] 调用信息数组的基地址
    **
    ** 指向调用信息数组的起始位置。调用信息数组存储了
    ** 所有嵌套调用的上下文信息。
    */
    CallInfo *base_ci;
    
    /*
    ** ====================================================================
    ** [容量管理] 栈和调用栈的容量信息
    ** ====================================================================
    */
    
    /*
    ** [容量] 值栈的当前大小
    **
    ** 记录栈数组的当前容量。当栈空间不足时，按需扩展
    ** 到更大的容量。
    */
    int stacksize;
    
    /*
    ** [容量] 调用信息数组的大小
    **
    ** 记录调用信息数组的当前容量。深度递归时可能需要
    ** 扩展这个数组。
    */
    int size_ci;
    
    /*
    ** ====================================================================
    ** [调用控制] C调用计数和控制
    ** ====================================================================
    */
    
    /*
    ** [计数] 嵌套C调用计数
    **
    ** 记录当前的C函数调用深度。用于：
    ** - 检测过深的递归
    ** - 协程切换时的状态保存
    ** - 错误处理中的调用链分析
    */
    unsigned short nCcalls;
    
    /*
    ** [恢复] 协程恢复时的C调用基数
    **
    ** 当协程被挂起又恢复时，记录恢复时的C调用深度基准。
    ** 用于正确计算相对的调用深度。
    */
    unsigned short baseCcalls;
    
    /*
    ** ====================================================================
    ** [调试支持] 钩子和调试功能
    ** ====================================================================
    */
    
    /*
    ** [钩子] 钩子事件掩码
    **
    ** 位掩码，指定启用哪些调试钩子：
    ** - LUA_MASKCALL: 函数调用钩子
    ** - LUA_MASKRET: 函数返回钩子
    ** - LUA_MASKLINE: 行钩子
    ** - LUA_MASKCOUNT: 计数钩子
    */
    lu_byte hookmask;
    
    /*
    ** [钩子] 是否允许钩子
    **
    ** 控制钩子的启用/禁用。某些情况下（如错误处理）
    ** 需要临时禁用钩子避免递归调用。
    */
    lu_byte allowhook;
    
    /*
    ** [钩子] 基础钩子计数
    **
    ** 计数钩子的基准值。当hookcount降到0时触发钩子，
    ** 然后重置为basehookcount。
    */
    int basehookcount;
    
    /*
    ** [钩子] 当前钩子计数
    **
    ** 距离下次计数钩子触发的指令数。每执行一条指令
    ** 递减1，到0时触发钩子。
    */
    int hookcount;
    
    /*
    ** [钩子] 钩子函数指针
    **
    ** 指向用户设置的钩子函数。当钩子事件发生时，
    ** 调用这个函数进行调试处理。
    */
    lua_Hook hook;
    
    /*
    ** ====================================================================
    ** [环境管理] 全局环境和局部环境
    ** ====================================================================
    */
    
    /*
    ** [环境] 线程的全局表
    **
    ** 每个线程都有自己的全局表副本。这支持线程级别的
    ** 环境隔离，不同线程可以有不同的全局变量空间。
    */
    TValue l_gt;
    
    /*
    ** [环境] 环境变量的临时存储
    **
    ** 临时存储环境相关的值，用于环境切换和恢复操作。
    */
    TValue env;
    
    /*
    ** ====================================================================
    ** [上值管理] 开放上值和GC管理
    ** ====================================================================
    */
    
    /*
    ** [上值] 此栈中开放上值的链表
    **
    ** 链表包含所有指向当前栈上变量的开放上值。当栈上的
    ** 变量离开作用域时，需要将开放上值转换为闭合上值。
    */
    GCObject *openupval;
    
    /*
    ** [GC] 垃圾收集链表指针
    **
    ** 将此线程链接到垃圾收集器的对象链表中。用于GC
    ** 遍历和标记过程。
    */
    GCObject *gclist;
    
    /*
    ** ====================================================================
    ** [错误处理] 异常处理和错误恢复
    ** ====================================================================
    */
    
    /*
    ** [错误] 当前错误恢复点
    **
    ** 指向当前的错误恢复点（longjmp缓冲区）。当发生错误时，
    ** 通过longjmp跳转到这个恢复点进行错误处理。
    */
    struct lua_longjmp *errorJmp;
    
    /*
    ** [错误] 当前错误处理函数
    **
    ** 栈索引，指向当前活动的错误处理函数。当发生错误时，
    ** 调用这个函数进行错误处理和报告。
    */
    ptrdiff_t errfunc;
};


/*
** ====================================================================
** [实用] 全局状态快速访问宏
** ====================================================================
*/

/*
** [快速访问] 从线程状态获取全局状态宏
**
** 功能：快速获取线程关联的全局状态指针
** @param L: lua_State* 线程状态指针
** @return: global_State* 全局状态指针
**
** 使用频率：
** 这是最常用的宏之一，几乎所有需要访问全局资源的操作
** 都会使用它。高频使用使得内联展开特别重要。
**
** 使用场景：
** - 内存分配操作
** - 垃圾收集相关操作
** - 字符串表访问
** - 全局注册表访问
*/
#define G(L)    (L->l_G)

/*
** ====================================================================
** [核心] 垃圾收集对象统一表示
** ====================================================================
*/

/*
** [核心] 所有可回收对象的联合体
**
** 功能：为所有需要垃圾收集的对象提供统一的表示
**
** 设计目标：
** 1. 类型统一：所有GC对象都可以用GCObject*表示
** 2. 内存对齐：确保所有对象类型的正确内存对齐
** 3. 遍历支持：GC遍历时可以统一处理所有对象类型
** 4. 大小计算：便于计算不同对象类型的内存占用
**
** 垃圾收集原理：
** 所有可回收的对象都以GCObject的形式链接在GC链表中。
** 垃圾收集器通过遍历这些链表来标记和清扫对象。
**
** 类型安全：
** 虽然使用联合体统一表示，但通过GC头部的类型标记
** 可以安全地确定对象的实际类型。
*/
union GCObject
{
    /*
    ** [头部] GC对象通用头部
    **
    ** 包含所有GC对象共同的元信息：
    ** - 类型标记（tt字段）
    ** - GC标记位
    ** - 链表指针（next字段）
    ** - 其他GC控制标志
    */
    GCheader gch;
    
    /*
    ** [字符串] 字符串对象表示
    **
    ** 包含字符串的完整信息：
    ** - 字符串内容
    ** - 长度信息
    ** - 哈希值缓存
    ** - 字符串类型（短/长字符串）
    */
    union TString ts;
    
    /*
    ** [用户数据] 用户数据对象表示
    **
    ** 包含用户数据的信息：
    ** - 数据大小
    ** - 用户环境表
    ** - 元表引用
    ** - 实际数据内容
    */
    union Udata u;
    
    /*
    ** [函数] 闭包对象表示
    **
    ** 包含函数/闭包信息：
    ** - 函数类型（Lua函数/C函数）
    ** - 函数原型或C函数指针
    ** - 上值数组
    ** - 环境表
    */
    union Closure cl;
    
    /*
    ** [表] 表对象表示
    **
    ** 包含表的完整结构：
    ** - 数组部分
    ** - 哈希部分
    ** - 元表引用
    ** - 弱引用标志
    */
    struct Table h;
    
    /*
    ** [原型] 函数原型对象表示
    **
    ** 包含Lua函数的原型信息：
    ** - 字节码指令数组
    ** - 常量表
    ** - 局部变量信息
    ** - 调试信息
    */
    struct Proto p;
    
    /*
    ** [上值] 上值对象表示
    **
    ** 包含上值的信息：
    ** - 值存储位置
    ** - 开放/闭合状态
    ** - 链表指针
    */
    struct UpVal uv;
    
    /*
    ** [线程] 线程对象表示
    **
    ** 线程本身也是GC对象，包含：
    ** - 完整的lua_State结构
    ** - 线程的所有状态信息
    */
    struct lua_State th;
};


/*
** ====================================================================
** [实用] GCObject 类型转换宏
** ====================================================================
**
** 以下宏提供了安全的类型转换功能，将通用的 GCObject 指针
** 转换为特定类型的对象指针。每个宏都包含类型检查，确保转换的安全性。
*/

/*
** [转换] GCObject 到字符串对象的原始转换
**
** 功能：将 GCObject 转换为 TString 联合体指针
** @param o: GCObject* 源对象指针
** @return: union TString* 字符串联合体指针
**
** 安全检查：
** 使用 check_exp 宏验证对象类型确实是 LUA_TSTRING，
** 只有在调试模式下进行检查，发布版本中优化为直接转换。
*/
#define rawgco2ts(o)    check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))

/*
** [转换] GCObject 到字符串值的转换
**
** 功能：将 GCObject 转换为字符串值结构指针
** @param o: GCObject* 源对象指针
** @return: TString* 字符串值结构指针
**
** 实现：
** 先调用 rawgco2ts 获取联合体指针，然后访问其 tsv 字段
** 获取实际的字符串值结构。
*/
#define gco2ts(o)       (&rawgco2ts(o)->tsv)

/*
** [转换] GCObject 到用户数据对象的原始转换
**
** 功能：将 GCObject 转换为 Udata 联合体指针
** @param o: GCObject* 源对象指针
** @return: union Udata* 用户数据联合体指针
**
** 类型验证：
** 确保对象类型是 LUA_TUSERDATA，保证转换的安全性。
*/
#define rawgco2u(o)     check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))

/*
** [转换] GCObject 到用户数据值的转换
**
** 功能：将 GCObject 转换为用户数据值结构指针
** @param o: GCObject* 源对象指针
** @return: Udata* 用户数据值结构指针
**
** 用途：
** 访问用户数据的实际内容、大小信息和元表。
*/
#define gco2u(o)        (&rawgco2u(o)->uv)

/*
** [转换] GCObject 到闭包的转换
**
** 功能：将 GCObject 转换为闭包联合体指针
** @param o: GCObject* 源对象指针
** @return: union Closure* 闭包联合体指针
**
** 应用场景：
** - 函数调用时访问函数信息
** - 上值操作
** - 函数类型判断（Lua函数 vs C函数）
*/
#define gco2cl(o)       check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))

/*
** [转换] GCObject 到表的转换
**
** 功能：将 GCObject 转换为表结构指针
** @param o: GCObject* 源对象指针
** @return: Table* 表结构指针
**
** 使用频率：
** 表操作是 Lua 中最频繁的操作之一，这个宏的使用频率很高。
*/
#define gco2h(o)        check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))

/*
** [转换] GCObject 到函数原型的转换
**
** 功能：将 GCObject 转换为函数原型结构指针
** @param o: GCObject* 源对象指针
** @return: Proto* 函数原型结构指针
**
** 用途：
** - 访问函数的字节码
** - 获取常量表
** - 调试信息处理
*/
#define gco2p(o)        check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))

/*
** [转换] GCObject 到上值的转换
**
** 功能：将 GCObject 转换为上值结构指针
** @param o: GCObject* 源对象指针
** @return: UpVal* 上值结构指针
**
** 闭包管理：
** 用于闭包中上值的访问和管理。
*/
#define gco2uv(o)       check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))

/*
** [转换] 空安全的 GCObject 到上值转换
**
** 功能：将可能为 NULL 的 GCObject 转换为上值指针
** @param o: GCObject* 源对象指针（可以是 NULL）
** @return: UpVal* 上值结构指针
**
** 空值处理：
** 允许输入为 NULL，这在上值链表操作中很常见。
** 提供了额外的安全性检查。
*/
#define ngcotouv(o) \
    check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))

/*
** [转换] GCObject 到线程的转换
**
** 功能：将 GCObject 转换为线程状态结构指针
** @param o: GCObject* 源对象指针
** @return: lua_State* 线程状态指针
**
** 协程支持：
** 用于协程操作中的线程对象访问。
*/
#define gco2th(o)       check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))

/*
** [转换] 任意 Lua 对象到 GCObject 的转换
**
** 功能：将任意 Lua 对象指针转换为 GCObject 指针
** @param v: void* 任意对象指针
** @return: GCObject* GC对象指针
**
** 通用性：
** 这是反向转换，将具体类型的对象指针转换回通用的 GCObject。
** 主要用于垃圾收集器的对象管理。
**
** 注意：
** 这个转换假设输入对象确实是一个 GC 对象，调用者需要
** 确保这一点。
*/
#define obj2gco(v)      (cast(GCObject *, (v)))


/*
** ====================================================================
** [接口] 线程管理函数声明
** ====================================================================
*/

/*
** [管理] 新线程创建函数
**
** 功能：创建一个新的 Lua 线程（协程）
** @param L: lua_State* 父线程状态
** @return: lua_State* 新创建的线程状态指针
**
** 创建过程：
** 1. 分配新的 lua_State 结构
** 2. 初始化线程的所有字段
** 3. 创建独立的栈空间
** 4. 设置调用信息数组
** 5. 关联到全局状态
** 6. 注册到垃圾收集器
**
** 内存管理：
** - 新线程是 GC 对象，会被自动管理
** - 与父线程共享全局状态
** - 具有独立的执行栈和调用栈
**
** 使用场景：
** - 协程的底层实现
** - 并发任务的创建
** - 独立执行上下文的建立
**
** 注意事项：
** - 新线程初始状态为挂起
** - 需要通过适当的API启动执行
** - 线程间的数据共享需要谨慎处理
*/
LUAI_FUNC lua_State *luaE_newthread (lua_State *L);

/*
** [管理] 线程释放函数
**
** 功能：释放指定线程占用的所有资源
** @param L: lua_State* 当前线程状态（用于内存管理）
** @param L1: lua_State* 要释放的目标线程
**
** 释放过程：
** 1. 释放线程的栈空间
** 2. 释放调用信息数组
** 3. 清理开放的上值
** 4. 断开GC链接
** 5. 释放线程结构本身
**
** 调用时机：
** - 垃圾收集器清理死线程时
** - 显式关闭线程时
** - 虚拟机关闭时的清理过程
**
** 安全性：
** - 确保目标线程已经不可达
** - 处理与其他对象的引用关系
** - 避免释放正在使用的线程
**
** 内存管理：
** - 通过参数L的内存分配器进行释放
** - 更新全局状态的内存统计
** - 可能触发进一步的垃圾收集
*/
LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);

//#endif