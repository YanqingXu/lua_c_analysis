/*
** ====================================================================
** Lua 代码生成器头文件 (lcode.h)
** ====================================================================
**
** 版本信息: $Id: lcode.h,v 1.48.1.1 2007/12/27 13:02:25 roberto Exp $
** 版权声明: 参见 lua.h 中的版权信息
**
** 模块职责:
** 本文件定义了 Lua 编译器的代码生成器接口，负责将解析后的语法树
** 转换为 Lua 虚拟机可执行的字节码指令序列。
**
** 主要功能:
** 1. [指令生成] 各种虚拟机指令的生成接口
** 2. [表达式处理] 表达式到字节码的转换机制
** 3. [寄存器管理] 虚拟寄存器的分配和释放
** 4. [常量管理] 常量表的构建和索引
** 5. [跳转处理] 条件跳转和无条件跳转的管理
** 6. [补丁系统] 前向引用和回填机制
** 7. [运算符处理] 二元和一元运算符的代码生成
** 8. [控制流] 函数调用、返回、循环等控制结构
**
** 设计特点:
** - 单遍生成：直接从语法分析生成最终字节码
** - 寄存器优化：高效的虚拟寄存器分配策略
** - 常量池化：常量的统一管理和重用
** - 延迟绑定：支持前向引用的补丁机制
** - 表达式优化：常量折叠和简单优化
**
** 核心概念:
** - FuncState: 函数编译状态，包含当前函数的所有编译信息
** - expdesc: 表达式描述符，表示表达式的类型和位置
** - 补丁链表: 用于处理前向跳转的回填机制
** - RK编码: 寄存器/常量的统一编码方式
**
** 重要说明:
** 代码生成器是编译器的核心组件，直接影响生成字节码的质量和效率。
** 良好的代码生成可以显著提升 Lua 程序的执行性能。
*/

#ifndef lcode_h
#define lcode_h

#include "llex.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"


/*
** ====================================================================
** [核心] 跳转和补丁系统常量
** ====================================================================
*/

/*
** [补丁] 补丁链表结束标记
**
** 功能：标记补丁链表的结束
** 值：-1
**
** 设计原理：
** 在代码生成过程中，经常需要处理前向引用，即在指令生成时
** 跳转目标还未确定。补丁系统通过链表记录这些待回填的位置。
**
** 无效性验证：
** -1 既不是有效的绝对地址（指令索引必须非负），也不是有效的
** 链表链接（会导致元素链接到自身），因此可以安全地用作结束标记。
**
** 使用场景：
** - 条件跳转的前向引用
** - 循环结构的跳转处理
** - break 和 continue 语句的目标回填
** - 函数调用中的跳转优化
**
** 补丁链表机制：
** 1. 生成跳转指令时，如果目标未知，将当前指令位置加入补丁链表
** 2. 链表通过指令的参数字段进行链接
** 3. 确定目标时，遍历链表回填所有相关指令
** 4. NO_JUMP 表示链表结束
*/
#define NO_JUMP (-1)


/*
** ====================================================================
** [运算符] 二元运算符枚举定义
** ====================================================================
**
** 重要提示：如果修改此枚举的顺序，请搜索 "ORDER OPR" 来查找
** 需要同步更新的相关代码（如运算符优先级表、指令映射表等）。
*/

/*
** [运算符] 二元运算符类型
**
** 功能：定义所有支持的二元运算符类型
**
** 分类说明：
** 
** 1. 算术运算符：
**    - 基本算术运算，直接对应虚拟机指令
**    - 支持数字类型的运算和元方法扩展
**
** 2. 比较运算符：
**    - 关系比较运算，生成条件跳转指令
**    - 结果用于控制流而非值计算
**
** 3. 逻辑运算符：
**    - 短路求值的逻辑运算
**    - 通过跳转指令实现短路语义
**
** 4. 字符串运算符：
**    - 字符串连接运算
**    - 支持多操作数的高效连接
**
** 枚举顺序的重要性：
** - 算术运算符的顺序与虚拟机指令对应
** - 比较运算符按照指令生成的便利性排列
** - 逻辑运算符需要特殊的短路处理
*/
typedef enum BinOpr {
  /*
  ** 算术运算符组
  ** 
  ** 这些运算符直接对应虚拟机的算术指令，枚举值的顺序
  ** 与指令操作码的顺序保持一致，便于快速转换。
  */
  OPR_ADD,      /* + 加法运算 */
  OPR_SUB,      /* - 减法运算 */
  OPR_MUL,      /* * 乘法运算 */
  OPR_DIV,      /* / 除法运算 */
  OPR_MOD,      /* % 取模运算 */
  OPR_POW,      /* ^ 幂运算 */
  
  /*
  ** 字符串运算符
  ** 
  ** 字符串连接是特殊的运算符，支持多个操作数的连接，
  ** 编译器会进行特殊优化以提高连接效率。
  */
  OPR_CONCAT,   /* .. 字符串连接 */
  
  /*
  ** 比较运算符组
  ** 
  ** 比较运算符生成条件跳转指令，不产生值。
  ** 顺序安排考虑了指令生成的便利性。
  */
  OPR_NE,       /* ~= 不等于比较 */
  OPR_EQ,       /* == 等于比较 */
  OPR_LT,       /* < 小于比较 */
  OPR_LE,       /* <= 小于等于比较 */
  OPR_GT,       /* > 大于比较 */
  OPR_GE,       /* >= 大于等于比较 */
  
  /*
  ** 逻辑运算符组
  ** 
  ** 逻辑运算符使用短路求值，通过条件跳转实现。
  ** 与比较运算符不同，逻辑运算符会产生值。
  */
  OPR_AND,      /* and 逻辑与 */
  OPR_OR,       /* or 逻辑或 */
  
  /*
  ** 特殊标记
  ** 
  ** 用于表示无效的二元运算符，作为枚举的边界值。
  */
  OPR_NOBINOPR  /* 无二元运算符 */
} BinOpr;


/*
** ====================================================================
** [运算符] 一元运算符枚举定义
** ====================================================================
*/

/*
** [运算符] 一元运算符类型
**
** 功能：定义所有支持的一元运算符类型
**
** 特点说明：
** 一元运算符相比二元运算符更简单，直接作用于单个操作数。
** 每个运算符都有对应的虚拟机指令或特殊处理逻辑。
**
** 实现方式：
** - 数值运算符：直接生成对应的虚拟机指令
** - 逻辑运算符：通过条件跳转实现
** - 长度运算符：调用对象的长度方法或元方法
*/
typedef enum UnOpr { 
  /*
  ** [算术] 一元负号运算符
  ** 
  ** 功能：对数值取负
  ** 对应指令：OP_UNM
  ** 类型支持：主要用于数字，也可通过__unm元方法扩展到其他类型
  ** 
  ** 语法：-expression
  ** 示例：-5, -x, -(a + b)
  */
  OPR_MINUS,
  
  /*
  ** [逻辑] 逻辑非运算符
  ** 
  ** 功能：对布尔值取反
  ** 对应指令：OP_NOT
  ** 语义：只有 nil 和 false 为假，其他所有值为真
  ** 
  ** 语法：not expression
  ** 示例：not true, not nil, not 0
  ** 
  ** 重要特性：
  ** - 总是返回 true 或 false
  ** - 不调用元方法
  ** - 是 Lua 中唯一不可重载的运算符
  */
  OPR_NOT,
  
  /*
  ** [实用] 长度运算符
  ** 
  ** 功能：获取对象的长度
  ** 对应指令：OP_LEN
  ** 类型支持：
  ** - 字符串：返回字节长度
  ** - 表：返回数组部分的长度
  ** - 其他类型：通过__len元方法
  ** 
  ** 语法：#expression
  ** 示例：#"hello", #table, #userdata
  ** 
  ** 长度定义：
  ** - 字符串长度是确定的字节数
  ** - 表长度遵循复杂的定义规则
  ** - 用户数据长度由元方法决定
  */
  OPR_LEN,
  
  /*
  ** [标记] 无一元运算符
  ** 
  ** 功能：表示无效的一元运算符
  ** 用途：作为枚举的边界值和错误标记
  */
  OPR_NOUNOPR
} UnOpr;


/*
** ====================================================================
** [实用] 代码生成工具宏
** ====================================================================
*/

/*
** [实用] 获取指令码宏
**
** 功能：从表达式描述符中获取对应的指令码
** @param fs: FuncState* 函数状态指针
** @param e: expdesc* 表达式描述符指针
** @return: Instruction 指令码
**
** 使用条件：
** 只有当表达式类型为 VRELOCABLE 时才能使用此宏，
** 即表达式对应一条已生成但可能需要重定位的指令。
**
** 实现原理：
** 通过表达式的 info 字段（包含指令索引）直接访问
** 函数原型中的指令数组。
**
** 应用场景：
** - 指令优化和合并
** - 跳转目标的回填
** - 指令参数的修改
*/
#define getcode(fs,e)	((fs)->f->code[(e)->u.s.info])

/*
** [实用] 生成 AsBx 格式指令宏
**
** 功能：生成带符号 Bx 参数的指令
** @param fs: FuncState* 函数状态指针
** @param o: OpCode 操作码
** @param A: int A 参数
** @param sBx: int 带符号的 Bx 参数
** @return: int 生成的指令索引
**
** 编码转换：
** 将带符号的 sBx 参数转换为无符号的 Bx 参数：
** unsigned_Bx = sBx + MAXARG_sBx
**
** 用途：
** - 跳转指令的生成（OP_JMP）
** - 循环控制指令（OP_FORLOOP, OP_FORPREP）
** - 其他需要相对地址的指令
**
** 优势：
** 简化了带符号参数指令的生成，隐藏了编码细节。
*/
#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)

/*
** [实用] 设置多返回值宏
**
** 功能：将表达式设置为接受多个返回值
** @param fs: FuncState* 函数状态指针
** @param e: expdesc* 表达式描述符指针
**
** 多返回值语义：
** 在 Lua 中，某些表达式可以返回多个值：
** - 函数调用
** - vararg 表达式（...）
** - 某些内建函数
**
** 实现原理：
** 调用 luaK_setreturns 并传入 LUA_MULTRET 常量，
** 表示接受所有可能的返回值。
**
** 使用场景：
** - 函数调用作为语句
** - 表达式列表的最后一个元素
** - 返回语句中的最后一个表达式
*/
#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)

/*
** ====================================================================
** [核心] 基础指令生成接口
** ====================================================================
*/

/*
** [指令生成] ABx 格式指令生成函数
**
** 功能：生成 ABx 格式的虚拟机指令
** @param fs: FuncState* 函数编译状态
** @param o: OpCode 操作码
** @param A: int A 参数（通常是目标寄存器）
** @param Bx: unsigned int Bx 参数（18位大参数）
** @return: int 生成指令在代码数组中的索引
**
** ABx 格式用途：
** - 常量加载指令（LOADK）
** - 全局变量访问（GETGLOBAL, SETGLOBAL）
** - 闭包创建指令（CLOSURE）
** - 其他需要大索引值的指令
**
** 参数范围：
** - A: 0-255（8位）
** - Bx: 0-262143（18位）
**
** 返回值：
** 返回新生成指令的索引，可用于后续的指令修改和跳转目标设置。
*/
LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);

/*
** [指令生成] ABC 格式指令生成函数
**
** 功能：生成 ABC 格式的虚拟机指令
** @param fs: FuncState* 函数编译状态
** @param o: OpCode 操作码
** @param A: int A 参数（通常是目标寄存器）
** @param B: int B 参数（第一源操作数）
** @param C: int C 参数（第二源操作数）
** @return: int 生成指令在代码数组中的索引
**
** ABC 格式用途：
** - 算术运算指令（ADD, SUB, MUL等）
** - 表操作指令（GETTABLE, SETTABLE）
** - 比较指令（EQ, LT, LE）
** - 函数调用指令（CALL）
** - 大多数三操作数指令
**
** 参数范围：
** - A: 0-255（8位）
** - B: 0-511（9位，支持RK编码）
** - C: 0-511（9位，支持RK编码）
**
** RK编码：
** B和C参数支持RK编码，可以表示寄存器或常量：
** - 0-255: 寄存器索引
** - 256-511: 常量索引（实际索引为值-256）
*/
LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);

/*
** ====================================================================
** [调试] 调试信息管理
** ====================================================================
*/

/*
** [调试] 修正行号信息函数
**
** 功能：为最后生成的指令设置正确的行号信息
** @param fs: FuncState* 函数编译状态
** @param line: int 源代码行号
**
** 调试信息的重要性：
** - 错误报告时显示准确的行号
** - 调试器设置断点和单步执行
** - 性能分析工具的代码定位
** - 堆栈跟踪的源码对应
**
** 使用时机：
** - 语句边界的指令生成后
** - 表达式跨行时的行号调整
** - 控制流指令的行号标记
**
** 实现原理：
** 更新函数原型的行号信息数组，建立指令位置到源码行号的映射。
*/
LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
/*
** ====================================================================
** [管理] 寄存器和栈管理
** ====================================================================
*/

/*
** [管理] nil 值初始化函数
**
** 功能：在指定寄存器范围内生成 nil 值初始化指令
** @param fs: FuncState* 函数编译状态
** @param from: int 起始寄存器编号
** @param n: int 寄存器数量
**
** 用途说明：
** - 局部变量的默认初始化
** - 数组或表的空位填充
** - 函数参数不足时的补充
** - 寄存器清理和重置
**
** 优化策略：
** - 连续的 nil 赋值会合并为单个 LOADNIL 指令
** - 减少指令数量，提高执行效率
** - 优化内存访问模式
*/
LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);

/*
** [管理] 寄存器预留函数
**
** 功能：预留指定数量的寄存器供后续使用
** @param fs: FuncState* 函数编译状态
** @param n: int 需要预留的寄存器数量
**
** 寄存器分配策略：
** - 栈式分配：寄存器按栈模式分配和释放
** - 最小化使用：避免不必要的寄存器占用
** - 生命周期管理：跟踪寄存器的使用周期
** - 重用优化：释放后的寄存器可被重新分配
**
** 应用场景：
** - 函数调用前的参数寄存器预留
** - 复杂表达式的临时寄存器分配
** - 循环变量的寄存器分配
** - 局部变量的寄存器分配
*/
LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);

/*
** [管理] 栈空间检查函数
**
** 功能：检查并确保有足够的栈空间可用
** @param fs: FuncState* 函数编译状态
** @param n: int 需要的额外栈空间大小
**
** 栈溢出保护：
** - 运行时栈大小限制检查
** - 防止递归调用导致的栈溢出
** - 确保函数调用和表达式计算的安全性
** - 提供优雅的错误处理机制
**
** 实现机制：
** - 编译时预估栈使用量
** - 插入必要的栈检查指令
** - 动态调整函数的最大栈需求
*/
LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);

/*
** ====================================================================
** [管理] 常量池管理
** ====================================================================
*/

/*
** [管理] 字符串常量索引获取
**
** 功能：获取字符串常量在常量池中的索引
** @param fs: FuncState* 函数编译状态
** @param s: TString* 字符串对象
** @return: int 字符串在常量池中的索引
**
** 字符串常量特点：
** - 字符串内部化：相同内容的字符串共享同一对象
** - 快速比较：通过指针比较而非内容比较
** - 内存优化：避免重复存储相同字符串
** - 垃圾回收：字符串对象的生命周期管理
**
** 应用场景：
** - 变量名和函数名的存储
** - 字符串字面量的处理
** - 表键的字符串索引
** - 元方法名称的存储
*/
LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);

/*
** [管理] 数字常量索引获取
**
** 功能：获取数字常量在常量池中的索引
** @param fs: FuncState* 函数编译状态
** @param r: lua_Number 数字值
** @return: int 数字在常量池中的索引
**
** 数字常量处理：
** - 整数和浮点数的统一表示
** - 数值精度的保持
** - 特殊值的处理（NaN, Infinity等）
** - 数值比较的优化
**
** 优化机制：
** - 相同数值的去重存储
** - 编译时数值运算折叠
** - 小整数的特殊优化
** - 常量传播和优化
*/
LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
/*
** ====================================================================
** [优化] 表达式处理和寄存器分配
** ====================================================================
*/

/*
** [优化] 表达式变量放电处理
**
** 功能：将表达式中的变量转换为实际值或寄存器引用
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
**
** 变量类型转换：
** - VUPVAL -> GETUPVAL 指令
** - VGLOBAL -> GETGLOBAL 指令  
** - VINDEXED -> GETTABLE 指令
** - VLOCAL -> 保持寄存器引用
** - VK -> LOADK 指令
**
** 放电过程：
** 1. 分析表达式的当前类型
** 2. 生成相应的加载指令
** 3. 更新表达式描述符为寄存器引用
** 4. 管理寄存器的分配和释放
**
** 优化考虑：
** - 避免不必要的寄存器拷贝
** - 合并相邻的内存访问操作
** - 减少临时寄存器的使用
*/
LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);

/*
** [优化] 表达式转换为任意寄存器
**
** 功能：将表达式结果存储到任意可用寄存器中
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
** @return: int 分配的寄存器编号
**
** 分配策略：
** - 优先重用已释放的寄存器
** - 避免不必要的数据移动
** - 考虑表达式的生命周期
** - 优化寄存器使用模式
**
** 返回值处理：
** - 表达式已在寄存器中：返回当前寄存器号
** - 表达式为常量：分配寄存器并加载常量
** - 表达式需要计算：分配寄存器执行计算
*/
LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);

/*
** [优化] 表达式转换为下一个寄存器
**
** 功能：将表达式结果存储到下一个可用寄存器中
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
**
** 栈式分配：
** - 按顺序分配寄存器，类似栈的 push 操作
** - 确保表达式列表的正确处理
** - 支持函数调用的参数传递
** - 维护寄存器分配的一致性
**
** 使用场景：
** - 函数调用参数的依次分配
** - 表达式列表的逐一处理
** - 赋值语句的右值处理
** - 表构造器的元素处理
*/
LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);

/*
** [优化] 表达式转换为值
**
** 功能：确保表达式有具体的值，但不一定在寄存器中
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
**
** 值类型处理：
** - 变量引用转换为值获取
** - 保持常量的常量性质
** - 处理条件表达式的真值
** - 优化不需要寄存器的情况
**
** 优化原理：
** - 避免将常量加载到寄存器
** - 延迟寄存器分配到真正需要时
** - 利用指令的 RK 编码减少寄存器使用
*/
LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);

/*
** [优化] 表达式转换为 RK 格式
**
** 功能：将表达式转换为 RK（寄存器或常量）格式
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
** @return: int RK 编码值
**
** RK 编码规则：
** - 0-255: 寄存器索引
** - 256-511: 常量索引（实际索引为值-256）
** - 常量范围：支持 256 个常量
** - 寄存器范围：支持 256 个寄存器
**
** 优化策略：
** - 常量值直接编码，避免寄存器分配
** - 寄存器值保持原有分配
** - 最大化利用指令的操作数编码能力
** - 减少内存访问和指令数量
*/
LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
/*
** ====================================================================
** [实用] 特殊表达式操作
** ====================================================================
*/

/*
** [实用] self 方法调用处理
**
** 功能：处理面向对象的 self 方法调用语法（obj:method）
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 对象表达式描述符
** @param key: expdesc* 方法名表达式描述符
**
** 语法转换：
** obj:method(args) 等价于 obj.method(obj, args)
**
** 实现步骤：
** 1. 计算对象表达式的值
** 2. 复制对象引用作为第一个参数
** 3. 获取对象的方法函数
** 4. 准备方法调用的栈布局
**
** 栈布局优化：
** - 方法函数存储在寄存器 R
** - 对象作为第一个参数存储在寄存器 R+1
** - 其他参数依次存储在 R+2, R+3, ...
** - 减少数据拷贝和寄存器使用
*/
LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);

/*
** [实用] 表索引访问处理
**
** 功能：处理表的索引访问操作（table[key]）
** @param fs: FuncState* 函数编译状态
** @param t: expdesc* 表表达式描述符
** @param k: expdesc* 键表达式描述符
**
** 索引类型处理：
** - 字符串键：优化为直接字段访问
** - 数字键：数组式访问优化
** - 变量键：通用表索引访问
** - 常量键：编译时优化
**
** 优化策略：
** - 字符串常量键的特殊编码
** - 小整数键的优化处理
** - 避免不必要的键值计算
** - 利用表的内部结构特性
**
** 生成指令：
** 根据键的类型生成 GETTABLE 或优化的访问指令
*/
LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);

/*
** ====================================================================
** [控制流] 条件跳转和控制流
** ====================================================================
*/

/*
** [控制流] 真值条件跳转
**
** 功能：生成基于表达式真值的条件跳转指令
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 条件表达式描述符
**
** 真值判断规则：
** - nil 和 false 为假值
** - 其他所有值（包括0和空字符串）为真值
** - 数字 0 在 Lua 中是真值
** - 空字符串 "" 在 Lua 中是真值
**
** 跳转优化：
** - 短路求值：避免不必要的表达式计算
** - 跳转合并：优化连续的条件跳转
** - 常量折叠：编译时确定的条件直接处理
** - 布尔表达式的特殊优化
**
** 应用场景：
** - if 语句的条件判断
** - while 和 for 循环的条件
** - and 和 or 操作符的短路求值
** - 条件表达式的处理
*/
LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);

/*
** [控制流] 变量赋值处理
**
** 功能：生成变量赋值的指令序列
** @param fs: FuncState* 函数编译状态
** @param var: expdesc* 左值变量描述符
** @param e: expdesc* 右值表达式描述符
**
** 变量类型处理：
** - VLOCAL: 局部变量赋值（寄存器间拷贝）
** - VUPVAL: 上值变量赋值（SETUPVAL 指令）
** - VGLOBAL: 全局变量赋值（SETGLOBAL 指令）
** - VINDEXED: 表字段赋值（SETTABLE 指令）
**
** 赋值优化：
** - 避免不必要的中间寄存器
** - 直接赋值优化
** - 多重赋值的批量处理
** - 表字段连续赋值的优化
**
** 类型转换：
** 根据左值类型选择合适的赋值指令，确保正确的语义。
*/
LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
/*
** ====================================================================
** [优化] 返回值管理
** ====================================================================
*/

/*
** [优化] 设置表达式返回值数量
**
** 功能：为表达式设置期望的返回值数量
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符  
** @param nresults: int 期望的返回值数量
**
** 多返回值处理：
** - 函数调用可能返回多个值
** - 表达式列表的最后一个表达式可以是多值的
** - 赋值语句需要匹配返回值数量
** - 可变参数 (...) 的处理
**
** 特殊值说明：
** - nresults = 1: 单一返回值
** - nresults = 0: 丢弃所有返回值
** - nresults = LUA_MULTRET: 保留所有返回值
**
** 实现策略：
** 根据返回值数量调整指令的参数，确保正确的栈管理。
*/
LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);

/*
** [优化] 设置单一返回值
**
** 功能：确保表达式只返回一个值
** @param fs: FuncState* 函数编译状态
** @param e: expdesc* 表达式描述符
**
** 单值优化：
** - 多返回值函数调用截断为单值
** - 可变参数的单值提取
** - 表达式列表的规范化处理
** - 避免多余的返回值处理
**
** 应用场景：
** - 算术表达式的操作数
** - 表索引的键值
** - 条件表达式的判断值
** - 函数参数的单值传递
*/
LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);

/*
** ====================================================================
** [控制流] 跳转指令管理
** ====================================================================
*/

/*
** [控制流] 无条件跳转生成
**
** 功能：生成无条件跳转指令
** @param fs: FuncState* 函数编译状态
** @return: int 跳转指令的位置（用于后续补丁）
**
** 跳转类型：
** - 前向跳转：目标地址未知，需要后续回填
** - 后向跳转：目标地址已知，直接设置
** - 条件跳转：基于运行时条件的跳转
** - 无条件跳转：始终执行的跳转
**
** 补丁机制：
** - 返回指令位置供后续目标地址回填
** - 支持跳转链表的构建
** - 处理嵌套控制结构的跳转
**
** 优化考虑：
** - 跳转距离的计算和优化
** - 死代码的识别和消除
** - 跳转指令的合并
*/
LUAI_FUNC int luaK_jump (FuncState *fs);

/*
** [控制流] 函数返回指令生成
**
** 功能：生成函数返回指令
** @param fs: FuncState* 函数编译状态
** @param first: int 第一个返回值的寄存器编号
** @param nret: int 返回值数量
**
** 返回值处理：
** - nret = 0: 无返回值
** - nret = 1: 单一返回值
** - nret = LUA_MULTRET: 多返回值（直到栈顶）
** - nret > 1: 指定数量的返回值
**
** 栈管理：
** - 清理局部变量占用的寄存器
** - 正确设置返回值的栈位置
** - 恢复调用者的栈状态
** - 处理尾调用优化
**
** 特殊情况：
** - 主函数的隐式返回
** - 协程的 yield 返回
** - 错误处理中的返回
*/
LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
/*
** ====================================================================
** [控制流] 跳转补丁管理系统
** ====================================================================
*/

/*
** [控制流] 跳转列表补丁处理
**
** 功能：将跳转列表中的所有跳转指令回填到指定目标
** @param fs: FuncState* 函数编译状态
** @param list: int 跳转列表的头指针
** @param target: int 跳转目标位置
**
** 补丁链表结构：
** - 每个跳转指令的目标字段存储下一个跳转指令的位置
** - 形成单向链表结构，以 NO_JUMP (-1) 结尾
** - 允许一次性回填多个相同目标的跳转
**
** 应用场景：
** - break 语句的跳转目标回填
** - continue 语句的跳转目标回填
** - if-else 结构的跳转处理
** - 循环结构的出口跳转
**
** 回填过程：
** 1. 遍历跳转链表中的每个指令
** 2. 计算相对跳转偏移量
** 3. 更新指令的跳转目标参数
** 4. 验证跳转距离的合法性
*/
LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);

/*
** [控制流] 跳转补丁到当前位置
**
** 功能：将跳转列表回填到当前代码生成位置
** @param fs: FuncState* 函数编译状态
** @param list: int 跳转列表的头指针
**
** 便利性接口：
** - patchlist 的便捷形式，目标为当前位置
** - 常用于控制结构的结束位置
** - 简化代码生成逻辑
**
** 使用场景：
** - if 语句结束后的跳转汇聚
** - 循环体结束后的跳转处理
** - switch-case 结构的跳转收束
** - 异常处理的跳转恢复
**
** 实现原理：
** 调用 luaK_patchlist，目标参数为当前的程序计数器值。
*/
LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);

/*
** [控制流] 跳转列表连接
**
** 功能：将两个跳转列表连接成一个列表
** @param fs: FuncState* 函数编译状态
** @param l1: int* 第一个列表的头指针（输出参数）
** @param l2: int 第二个列表的头指针
**
** 列表合并策略：
** - 将 l2 列表追加到 l1 列表的末尾
** - 更新 l1 指向合并后列表的头部
** - 保持列表的链接完整性
** - 处理空列表的特殊情况
**
** 应用场景：
** - 多个 break 语句的跳转合并
** - 嵌套控制结构的跳转处理
** - 并行分支的跳转统一
** - 复杂控制流的简化管理
**
** 算法复杂度：
** O(n) 时间复杂度，其中 n 是第一个列表的长度
*/
LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);

/*
** [控制流] 标签位置获取
**
** 功能：获取当前代码位置作为跳转标签
** @param fs: FuncState* 函数编译状态
** @return: int 当前代码位置（程序计数器值）
**
** 标签管理：
** - 提供代码位置的统一接口
** - 用于后向跳转的目标设置
** - 支持循环的开始位置标记
** - 处理 goto 语句的目标定义
**
** 返回值用途：
** - 循环语句的继续位置
** - 条件跳转的目标计算
** - 代码块的边界标记
** - 优化分析的控制点
**
** 注意事项：
** 返回的标签位置是相对于函数开始的偏移量。
*/
LUAI_FUNC int luaK_getlabel (FuncState *fs);
/*
** ====================================================================
** [运算符] 运算符处理接口
** ====================================================================
*/

/*
** [运算符] 前缀运算符处理
**
** 功能：处理前缀（一元）运算符的代码生成
** @param fs: FuncState* 函数编译状态
** @param op: UnOpr 一元运算符类型
** @param v: expdesc* 操作数表达式描述符
**
** 支持的前缀运算符：
** - OPR_MINUS: 取负运算 (-x)
** - OPR_NOT: 逻辑非运算 (not x)
** - OPR_LEN: 长度运算 (#x)
**
** 处理策略：
** - 常量折叠：编译时计算常量表达式
** - 类型检查：确保运算符适用于操作数类型
** - 指令生成：生成相应的虚拟机指令
** - 结果优化：优化结果的存储和使用
**
** 优化机制：
** - 数字常量的直接计算
** - 布尔常量的逻辑运算
** - 字符串长度的编译时确定
** - 表达式树的简化
*/
LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);

/*
** [运算符] 中缀运算符中间处理
**
** 功能：处理中缀（二元）运算符的左操作数
** @param fs: FuncState* 函数编译状态
** @param op: BinOpr 二元运算符类型
** @param v: expdesc* 左操作数表达式描述符
**
** 处理阶段：
** 这是二元运算符处理的第一阶段，主要处理左操作数：
** 1. 左操作数的值计算和优化
** 2. 短路求值的条件设置
** 3. 比较运算符的左值准备
** 4. 算术运算符的左值准备
**
** 短路求值优化：
** - AND: 左操作数为假时直接跳转
** - OR: 左操作数为真时直接跳转
** - 避免不必要的右操作数计算
** - 优化条件表达式的性能
**
** 后续处理：
** 调用此函数后，需要解析右操作数，然后调用 luaK_posfix 完成运算。
*/
LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);

/*
** [运算符] 后缀运算符最终处理
**
** 功能：完成中缀（二元）运算符的代码生成
** @param fs: FuncState* 函数编译状态
** @param op: BinOpr 二元运算符类型
** @param v1: expdesc* 左操作数表达式描述符
** @param v2: expdesc* 右操作数表达式描述符
**
** 运算符分类处理：
** - 算术运算符: +, -, *, /, %, ^
** - 比较运算符: ==, ~=, <, <=, >, >=
** - 逻辑运算符: and, or
** - 字符串运算符: .. (连接)
**
** 优化策略：
** - 常量折叠：两个常量的运算在编译时完成
** - 交换律利用：调整操作数顺序优化指令
** - 强度削减：将复杂运算替换为简单运算
** - 指令合并：合并相邻的相关运算
**
** 指令生成：
** 根据运算符类型和操作数特性，生成最优的虚拟机指令序列。
*/
LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);

/*
** ====================================================================
** [实用] 表构造和列表处理
** ====================================================================
*/

/*
** [实用] 表列表元素设置
**
** 功能：为表构造器设置连续的数组部分元素
** @param fs: FuncState* 函数编译状态
** @param base: int 基础寄存器位置
** @param nelems: int 元素数量
** @param tostore: int 需要存储的元素数量
**
** 表构造优化：
** - 批量设置：一次性设置多个数组元素
** - 内存效率：减少单个元素设置的开销
** - 指令优化：使用 SETLIST 指令批量操作
** - 栈管理：优化寄存器的使用和回收
**
** 参数说明：
** - base: 表对象所在的寄存器
** - nelems: 当前已有的元素数量
** - tostore: 本次要存储的新元素数量
**
** 应用场景：
** - 表字面量的数组部分初始化
** - 列表推导的结果构造
** - 批量数据的表插入
** - 数组式表的高效构造
**
** 实现原理：
** 生成 SETLIST 指令，利用虚拟机的批量设置机制提高性能。
*/
LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);


/*
** ====================================================================
** [总结] Lua 代码生成器模块总结
** ====================================================================
**
** 本头文件定义了 Lua 编译器的代码生成器接口，负责将语法分析的结果
** 转换为 Lua 虚拟机的字节码指令。
**
** 主要功能模块：
**
** 1. [常量定义]
**    - 跳转补丁常量 (NO_JUMP)
**    - 运算符优先级和类型定义
**
** 2. [运算符枚举]  
**    - 二元运算符 (BinOpr): 算术、比较、逻辑运算符
**    - 一元运算符 (UnOpr): 取负、逻辑非、长度运算符
**
** 3. [指令生成]
**    - 基础指令生成: luaK_codeABC, luaK_codeABx
**    - 调试信息管理: luaK_fixline
**
** 4. [寄存器管理]
**    - 寄存器分配: luaK_reserveregs, luaK_checkstack
**    - 栈空间管理: luaK_nil
**
** 5. [常量池管理]
**    - 常量索引获取: luaK_stringK, luaK_numberK
**    - 常量去重和优化
**
** 6. [表达式处理]
**    - 表达式类型转换: luaK_exp2anyreg, luaK_exp2RK
**    - 变量访问优化: luaK_dischargevars
**    - 返回值管理: luaK_setreturns, luaK_setoneret
**
** 7. [特殊操作]
**    - 表索引访问: luaK_indexed
**    - 方法调用处理: luaK_self
**    - 变量赋值: luaK_storevar
**
** 8. [控制流]
**    - 跳转指令: luaK_jump, luaK_ret
**    - 条件跳转: luaK_goiftrue
**    - 跳转补丁系统: luaK_patchlist, luaK_patchtohere
**
** 9. [运算符处理]
**    - 一元运算符: luaK_prefix
**    - 二元运算符: luaK_infix, luaK_posfix
**    - 运算符优化和常量折叠
**
** 10. [表构造]
**     - 表列表设置: luaK_setlist
**     - 批量元素初始化优化
**
** 设计特点：
** - 模块化设计：功能明确分离，易于维护
** - 优化导向：多层次的编译优化支持
** - 类型安全：严格的表达式类型管理
** - 内存高效：最小化寄存器和常量使用
** - 可扩展性：为新的语言特性预留扩展空间
**
** 与其他模块的关系：
** - lparser.c: 语法分析器的主要客户
** - lopcodes.h: 虚拟机指令集的使用者
** - lobject.h: Lua 对象系统的依赖
** - lstate.h: 编译状态管理的基础
*/

#endif
