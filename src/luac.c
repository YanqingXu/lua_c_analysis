/*
** ============================================================================
** [核心] Lua 编译器实现 (Lua Compiler Implementation)
** ============================================================================
**
** 文件功能：
** 本文件实现了 Lua 编译器（luac），是将 Lua 源代码编译为字节码的命令行工具。
** 编译器提供了完整的源码到字节码的转换功能，支持多种编译选项和输出格式。
**
** [核心] 编译器功能模块：
** 1. [编译] 源代码词法分析、语法分析和字节码生成
** 2. [输出] 字节码文件的序列化输出和格式控制
** 3. [列表] 字节码指令的反汇编显示和调试支持
** 4. [优化] 调试信息剥离和字节码优化处理
** 5. [合并] 多源文件的批量编译和函数合并
** 6. [验证] 编译过程的完整性检查和错误报告
**
** [设计] 架构特点：
** - 标准命令行工具接口设计，支持 POSIX 风格选项
** - 模块化编译流程，每个阶段职责分离
** - 灵活的输出控制，支持文件、标准输出和调试列表
** - 完善的错误处理体系，提供清晰的诊断信息
** - 跨平台文件操作，统一的字符编码处理
** - 内存安全的资源管理，防止内存泄漏
**
** [流程] 编译处理流程：
** 1. [解析] 命令行参数解析和编译选项配置
** 2. [加载] Lua 源文件读取和预处理检查
** 3. [词法] 词法分析器进行 Token 识别和分类
** 4. [语法] 语法分析器构建抽象语法树（AST）
** 5. [生成] 字节码生成器产生虚拟机指令序列
** 6. [优化] 可选的调试信息剥离和代码优化
** 7. [序列化] 字节码序列化输出到目标文件
**
** [依赖] 模块依赖关系：
** - lua.h/lauxlib.h: Lua 核心 API 和辅助函数库
** - ldo.h: 执行控制、调用栈管理和异常处理
** - lfunc.h: 函数对象、闭包管理和原型操作
** - lmem.h: 内存分配器、垃圾回收协调
** - lobject.h: 基础对象系统、类型定义和值表示
** - lopcodes.h: 字节码指令集定义和操作码枚举
** - lstring.h: 字符串内部化、哈希表和内存池
** - lundump.h: 字节码序列化、反序列化和格式定义
**
** [版本] 源码版本信息：
** $Id: luac.c,v 1.54 2006/06/02 17:37:11 lhf Exp $
** Lua compiler (saves bytecodes to files; also list bytecodes)
** See Copyright Notice in lua.h
*/

/*
** ============================================================================
** [依赖] 系统头文件包含区域
** ============================================================================
*/

// 标准错误处理头文件
// 提供 errno 全局变量和错误代码常量定义
// 用于获取系统调用失败的详细错误信息
#include <errno.h>

// 标准输入输出库头文件  
// 提供 printf、fprintf、fopen、fwrite 等文件操作函数
// 支持格式化输出和文件流操作
#include <stdio.h>

// 标准库函数头文件
// 提供 exit、malloc、free 等基础库函数
// 包含程序终止和内存管理相关功能
#include <stdlib.h>

// 字符串操作函数头文件
// 提供 strcmp、strlen、strerror 等字符串处理函数
// 用于命令行参数比较和错误消息格式化
#include <string.h>

/*
** ============================================================================
** [配置] 编译器特定宏定义
** ============================================================================
*/

// 标识当前正在编译 luac.c 文件
// 用于条件编译和模块识别
#define luac_c

// 标识编译 Lua 核心组件
// 启用核心 API 的内部访问权限
#define LUA_CORE

/*
** ============================================================================
** [核心] Lua API 头文件包含区域
** ============================================================================
*/

// Lua 核心 API 定义头文件
// 提供 lua_State、lua_CFunction 等核心类型定义
// 包含虚拟机接口函数的声明
#include "lua.h"

// Lua 辅助库函数头文件
// 提供 luaL_loadfile、luaL_error 等高级 API
// 简化常见 Lua 操作的辅助函数集合
#include "lauxlib.h"

/*
** ============================================================================
** [内部] Lua 内部模块头文件包含区域
** ============================================================================
*/

// 执行控制和调用栈管理头文件
// 提供 luaD_* 系列函数和执行环境控制
// 包含异常处理和调用栈操作功能
#include "ldo.h"

// 函数对象和闭包操作头文件
// 提供 luaF_newproto、Proto 结构定义
// 用于函数原型的创建和管理
#include "lfunc.h"

// 内存管理和分配器头文件
// 提供 luaM_newvector 等内存分配函数
// 与垃圾回收器协调的内存管理接口
#include "lmem.h"

// 基础对象系统和类型定义头文件
// 提供 TValue、setptvalue2s 等对象操作
// 包含 Lua 值的内部表示和操作宏
#include "lobject.h"

// 字节码指令集定义头文件
// 提供 OpCode 枚举和 CREATE_ABx 等指令构造宏
// 定义虚拟机的指令格式和操作码
#include "lopcodes.h"

// 字符串内部化和管理头文件
// 提供 luaS_newliteral 等字符串创建函数
// 包含字符串哈希表和内存池管理
#include "lstring.h"

// 字节码序列化和反序列化头文件
// 提供 luaU_dump、luaU_print 等序列化函数
// 用于字节码的文件保存和加载
#include "lundump.h"

/*
** ============================================================================
** [常量] 程序配置常量定义
** ============================================================================
*/

// 程序名称常量
// 用于错误消息显示和帮助信息输出
// 在各种用户界面场景中标识程序身份
#define PROGNAME    "luac"

// 默认输出文件名常量
// 当用户未指定输出文件时使用的默认名称
// 组合程序名和 .out 扩展名形成标准输出文件
#define OUTPUT      PROGNAME ".out"

/*
** ============================================================================
** [状态] 编译器全局状态变量
** ============================================================================
*/

// 字节码列表显示控制变量
// 0: 不显示字节码列表
// 1: 显示简要字节码列表
// 2: 显示详细字节码列表（包含调试信息）
// 通过 -l 选项递增，支持多级详细程度
static int listing = 0;

// 字节码转储输出控制变量
// 1: 生成字节码文件输出（默认行为）
// 0: 仅执行解析和编译，不生成文件
// 通过 -p 选项设置为仅解析模式
static int dumping = 1;

// 调试信息剥离控制变量
// 0: 保留完整调试信息（默认行为）
// 1: 剥离调试信息以减小文件大小
// 通过 -s 选项启用调试信息剥离
static int stripping = 0;

// 默认输出文件名存储数组
// 使用静态字符数组存储默认输出文件名
// 可通过 output 指针修改实际使用的文件名
static char Output[] = { OUTPUT };

// 当前输出文件名指针
// 指向实际使用的输出文件名
// 可以指向 Output 数组或命令行指定的文件名
static const char* output = Output;

// 当前程序名称指针
// 通常从 argv[0] 获取实际的程序调用名称
// 用于错误消息和帮助信息的显示
static const char* progname = PROGNAME;

/*
** ============================================================================
** [错误] 错误处理和程序终止函数
** ============================================================================
*/

/*
** [错误] 致命错误处理函数
**
** 功能描述：
** 报告致命错误并立即终止程序执行，用于处理不可恢复的错误情况。
** 
** 参数说明：
** @param message - const char*: 错误描述消息字符串
**
** 处理流程：
** 1. [格式化] 将程序名和错误消息组合成标准错误格式
** 2. [输出] 向标准错误流输出完整的错误信息
** 3. [退出] 使用 EXIT_FAILURE 状态码终止程序
**
** 错误格式：
** "<程序名>: <错误消息>"
**
** 使用场景：
** - 内存分配失败无法继续执行
** - 关键文件无法访问或损坏
** - Lua 虚拟机初始化失败
** - 其他系统级不可恢复错误
**
** 注意事项：
** - 函数不会返回，调用后程序直接终止
** - 错误信息输出到标准错误流而非标准输出
** - 退出状态码遵循 POSIX 标准约定
*/
static void fatal(const char* message)
{
    fprintf(stderr, "%s: %s\n", progname, message);
    exit(EXIT_FAILURE);
}

/*
** [错误] 文件操作错误处理函数
**
** 功能描述：
** 报告文件操作失败并终止程序，提供详细的系统错误信息。
**
** 参数说明：
** @param what - const char*: 失败的操作类型描述
**
** 处理流程：
** 1. [错误获取] 使用 strerror(errno) 获取系统错误描述
** 2. [信息组合] 结合操作类型、文件名和系统错误信息
** 3. [格式输出] 输出完整的错误上下文到标准错误流
** 4. [程序终止] 使用失败状态码退出程序
**
** 错误格式：
** "<程序名>: cannot <操作类型> <文件名>: <系统错误描述>"
**
** 常用操作类型：
** - "open": 文件打开失败
** - "write": 文件写入失败  
** - "close": 文件关闭失败
** - "read": 文件读取失败
**
** 使用场景：
** - 无法打开输入或输出文件
** - 磁盘空间不足导致写入失败
** - 文件权限不足或文件被锁定
** - 网络文件系统连接中断
** - 其他文件系统相关错误
**
** 注意事项：
** - 依赖全局变量 output 作为文件名
** - 必须在设置 errno 的系统调用失败后立即调用
** - 提供的错误信息有助于用户诊断问题
*/
static void cannot(const char* what)
{
    fprintf(stderr, "%s: cannot %s %s: %s\n", 
            progname, what, output, strerror(errno));
    exit(EXIT_FAILURE);
}

/*
** [帮助] 使用说明和错误提示函数
**
** 功能描述：
** 显示程序使用方法并退出，为用户提供完整的命令行接口说明。
**
** 参数说明：
** @param message - const char*: 错误消息或触发帮助的选项名称
**
** 处理逻辑：
** 1. [消息判断] 检查消息是否为未知选项（以 '-' 开头）
** 2. [错误显示] 根据消息类型显示相应的错误信息
** 3. [帮助输出] 显示完整的使用说明和选项列表
** 4. [程序退出] 使用失败状态码终止程序
**
** 选项说明详解：
** -        : 从标准输入读取 Lua 源代码
** -l       : 启用字节码列表显示模式
** -o name  : 指定输出文件名（默认为 "luac.out"）
** -p       : 仅解析模式，不生成字节码文件
** -s       : 剥离调试信息以减小文件大小
** -v       : 显示版本信息
** --       : 停止选项处理，后续参数视为文件名
**
** 错误消息格式：
** - 未知选项: "<程序名>: unrecognized option '<选项>'"
** - 一般错误: "<程序名>: <错误消息>"
**
** 使用说明格式：
** "usage: <程序名> [options] [filenames]."
** 
** 使用场景：
** - 用户提供无效的命令行选项
** - 缺少必需的参数或文件名
** - 用户明确请求帮助信息
** - 命令行语法错误或参数冲突
**
** 设计考虑：
** - 遵循 POSIX 标准的错误报告格式
** - 提供清晰、简洁的选项说明
** - 包含默认值信息以便用户理解
** - 使用标准错误流输出以便重定向
*/
static void usage(const char* message)
{
    // 判断消息类型并显示相应错误信息
    if (*message == '-')
    {
        fprintf(stderr, "%s: unrecognized option " LUA_QS "\n", progname, message);
    }
    else
    {
        fprintf(stderr, "%s: %s\n", progname, message);
    }
    
    // 显示完整的使用说明
    fprintf(stderr,
        "usage: %s [options] [filenames].\n"
        "Available options are:\n"
        "  -        process stdin\n"
        "  -l       list\n"
        "  -o name  output to file " LUA_QL("name") " (default is \"%s\")\n"
        "  -p       parse only\n"
        "  -s       strip debug information\n"
        "  -v       show version information\n"
        "  --       stop handling options\n",
        progname, Output);
    
    exit(EXIT_FAILURE);
}

/*
** ============================================================================
** [工具] 字符串比较便利宏定义
** ============================================================================
*/

// 字符串相等比较宏
// 简化命令行参数与预定义选项的字符串比较操作
// 使用 strcmp 进行严格的字符串匹配检查
#define IS(s)    (strcmp(argv[i], s) == 0)

/*
** ============================================================================
** [解析] 命令行参数处理和配置函数
** ============================================================================
*/

/*
** [解析] 命令行参数解析和状态配置函数
**
** 功能描述：
** 解析命令行参数并配置编译器的全局状态变量，返回源文件参数的起始位置。
**
** 参数说明：
** @param argc - int: 命令行参数总数量
** @param argv - char*[]: 命令行参数字符串数组
** @return int: 第一个非选项参数（源文件名）的数组索引位置
**
** 解析流程：
** 1. [程序名提取] 从 argv[0] 提取并设置程序名称
** 2. [选项扫描] 遍历所有以 '-' 开头的选项参数
** 3. [状态配置] 根据识别的选项设置相应全局变量
** 4. [参数验证] 验证选项参数的完整性和有效性
** 5. [特殊处理] 处理版本显示和终止条件
** 6. [返回索引] 返回第一个源文件名的位置
**
** 支持的命令行选项：
** -        : 使用标准输入作为源文件输入
** -l       : 启用字节码列表显示（可重复使用增加详细程度）
** -o name  : 指定输出文件名（name 为 "-" 时输出到标准输出）
** -p       : 仅解析模式，不生成字节码文件
** -s       : 启用调试信息剥离以减小文件大小
** -v       : 显示版本信息（可与其他操作组合）
** --       : 停止选项处理，后续参数视为文件名
**
** 特殊处理逻辑：
** 1. [版本显示] 如果指定了 -v，显示版本和版权信息
** 2. [默认行为] 无源文件且启用列表或禁用转储时，使用默认输出
** 3. [单独版本] 仅指定版本选项时，显示后直接退出
** 4. [参数调整] 调整 argc 和 argv 以跳过已处理的选项
**
** 错误处理：
** - 无效选项：调用 usage 函数显示帮助并退出
** - 缺少参数：检查 -o 选项是否提供了文件名参数
** - 空参数：验证提供的参数不为空字符串
**
** 状态变量影响：
** - listing: 控制字节码列表显示级别
** - dumping: 控制是否生成字节码文件
** - stripping: 控制是否剥离调试信息
** - output: 设置输出文件名或标准输出
** - progname: 设置程序名称用于错误消息
**
** 返回值意义：
** 返回的索引指向 argv 中第一个源文件名，调用者可以从此位置
** 开始遍历所有需要编译的源文件。
**
** 使用示例：
** int file_start = doargs(argc, argv);
** for (int i = file_start; i < argc; i++) {
**     compile_file(argv[i]);
** }
*/
static int doargs(int argc, char* argv[])
{
    int i;
    int version = 0;
    
    // 从 argv[0] 提取程序名称
    if (argv[0] != NULL && *argv[0] != 0)
    {
        progname = argv[0];
    }
    
    // 遍历所有命令行参数
    for (i = 1; i < argc; i++)
    {
        // 检查是否为选项参数
        if (*argv[i] != '-')
        {
            // 非选项参数，选项处理结束
            break;
        }
        else if (IS("--"))
        {
            // 双破折号：停止选项处理
            ++i;
            if (version)
            {
                ++version;
            }
            break;
        }
        else if (IS("-"))
        {
            // 单破折号：使用标准输入
            break;
        }
        else if (IS("-l"))
        {
            // 列表模式：启用字节码显示
            ++listing;
        }
        else if (IS("-o"))
        {
            // 输出文件：指定输出文件名
            output = argv[++i];
            if (output == NULL || *output == 0)
            {
                usage(LUA_QL("-o") " needs argument");
            }
            if (IS("-"))
            {
                // 输出到标准输出
                output = NULL;
            }
        }
        else if (IS("-p"))
        {
            // 仅解析模式：不生成字节码
            dumping = 0;
        }
        else if (IS("-s"))
        {
            // 剥离模式：移除调试信息
            stripping = 1;
        }
        else if (IS("-v"))
        {
            // 版本信息：显示版本
            ++version;
        }
        else
        {
            // 未知选项：显示错误和帮助
            usage(argv[i]);
        }
    }
    
    // 处理无输入文件的特殊情况
    if (i == argc && (listing || !dumping))
    {
        dumping = 0;
        argv[--i] = Output;
    }
    
    // 处理版本信息显示
    if (version)
    {
        printf("%s  %s\n", LUA_RELEASE, LUA_COPYRIGHT);
        if (version == argc - 1)
        {
            exit(EXIT_SUCCESS);
        }
    }
    
    return i;
}

/*
** ============================================================================
** [工具] 对象访问便利宏定义
** ============================================================================
*/

// 从 Lua 栈指定偏移位置提取函数原型宏
// 访问栈顶偏移 i 位置的闭包对象，并获取其函数原型
// 用于从编译结果中提取 Proto 对象进行后续处理
#define toproto(L, i)    (clvalue(L->top + (i))->l.p)

/*
** ============================================================================
** [核心] 函数原型合并和包装处理
** ============================================================================
*/

/*
** [合并] 多函数原型合并为单一执行单元
**
** 功能描述：
** 将多个独立编译的函数原型合并为一个统一的主函数，创建包含所有
** 子函数的执行包装器，简化字节码加载和批量执行。
**
** 参数说明：
** @param L - lua_State*: Lua 虚拟机状态指针
** @param n - int: 要合并的函数原型数量
** @return const Proto*: 合并后的主函数原型指针
**
** 合并策略：
** 1. [单函数优化] 只有一个函数时直接返回，避免不必要的包装
** 2. [多函数包装] 创建新的包装函数原型容纳所有子函数
** 3. [字节码生成] 为每个子函数生成相应的调用字节码
** 4. [元数据设置] 配置包装函数的基本属性和执行环境
**
** 生成的字节码结构：
** 对于 n 个函数，生成 2*n+1 条指令：
** - OP_CLOSURE 指令：创建每个子函数的闭包对象
** - OP_CALL 指令：调用每个子函数（无参数，无返回值）
** - OP_RETURN 指令：主函数返回（无返回值）
**
** 内存管理：
** 1. [原型分配] 使用 luaF_newproto 创建新的函数原型
** 2. [指令数组] 分配 2*n+1 大小的指令序列内存
** 3. [子函数数组] 分配 n 大小的子函数指针数组
** 4. [栈管理] 正确管理 Lua 栈上的对象引用
** 5. [GC 协调] 确保新对象能被垃圾回收器正确跟踪
**
** 函数属性设置：
** - source: 设置为 "=(luac)" 标识编译器生成
** - maxstacksize: 设置为 1，足够容纳临时闭包对象
** - sizecode: 指令数组大小 = 2*n+1
** - sizep: 子函数数组大小 = n
**
** 字节码生成详解：
** ```
** for i = 0 to n-1:
**     CLOSURE 0 i    ; 创建第 i 个子函数的闭包
**     CALL 0 1 1     ; 调用闭包（0 参数，1 返回值被忽略）
** RETURN 0 1 0       ; 返回（无返回值）
** ```
**
** 使用场景：
** - 多个源文件的批量编译结果合并
** - 创建包含多个模块的单一字节码文件
** - 简化复杂项目的字节码分发和加载
** - 提供统一的程序入口点和执行序列
**
** 设计考虑：
** - 最小化运行时开销，单函数时无额外包装
** - 保持所有子函数的独立性和完整性
** - 支持任意数量的函数合并
** - 与 Lua 虚拟机的加载机制完全兼容
**
** 注意事项：
** - 调用者需要确保栈上有足够的函数原型
** - 子函数按照在栈上的相对位置进行索引
** - 合并后的函数会按顺序执行所有子函数
** - 子函数的返回值被丢弃，不影响主流程
*/
static const Proto* combine(lua_State* L, int n)
{
    // 单函数优化：直接返回，无需包装
    if (n == 1)
    {
        return toproto(L, -1);
    }
    else
    {
        int i, pc;
        Proto* f = luaF_newproto(L);
        
        // 将新原型推入栈顶并保护
        setptvalue2s(L, L->top, f);
        incr_top(L);
        
        // 设置包装函数的基本属性
        f->source = luaS_newliteral(L, "=(" PROGNAME ")");
        f->maxstacksize = 1;
        
        // 计算所需指令数量：每个函数需要 CLOSURE + CALL，最后加 RETURN
        pc = 2 * n + 1;
        f->code = luaM_newvector(L, pc, Instruction);
        f->sizecode = pc;
        
        // 分配子函数指针数组
        f->p = luaM_newvector(L, n, Proto*);
        f->sizep = n;
        
        // 生成字节码序列
        pc = 0;
        for (i = 0; i < n; i++)
        {
            // 从栈中获取第 i 个函数原型
            f->p[i] = toproto(L, i - n - 1);
            
            // 生成 CLOSURE 指令：创建闭包
            f->code[pc++] = CREATE_ABx(OP_CLOSURE, 0, i);
            
            // 生成 CALL 指令：调用函数（0参数，1返回值被忽略）
            f->code[pc++] = CREATE_ABC(OP_CALL, 0, 1, 1);
        }
        
        // 生成 RETURN 指令：主函数返回
        f->code[pc++] = CREATE_ABC(OP_RETURN, 0, 1, 0);
        
        return f;
    }
}

/*
** ============================================================================
** [输出] 字节码序列化输出处理
** ============================================================================
*/

/*
** [写入] 字节码数据写入回调函数
**
** 功能描述：
** 作为 luaU_dump 函数的写入回调，将字节码数据写入到指定的文件流。
** 实现字节码序列化过程中的底层数据写入操作。
**
** 参数说明：
** @param L - lua_State*: Lua 状态机指针（在此函数中未使用）
** @param p - const void*: 指向要写入数据的内存地址
** @param size - size_t: 要写入的数据字节大小
** @param u - void*: 用户数据指针，实际为 FILE* 类型的文件句柄
** @return int: 写入操作的结果状态（0表示成功，非0表示失败）
**
** 写入逻辑：
** 1. [数据写入] 使用 fwrite 将内存数据写入文件流
** 2. [结果检查] 验证实际写入的数据块数量
** 3. [特殊处理] 零大小数据始终视为成功操作
** 4. [错误返回] 写入失败时返回非零错误码
**
** 错误处理：
** - 当 fwrite 返回值不等于 1 且 size 不为 0 时表示写入失败
** - 零大小写入被特殊处理，总是返回成功状态
** - 错误状态会传播给 luaU_dump 的调用者进行处理
**
** 使用场景：
** - luaU_dump 函数的标准写入回调接口
** - 字节码序列化到文件的底层实现
** - 提供统一的文件写入抽象层
** - 支持任意类型的输出流（文件、管道等）
**
** 性能考虑：
** - 直接使用系统级 fwrite 调用，性能高效
** - 无额外的数据复制或转换开销
** - 支持大块数据的高效写入
**
** 兼容性：
** - 符合 lua_Writer 函数指针类型定义
** - 与 Lua 标准库的序列化接口完全兼容
** - 可用于任何需要数据写入回调的场景
**
** 注意事项：
** - L 参数虽然未使用，但保持接口一致性
** - 用户数据 u 必须是有效的 FILE* 指针
** - 调用者负责文件的打开、关闭和错误处理
** - 写入过程中不进行任何数据格式转换
*/
static int writer(lua_State* L, const void* p, size_t size, void* u)
{
    // L 参数在此函数中未使用，标记以避免编译器警告
    UNUSED(L);
    
    // 执行数据写入并检查结果
    // 当写入的块数不等于1且数据大小不为0时表示失败
    return (fwrite(p, size, 1, (FILE*)u) != 1) && (size != 0);
}

/*
** ============================================================================
** [结构] 主函数参数传递数据结构
** ============================================================================
*/

/*
** [结构] 主函数参数封装结构体
**
** 功能描述：
** 用于向受保护调用的主函数传递命令行参数的数据结构。
** 由于 lua_cpcall 只能传递一个 void* 参数，使用此结构体
** 包装多个参数以实现参数传递。
**
** 结构成员：
** @member argc - int: 源文件参数的数量
** @member argv - char**: 源文件名字符串数组指针
**
** 使用场景：
** - 作为 lua_cpcall 的用户数据参数
** - 在受保护环境中传递命令行参数
** - 封装编译所需的文件信息
**
** 设计考虑：
** - 结构简单，最小化内存开销
** - 直接传递指针，避免数据复制
** - 与标准 main 函数参数格式兼容
*/
struct Smain
{
    // 源文件参数数量
    int argc;
    // 源文件名数组指针
    char** argv;
};

/*
** ============================================================================
** [核心] 受保护的编译主逻辑实现
** ============================================================================
*/

/*
** [主函数] 受保护环境下的编译执行函数
**
** 功能描述：
** 在受保护的 Lua 环境中执行完整的编译流程，包括文件加载、编译、
** 合并、列表显示和字节码输出等核心操作。
**
** 参数说明：
** @param L - lua_State*: Lua 虚拟机状态指针
** @return int: 执行结果状态（0表示成功，非0表示失败）
**
** 执行流程：
** 1. [参数提取] 从用户数据中解析命令行参数结构
** 2. [栈空间检查] 确保有足够栈空间容纳所有编译结果
** 3. [文件批量加载] 逐个加载并编译所有源文件
** 4. [函数合并] 将多个函数原型合并为统一执行单元
** 5. [可选列表] 根据配置显示字节码反汇编列表
** 6. [字节码输出] 序列化字节码并写入目标文件
**
** 文件处理逻辑：
** - 支持文件名或 "-" 表示标准输入
** - 使用 luaL_loadfile 进行源码编译
** - 编译错误时立即报告并终止
** - 编译成功的函数推入栈顶等待合并
**
** 输出控制机制：
** 1. [列表显示] 由全局变量 listing 控制
**    - 0: 不显示列表
**    - 1: 显示基本字节码列表
**    - >1: 显示详细字节码列表
** 2. [字节码转储] 由全局变量 dumping 控制
**    - 0: 仅编译，不生成文件
**    - 1: 生成字节码文件
** 3. [调试信息] 由全局变量 stripping 控制
**    - 0: 保留完整调试信息
**    - 1: 剥离调试信息减小文件大小
**
** 文件输出处理：
** - output 为 NULL: 输出到标准输出流
** - output 非 NULL: 输出到指定文件
** - 使用二进制模式 "wb" 确保跨平台兼容性
** - 完整的文件操作错误检查和处理
**
** 错误处理策略：
** 1. [编译错误] luaL_loadfile 失败时调用 fatal 终止
** 2. [文件错误] 无法打开输出文件时调用 cannot 报告
** 3. [写入错误] 检查 ferror 状态，写入失败时报告
** 4. [关闭错误] 检查 fclose 返回值，确保数据完整性
**
** 内存和资源管理：
** - 使用 Lua 的垃圾回收机制管理编译产生的对象
** - 及时关闭文件句柄，防止资源泄漏
** - 异常情况下依然保证资源的正确释放
**
** 线程安全考虑：
** - 使用 lua_lock/lua_unlock 保护字节码转储操作
** - 确保在多线程环境下的操作原子性
** - 防止并发访问导致的数据竞争
**
** 使用场景：
** - 作为 lua_cpcall 的受保护回调函数
** - 在异常安全的环境中执行编译逻辑
** - 提供完整的错误恢复和资源清理机制
**
** 设计优势：
** - 异常安全：即使发生错误也不会导致程序崩溃
** - 资源安全：确保文件句柄等资源的正确管理
** - 状态一致：保持 Lua 虚拟机状态的一致性
** - 错误透明：详细的错误报告帮助用户诊断问题
**
** 注意事项：
** - 函数假设输入参数已经通过 doargs 正确解析
** - 栈上的函数原型按照文件加载顺序排列
** - 字节码转储使用平台无关的格式
** - 调用者负责创建和销毁 Lua 状态机
*/
static int pmain(lua_State* L)
{
    // 从用户数据中提取参数结构
    struct Smain* s = (struct Smain*)lua_touserdata(L, 1);
    int argc = s->argc;
    char** argv = s->argv;
    const Proto* f;
    int i;
    
    // 检查栈空间是否足够容纳所有文件的编译结果
    if (!lua_checkstack(L, argc))
    {
        fatal("too many input files");
    }
    
    // 批量加载和编译所有源文件
    for (i = 0; i < argc; i++)
    {
        // 确定文件名："-" 表示标准输入，否则使用文件名
        const char* filename = IS("-") ? NULL : argv[i];
        
        // 加载并编译文件，失败时报告错误并退出
        if (luaL_loadfile(L, filename) != 0)
        {
            fatal(lua_tostring(L, -1));
        }
    }
    
    // 将所有编译结果合并为单一函数原型
    f = combine(L, argc);
    
    // 可选的字节码列表显示
    if (listing)
    {
        luaU_print(f, listing > 1);
    }
    
    // 字节码文件输出处理
    if (dumping)
    {
        FILE* D;
        
        // 确定输出目标：NULL 表示标准输出，否则打开指定文件
        if (output == NULL)
        {
            D = stdout;
        }
        else
        {
            D = fopen(output, "wb");
            if (D == NULL)
            {
                cannot("open");
            }
        }
        
        // 在保护状态下执行字节码转储
        lua_lock(L);
        luaU_dump(L, f, writer, D, stripping);
        lua_unlock(L);
        
        // 检查写入过程中的错误
        if (ferror(D))
        {
            cannot("write");
        }
        
        // 关闭文件并检查关闭操作的成功性
        if (fclose(D))
        {
            cannot("close");
        }
    }
    
    return 0;
}

/*
** ============================================================================
** [主函数] 程序入口点和顶层控制逻辑
** ============================================================================
*/

/*
** [入口] Lua 编译器主函数
**
** 功能描述：
** Lua 编译器的程序入口点，负责整体流程控制、错误处理和资源管理。
** 协调命令行解析、虚拟机管理和受保护的编译执行。
**
** 参数说明：
** @param argc - int: 命令行参数总数量（包括程序名）
** @param argv - char*[]: 命令行参数字符串数组
** @return int: 程序退出状态码（EXIT_SUCCESS 或 EXIT_FAILURE）
**
** 执行流程：
** 1. [参数解析] 调用 doargs 解析命令行选项和配置
** 2. [参数调整] 调整 argc 和 argv 指向源文件列表
** 3. [输入验证] 验证至少提供了一个源文件
** 4. [虚拟机初始化] 创建新的 Lua 状态机实例
** 5. [受保护执行] 在保护环境中执行编译逻辑
** 6. [资源清理] 关闭 Lua 状态机并释放资源
** 7. [状态返回] 返回适当的程序退出状态
**
** 参数处理详解：
** - doargs 返回第一个源文件在 argv 中的索引
** - argc 调整为剩余源文件的数量
** - argv 调整为指向第一个源文件名的位置
** - 确保至少有一个有效的输入源文件
**
** 虚拟机生命周期管理：
** 1. [创建] 使用 lua_open 创建独立的 Lua 状态
** 2. [验证] 检查内存分配是否成功
** 3. [使用] 传递给受保护的编译函数
** 4. [销毁] 使用 lua_close 释放所有相关资源
**
** 错误处理机制：
** 1. [参数错误] 无输入文件时显示使用说明
** 2. [内存错误] 虚拟机创建失败时报告内存不足
** 3. [编译错误] 受保护调用失败时提取错误消息
** 4. [统一终止] 所有错误都通过 fatal 函数统一处理
**
** 受保护执行策略：
** - 使用 lua_cpcall 执行编译逻辑
** - 自动处理 Lua 级别的异常和错误
** - 防止编译错误导致程序崩溃
** - 提供清晰的错误信息和诊断
**
** 返回值约定：
** - EXIT_SUCCESS (0): 编译成功完成
** - EXIT_FAILURE (1): 发生错误（通过 fatal 函数退出）
**
** 程序终止路径：
** 1. [正常完成] 所有文件编译成功，返回 EXIT_SUCCESS
** 2. [参数错误] usage 函数显示帮助并以 EXIT_FAILURE 退出
** 3. [致命错误] fatal 函数报告错误并以 EXIT_FAILURE 退出
** 4. [版本显示] doargs 中版本选项可能导致 EXIT_SUCCESS 退出
**
** 内存安全考虑：
** - Lua 状态机自动管理所有内部内存分配
** - 即使发生错误也确保状态机被正确关闭
** - 无手动内存管理，避免内存泄漏风险
**
** 并发和线程安全：
** - 每个进程实例使用独立的 Lua 状态机
** - 全局变量仅在单线程环境中安全
** - 文件操作使用标准 C 库的线程安全保证
**
** 使用示例：
** luac source.lua                    # 编译到 luac.out
** luac -o output.luac source.lua     # 编译到指定文件
** luac -l source.lua                 # 编译并显示字节码
** luac -s source.lua                 # 编译并剥离调试信息
** luac file1.lua file2.lua           # 合并编译多个文件
**
** 兼容性说明：
** - 遵循 POSIX 标准的程序接口约定
** - 支持标准输入输出重定向
** - 跨平台的文件路径和字符编码处理
** - 与 Lua 虚拟机的字节码格式完全兼容
**
** 设计哲学：
** - 简单可靠：最小化复杂性，最大化可靠性
** - 错误透明：提供清晰的错误诊断信息
** - 资源安全：确保系统资源的正确管理
** - 用户友好：提供直观的命令行接口
**
** 注意事项：
** - 程序不支持交互模式，仅用于批量编译
** - 所有错误处理都是致命的，不支持错误恢复
** - 输出格式与 Lua 虚拟机的加载器完全兼容
** - 调试信息的剥离是不可逆的操作
*/
int main(int argc, char* argv[])
{
    lua_State* L;
    struct Smain s;
    int i;
    
    // 解析命令行参数并获取源文件起始位置
    i = doargs(argc, argv);
    
    // 调整参数数组，使其指向源文件列表
    argc -= i;
    argv += i;
    
    // 验证至少提供了一个输入文件
    if (argc <= 0)
    {
        usage("no input files given");
    }
    
    // 创建新的 Lua 虚拟机状态
    L = lua_open();
    if (L == NULL)
    {
        fatal("not enough memory for state");
    }
    
    // 准备受保护调用的参数
    s.argc = argc;
    s.argv = argv;
    
    // 在受保护环境中执行编译逻辑
    if (lua_cpcall(L, pmain, &s) != 0)
    {
        fatal(lua_tostring(L, -1));
    }
    
    // 清理虚拟机资源并成功退出程序
    lua_close(L);
    return EXIT_SUCCESS;
}
