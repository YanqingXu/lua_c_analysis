/*
** [核心] Lua 输入流抽象层头文件 - lzio.h
**
** 本文件定义了 Lua 的缓冲输入流系统，为词法分析器和代码加载器
** 提供统一的字符输入接口。通过抽象化不同的输入源（文件、字符串、
** 内存缓冲区等），实现了灵活高效的字符流读取机制。
**
** 核心设计理念：
** - 流式读取：支持大文件的分块读取，避免全部加载到内存
** - 缓冲机制：内置缓冲区提高小块读取的性能
** - 统一接口：为不同输入源提供一致的访问方式
** - 预读支持：支持词法分析器的前瞻需求
** - 内存管理：集成 Lua 的内存管理系统
**
** 主要组件：
** 1. ZIO 结构体 - 核心输入流对象
** 2. Mbuffer 结构体 - 可增长的内存缓冲区
** 3. 字符读取宏 - 高效的字符访问接口
** 4. 缓冲区管理函数 - 动态内存管理
** 5. 流操作函数 - 读取和预读功能
**
** 应用场景：
** - 词法分析器的字符输入
** - 代码文件的流式解析
** - 字符串和内存数据的统一处理
** - 大文件的分块读取处理
*/

#ifndef lzio_h
#define lzio_h

// Lua 核心头文件
#include "lua.h"    // Lua 核心类型和常量定义
#include "lmem.h"   // Lua 内存管理接口


/*
** ====================================================================
** [核心] 输入流系统常量和类型定义
** ====================================================================
*/

/*
** [常量] 流结束标记
**
** EOZ (End Of Zio) 表示输入流已到达末尾的特殊值。
** 使用 -1 作为结束标记，区别于有效的字符值范围 [0, 255]。
**
** 用途：
** - 标识流的结束状态
** - 区分正常字符和流结束
** - 为词法分析器提供明确的结束信号
*/
#define EOZ	(-1)

/*
** [类型] 输入流对象前向声明
**
** ZIO (Z Input/Output) 是输入流的核心数据结构。
** 使用 typedef 为结构体提供简洁的类型名称。
*/
typedef struct Zio ZIO;

/*
** [实用] 字符到整数转换宏
**
** 功能：安全地将字符转换为非负整数值
** @param c - char: 要转换的字符
** @return int: 字符的无符号整数表示 (0-255)
**
** 转换过程：
** 1. 先转换为 unsigned char，消除符号扩展
** 2. 再转换为 int，确保结果为非负数
**
** 重要性：
** - 防止有符号字符的符号扩展问题
** - 确保所有字符值都映射到 0-255 范围
** - 为哈希计算和查表操作提供一致的值域
**
** 使用场景：
** - 词法分析中的字符分类
** - 字符串哈希计算
** - 字符查表操作
*/
#define char2int(c)	cast(int, cast(unsigned char, (c)))

/*
** [核心] 高效字符读取宏
**
** 功能：从输入流中读取一个字符
** @param z - ZIO*: 输入流指针
** @return int: 读取的字符值，或 EOZ 表示流结束
**
** 优化策略：
** 1. 首先检查缓冲区是否有可用字符 ((z)->n-- > 0)
** 2. 如果有，直接从缓冲区读取 (char2int(*(z)->p++))
** 3. 如果无，调用 luaZ_fill(z) 填充缓冲区
**
** 性能特点：
** - 内联操作，避免函数调用开销
** - 缓冲区命中时只需几个机器指令
** - 缓冲区未命中时才调用较重的填充函数
** - 自动管理缓冲区指针和计数器
**
** 使用注意：
** - 宏参数可能被多次求值，传入时要小心副作用
** - 内部修改流状态，不可重复调用同一表达式
** - 适用于顺序读取，不支持回退操作
*/
#define zgetc(z)  (((z)->n--)>0 ?  char2int(*(z)->p++) : luaZ_fill(z))

/*
** ====================================================================
** [核心] 动态内存缓冲区系统
** ====================================================================
*/

/*
** [核心] 可增长内存缓冲区结构体
**
** Mbuffer (Memory Buffer) 实现了一个可动态调整大小的内存缓冲区，
** 主要用于词法分析器和解析器中的临时数据存储。
**
** 设计特点：
** - 动态增长：根据需要自动扩展缓冲区大小
** - 内存高效：只在需要时分配内存
** - 集成管理：与 Lua 内存管理系统完全集成
** - 重用友好：支持重置和重复使用
**
** 应用场景：
** - 词法分析器的标识符缓存
** - 字符串字面量的构建
** - 临时数据的动态存储
** - 文本处理中的缓冲区管理
*/
typedef struct Mbuffer
{
    char *buffer;      // 缓冲区内存指针
    size_t n;          // 当前已使用的字节数
    size_t buffsize;   // 缓冲区总容量（字节数）
} Mbuffer;

/*
** ====================================================================
** [实用] 缓冲区操作宏定义
** ====================================================================
*/

/*
** [初始化] 缓冲区初始化宏
**
** 功能：将缓冲区初始化为空状态
** @param L - lua_State*: Lua状态机（用于内存分配）
** @param buff - Mbuffer*: 要初始化的缓冲区
**
** 初始化状态：
** - buffer = NULL: 无内存分配
** - buffsize = 0: 容量为零
** - n 字段不需要初始化（使用时会被设置）
**
** 使用场景：
** - 创建新缓冲区时的初始化
** - 重置缓冲区到初始状态
** - 确保缓冲区处于已知的安全状态
*/
#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)

/*
** [访问] 获取缓冲区数据指针宏
**
** 功能：返回缓冲区的数据指针
** @param buff - Mbuffer*: 缓冲区对象
** @return char*: 缓冲区数据的起始地址
**
** 使用注意：
** - 返回的指针可能为 NULL（未分配内存时）
** - 缓冲区重新分配后指针可能改变
** - 主要用于读取缓冲区内容
*/
#define luaZ_buffer(buff)	((buff)->buffer)

/*
** [容量] 获取缓冲区容量宏
**
** 功能：返回缓冲区的总容量
** @param buff - Mbuffer*: 缓冲区对象
** @return size_t: 缓冲区的总字节容量
**
** 说明：
** - 表示缓冲区可存储的最大字节数
** - 不同于当前使用的字节数 (n 字段)
** - 用于容量检查和内存管理
*/
#define luaZ_sizebuffer(buff)	((buff)->buffsize)

/*
** [长度] 获取缓冲区当前长度宏
**
** 功能：返回缓冲区当前已使用的字节数
** @param buff - Mbuffer*: 缓冲区对象
** @return size_t: 当前使用的字节数
**
** 应用：
** - 确定有效数据的长度
** - 计算剩余可用空间
** - 字符串化操作的长度参数
*/
#define luaZ_bufflen(buff)	((buff)->n)

/*
** [重置] 缓冲区重置宏
**
** 功能：重置缓冲区长度为零，准备重新使用
** @param buff - Mbuffer*: 要重置的缓冲区
**
** 重置效果：
** - 逻辑清空缓冲区内容
** - 保留已分配的内存空间
** - 将使用长度重置为 0
** - 不释放底层内存，支持快速重用
**
** 性能优势：
** - 避免重复的内存分配/释放
** - 保持缓冲区容量，减少后续扩展开销
** - 适用于需要重复使用的缓冲区
*/
#define luaZ_resetbuffer(buff) ((buff)->n = 0)


/*
** ====================================================================
** [内存] 缓冲区内存管理宏
** ====================================================================
*/

/*
** [核心] 缓冲区大小调整宏
**
** 功能：调整缓冲区的容量大小
** @param L - lua_State*: Lua状态机（用于内存分配）
** @param buff - Mbuffer*: 要调整的缓冲区
** @param size - size_t: 新的容量大小
**
** 调整机制：
** 1. 使用 luaM_reallocvector 重新分配内存向量
** 2. 从旧容量 (buff)->buffsize 调整到新容量 size
** 3. 更新缓冲区的容量字段
**
** 内存语义：
** - size > buffsize: 扩展缓冲区，保留原有数据
** - size < buffsize: 收缩缓冲区，可能截断数据
** - size = 0: 释放缓冲区，等价于 luaZ_freebuffer
**
** 安全特性：
** - 集成 Lua 的内存管理和垃圾回收
** - 内存不足时会触发垃圾回收或抛出异常
** - 自动处理内存对齐和平台相关问题
**
** 使用场景：
** - 缓冲区容量不足时的动态扩展
** - 优化内存使用的容量收缩
** - 缓冲区大小的精确控制
*/
#define luaZ_resizebuffer(L, buff, size) \
	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
	(buff)->buffsize = size)

/*
** [释放] 缓冲区内存释放宏
**
** 功能：完全释放缓冲区占用的内存
** @param L - lua_State*: Lua状态机
** @param buff - Mbuffer*: 要释放的缓冲区
**
** 释放过程：
** - 将缓冲区大小调整为 0
** - 自动释放所有已分配的内存
** - 重置 buffer 指针为 NULL
** - 重置 buffsize 为 0
**
** 释放后状态：
** - 缓冲区回到初始化后的状态
** - 可安全地重新初始化和使用
** - 不影响 n 字段（使用长度）
**
** 内存管理：
** - 通过 luaZ_resizebuffer(L, buff, 0) 实现
** - 利用 Lua 内存管理器的零大小释放语义
** - 确保内存被正确回收到内存池
*/
#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)


/*
** ====================================================================
** [接口] 公共函数声明
** ====================================================================
*/

/*
** [核心] 缓冲区空间准备函数
**
** 功能：确保缓冲区有足够空间容纳指定字节数
** @param L - lua_State*: Lua状态机
** @param buff - Mbuffer*: 目标缓冲区
** @param n - size_t: 需要的字节数
** @return char*: 可写入的缓冲区地址
**
** 空间保证：
** - 如果当前容量足够，直接返回可用地址
** - 如果容量不足，自动扩展缓冲区
** - 返回的地址至少可写入 n 个字节
**
** 扩展策略：
** - 通常以 2 的幂次增长，避免频繁重分配
** - 考虑内存对齐和平台优化
** - 平衡内存使用和性能考虑
**
** 应用场景：
** - 向缓冲区写入数据前的空间准备
** - 动态字符串构建
** - 流式数据处理的缓冲区管理
*/
LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);

/*
** [核心] 输入流初始化函数
**
** 功能：初始化一个 ZIO 输入流对象
** @param L - lua_State*: Lua状态机
** @param z - ZIO*: 要初始化的流对象
** @param reader - lua_Reader: 数据读取函数
** @param data - void*: 传递给读取函数的用户数据
**
** 初始化过程：
** 1. 设置读取函数和用户数据
** 2. 初始化缓冲区状态
** 3. 关联 Lua 状态机
** 4. 准备第一次读取
**
** 读取函数接口：
** - lua_Reader 是标准的 Lua 读取函数类型
** - 读取函数负责提供数据块
** - 支持文件、字符串、网络等各种数据源
** - 返回 NULL 表示数据结束
**
** 灵活性：
** - 支持任意数据源的抽象
** - 通过函数指针实现多态读取
** - 用户数据机制支持复杂的读取逻辑
*/
LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
                                        void *data);

/*
** [核心] 流数据读取函数
**
** 功能：从输入流中读取指定字节数的数据
** @param z - ZIO*: 输入流对象
** @param b - void*: 目标缓冲区
** @param n - size_t: 要读取的字节数
** @return size_t: 实际读取的字节数
**
** 读取行为：
** - 尽力读取请求的字节数
** - 返回值可能小于请求值（文件结束或错误）
** - 返回 0 表示已到达流的末尾
**
** 缓冲策略：
** - 优先从内部缓冲区读取
** - 缓冲区不足时调用读取函数填充
** - 大块读取可能直接调用底层读取函数
**
** 使用场景：
** - 词法分析器的批量字符读取
** - 二进制数据的块读取
** - 流式数据处理
*/
LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);

/*
** [实用] 流前瞻函数
**
** 功能：查看输入流的下一个字符而不消费它
** @param z - ZIO*: 输入流对象
** @return int: 下一个字符值，或 EOZ 表示流结束
**
** 前瞻特性：
** - 查看但不移动流位置
** - 支持词法分析器的前瞻需求
** - 多次调用返回相同结果
**
** 实现原理：
** - 如果缓冲区有数据，直接返回下一个字符
** - 如果缓冲区为空，尝试填充后返回
** - 不修改流的读取位置
**
** 应用场景：
** - 词法分析中的符号识别
** - 语法分析中的决策制定
** - 条件性的字符读取
*/
LUAI_FUNC int luaZ_lookahead (ZIO *z);



/*
** ====================================================================
** [内部] 私有结构体定义和内部函数
** ====================================================================
*/

/*
** [内部] ZIO 输入流结构体定义
**
** ZIO (Zio Input-Output) 是 Lua 输入流的核心抽象，提供了统一的
** 字符流接口，支持文件、字符串、网络等各种数据源。
**
** 结构设计：
** - 高效缓冲：维护内部缓冲区状态
** - 抽象接口：通过函数指针支持多种数据源
** - 状态管理：跟踪读取位置和剩余数据
** - Lua 集成：与 Lua 内存管理和错误处理集成
**
** 工作原理：
** 1. reader 函数负责从数据源读取数据块
** 2. p 和 n 管理当前缓冲区的状态
** 3. data 传递给 reader 函数的上下文信息
** 4. L 用于内存分配和错误报告
*/
struct Zio
{
    size_t n;          // 缓冲区中剩余未读字节数
    const char *p;     // 当前读取位置指针
    lua_Reader reader; // 数据读取函数指针
    void* data;        // 传递给读取函数的用户数据
    lua_State *L;      // 关联的 Lua 状态机（用于内存管理）
};

/*
** [内部] 缓冲区填充函数
**
** 功能：当缓冲区为空时填充新数据
** @param z - ZIO*: 输入流对象
** @return int: 第一个可用字符，或 EOZ 表示流结束
**
** 内部机制：
** 1. 调用用户提供的读取函数
** 2. 更新缓冲区指针和大小
** 3. 返回缓冲区的第一个字符
**
** 调用时机：
** - 当 zgetc 宏发现缓冲区为空时
** - 由 luaZ_lookahead 在需要时调用
** - 不应被外部代码直接调用
**
** 错误处理：
** - 读取函数返回 NULL 时，表示流结束
** - 设置 z->n = 0 标记缓冲区为空
** - 返回 EOZ 表示没有更多数据
**
** 性能考虑：
** - 这是热点函数，需要高效实现
** - 与 zgetc 宏配合实现快速字符读取
** - 缓冲区大小影响调用频率
*/
LUAI_FUNC int luaZ_fill (ZIO *z);

#endif
