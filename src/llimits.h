/**
 * @file llimits.h
 * @brief Lua虚拟机限制、基本类型和平台相关定义：系统核心基础设施
 * 
 * 详细说明：
 * 本文件是Lua虚拟机的核心基础设施头文件，定义了整个Lua系统的基本类型、
 * 内存限制、虚拟机配置和平台兼容性支持。它为Lua解释器提供了跨平台的
 * 统一接口和性能优化的基础类型定义。
 * 
 * 系统架构定位：
 * - 位于Lua虚拟机架构的最底层，为所有其他模块提供基础定义
 * - 作为平台抽象层，屏蔽不同操作系统和硬件平台的差异
 * - 定义虚拟机的核心限制和配置参数，控制运行时行为
 * - 提供类型安全的转换宏和内存对齐支持
 * 
 * 技术特点：
 * - 使用条件编译实现跨平台兼容性
 * - 基于C99标准，确保广泛的编译器支持
 * - 优化的类型定义，平衡性能和内存使用
 * - 提供调试断言和安全检查机制
 * - 支持嵌入式系统的最小化配置
 * 
 * 依赖关系：
 * - 系统标准库：limits.h（获取系统限制）、stddef.h（基础类型定义）
 * - Lua核心头文件：lua.h（基础Lua类型和宏定义）
 * - 平台特定宏：LUAI_*系列宏（在luaconf.h中定义）
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 处理器要求：支持至少32位整数运算
 * - 内存对齐：支持平台特定的内存对齐要求
 * - 预处理器：支持条件编译和宏展开
 * 
 * 使用示例：
 * @code
 * #include "llimits.h"
 * 
 * // 使用Lua基础类型
 * lu_mem memory_size = MAX_LUMEM;
 * lu_byte small_value = cast_byte(255);
 * Instruction vm_instruction = 0x12345678;
 * 
 * // 类型安全转换
 * lua_Number number_value = cast_num(42);
 * int integer_value = cast_int(number_value);
 * 
 * // 调试断言使用
 * api_check(L, lua_isstring(L, -1));
 * 
 * // 避免未使用变量警告
 * UNUSED(some_parameter);
 * @endcode
 * 
 * 内存安全考虑：
 * - 所有最大值定义都预留安全边界（减2），防止整数溢出
 * - 提供类型安全的强制转换宏，避免不安全的指针操作
 * - 内存对齐类型确保在所有平台上的正确对齐
 * - 指针到整数转换仅用于哈希，不依赖完整指针值
 * 
 * 性能特征：
 * - 基础类型定义针对虚拟机性能优化
 * - 指令类型使用32位无符号整数，平衡速度和内存
 * - 栈大小限制(250)平衡递归深度和内存使用
 * - 字符串表最小大小使用2的幂，优化哈希分布
 * 
 * 线程安全性：
 * - 提供lua_lock/lua_unlock宏，支持用户自定义线程同步
 * - luai_threadyield实现协作式多任务，避免长时间占用CPU
 * - 所有定义都是编译时常量，本身线程安全
 * 
 * 注意事项：
 * - 某些宏依赖luaconf.h中的平台特定定义
 * - MAX_*系列常量的-2偏移是为了避免边界条件错误
 * - 调试宏在发布版本中会被优化掉，不影响性能
 * - 线程同步宏的默认实现为空，需要在多线程环境中重新定义
 * 
 * @author Roberto Ierusalimschy
 * @version 1.69.1.1
 * @date 2007/12/27
 * @since C99
 * @see lua.h, luaconf.h
 */

#ifndef llimits_h
#define llimits_h

// 标准C库头文件
#include <limits.h>     // 系统整数类型限制
#include <stddef.h>     // 标准类型定义（size_t等）

// Lua核心头文件
#include "lua.h"        // Lua基础类型和宏定义

/**
 * @brief Lua 32位无符号整数类型：虚拟机内部使用的标准整数类型
 * 
 * 详细说明：
 * 基于LUAI_UINT32宏定义的32位无符号整数类型，是Lua虚拟机内部
 * 广泛使用的基础整数类型。该类型确保在所有支持的平台上都是
 * 精确的32位宽度，为虚拟机提供一致的数值表示。
 * 
 * 使用场景：
 * - 虚拟机指令编码和解码
 * - 内存地址计算和偏移量表示
 * - 哈希值计算和表索引
 * - 字节码文件的数值字段
 * 
 * 性能特征：
 * - 在32位和64位平台上都有良好的性能表现
 * - 支持高效的位运算操作
 * - 内存占用固定为4字节，便于缓存优化
 * 
 * @since C99
 * @see LUAI_UINT32, Instruction
 */
typedef LUAI_UINT32 lu_int32;

/**
 * @brief Lua无符号内存大小类型：用于表示内存大小和数组索引
 * 
 * 详细说明：
 * 基于LUAI_UMEM宏定义的无符号内存类型，用于表示内存大小、
 * 数组长度、字符串长度等非负数值。该类型的位宽度根据目标
 * 平台的地址空间大小进行优化。
 * 
 * 设计考虑：
 * - 在32位系统上通常为32位无符号整数
 * - 在64位系统上可能为64位无符号整数
 * - 确保能够表示系统的最大内存地址范围
 * 
 * 使用场景：
 * - 字符串长度和缓冲区大小
 * - 表的元素数量和容量
 * - 内存分配器的大小参数
 * - 垃圾收集器的内存统计
 * 
 * @since C99
 * @see LUAI_UMEM, MAX_LUMEM
 */
typedef LUAI_UMEM lu_mem;

/**
 * @brief Lua有符号内存类型：用于表示可能为负的内存相关数值
 * 
 * 详细说明：
 * 基于LUAI_MEM宏定义的有符号内存类型，用于表示可能为负数的
 * 内存相关数值，如偏移量、差值、错误码等。与lu_mem类型配对
 * 使用，提供完整的内存操作数值表示。
 * 
 * 使用场景：
 * - 内存地址偏移量计算
 * - 数组索引的相对位置
 * - 函数返回的错误码
 * - 内存分配失败的标识
 * 
 * @since C99
 * @see LUAI_MEM, lu_mem
 */
typedef LUAI_MEM l_mem;

/**
 * @brief Lua字节类型：用于表示小的自然数和字节数据
 * 
 * 详细说明：
 * 使用unsigned char定义的字节类型，专门用于表示小的自然数值
 * （0-255范围）。这样做的目的是将char类型保留给字符数据使用，
 * 避免混淆数值数据和字符数据。
 * 
 * 设计理念：
 * - 语义清晰：lu_byte表示数值，char表示字符
 * - 类型安全：避免数值和字符的意外混用
 * - 内存效率：单字节存储，适合大量小数值
 * 
 * 使用场景：
 * - 虚拟机操作码和参数
 * - 类型标识和标志位
 * - 小范围的计数器和索引
 * - 字节码文件的控制字节
 * 
 * 取值范围：0-255
 * 
 * @since C99
 * @see cast_byte()
 */
typedef unsigned char lu_byte;

/**
 * @brief size_t类型的最大安全值：防止整数溢出的系统大小限制
 * 
 * 详细说明：
 * 通过位运算计算出size_t类型的最大值，然后减去2作为安全边界。
 * 这个-2的偏移是为了防止在边界计算中出现整数溢出，确保所有
 * 使用该值的操作都是安全的。
 * 
 * 计算过程：
 * 1. ~(size_t)0：生成全1的bit模式，即size_t的最大值
 * 2. 减去2：预留安全边界，防止+1或+2操作时溢出
 * 
 * 使用场景：
 * - 内存分配大小的上限检查
 * - 数组长度的最大值验证
 * - 字符串长度的边界检查
 * - 循环计数器的安全范围
 * 
 * 安全考虑：
 * - 防止size_t类型的算术溢出
 * - 确保内存分配请求的合法性
 * - 避免在边界条件下的未定义行为
 * 
 * @note 在32位系统上约为4GB-2，在64位系统上约为16EB-2
 * @since C99
 */
#define MAX_SIZET  ((size_t)(~(size_t)0) - 2)

/**
 * @brief lu_mem类型的最大安全值：Lua内存类型的上限定义
 * 
 * 详细说明：
 * 与MAX_SIZET类似，计算lu_mem类型的最大安全值。由于lu_mem
 * 是Lua自定义的内存大小类型，该宏确保所有使用lu_mem的操作
 * 都在安全范围内。
 * 
 * 使用场景：
 * - Lua对象大小的上限检查
 * - 字符串和表的最大容量
 * - 垃圾收集器的内存阈值
 * - 虚拟机栈的大小限制
 * 
 * @since C99
 * @see lu_mem, MAX_SIZET
 */
#define MAX_LUMEM  ((lu_mem)(~(lu_mem)0) - 2)

/**
 * @brief 整数类型的最大安全值：防止整数运算溢出
 * 
 * 详细说明：
 * 基于系统定义的INT_MAX，减去2作为安全边界。这确保了所有
 * 使用该值的整数运算都不会导致溢出，特别是在进行+1或+2
 * 操作时仍然在安全范围内。
 * 
 * 安全设计：
 * - INT_MAX是系统定义的int类型最大值
 * - 减2预留空间，防止边界操作溢出
 * - 适用于所有需要安全整数运算的场景
 * 
 * 使用场景：
 * - 循环计数器的上限
 * - 数组索引的边界检查
 * - 算术运算的溢出预防
 * - 虚拟机参数的范围验证
 * 
 * @since C99
 * @see INT_MAX
 */
#define MAX_INT (INT_MAX - 2)

/**
 * @brief 指针到整数的转换宏：用于哈希计算的指针转换
 * 
 * 详细说明：
 * 将指针转换为无符号整数，专门用于哈希计算。这个宏不要求
 * 整数能够完整保存指针的所有信息，只需要提供足够的位数
 * 用于哈希函数的计算。
 * 
 * 设计原理：
 * 1. 先将指针转换为lu_mem类型（保证足够的位宽）
 * 2. 再转换为unsigned int（标准的哈希函数输入类型）
 * 3. 即使在64位系统上丢失高位也不影响哈希效果
 * 
 * 使用限制：
 * - 仅用于哈希计算，不能用于指针重建
 * - 不保证转换的可逆性
 * - 不同指针可能产生相同的整数值（哈希冲突）
 * 
 * 哈希应用：
 * - 表的键值哈希计算
 * - 对象地址的快速比较
 * - 内存布局的统计分析
 * 
 * @param p 要转换的指针
 * @return 用于哈希的无符号整数值
 * 
 * @warning 仅限哈希用途，不能用于指针算术或地址重建
 * @since C99
 */
#define IntPoint(p)  ((unsigned int)(lu_mem)(p))

/**
 * @brief 最大内存对齐类型：确保正确的内存对齐
 * 
 * 详细说明：
 * 基于LUAI_USER_ALIGNMENT_T宏定义的内存对齐类型，确保Lua的
 * 数据结构在所有支持的平台上都能正确对齐。正确的内存对齐
 * 对性能和正确性都至关重要。
 * 
 * 对齐重要性：
 * - 性能：正确对齐的内存访问速度更快
 * - 正确性：某些架构要求特定类型必须对齐
 * - 兼容性：确保在不同平台上的一致行为
 * 
 * 使用场景：
 * - 动态内存分配的对齐要求
 * - 结构体成员的对齐计算
 * - 栈帧和数据块的对齐
 * - 缓存行边界的优化
 * 
 * 平台差异：
 * - x86/x64：通常为8字节或16字节对齐
 * - ARM：可能需要4字节或8字节对齐
 * - 嵌入式系统：根据处理器架构确定
 * 
 * @since C99
 * @see LUAI_USER_ALIGNMENT_T
 */
typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;

/**
 * @brief Lua数值类型的参数转换结果：C函数调用中的数值类型
 * 
 * 详细说明：
 * 基于LUAI_UACNUMBER宏定义的类型，表示lua_Number经过"常规
 * 参数转换"（usual argument conversion）后的结果。这个转换
 * 是C语言规范的一部分，在函数调用时自动发生。
 * 
 * C语言参数转换规则：
 * - float类型会提升为double
 * - 小于int的整数类型会提升为int
 * - 确保参数在栈上的一致表示
 * 
 * 使用场景：
 * - C API函数的参数处理
 * - 可变参数函数的参数提取
 * - 平台无关的数值传递
 * - 与C标准库的接口兼容
 * 
 * 性能考虑：
 * - 避免在函数调用中的重复类型转换
 * - 提供编译器优化的机会
 * - 确保与C调用约定的兼容性
 * 
 * @since C99
 * @see LUAI_UACNUMBER, lua_Number
 */
typedef LUAI_UACNUMBER l_uacNumber;

// === 调试断言系统：开发期间的内部验证机制 ===
#ifdef lua_assert

/**
 * @brief 带表达式求值的条件检查宏：调试模式下的安全验证
 * 
 * 详细说明：
 * 在调试模式下，首先执行断言检查条件c，然后返回表达式e的值。
 * 这种模式结合了运行时验证和正常的表达式求值，确保在开发
 * 阶段能够及时发现逻辑错误。
 * 
 * 工作机制：
 * 1. 使用逗号运算符：lua_assert(c), (e)
 * 2. 先执行lua_assert(c)进行条件检查
 * 3. 然后求值并返回表达式e的结果
 * 4. 如果断言失败，程序会终止
 * 
 * 使用场景：
 * - 函数参数的有效性检查
 * - 复杂计算前的前置条件验证
 * - 数据结构状态的一致性检查
 * 
 * @param c 要检查的条件，失败时触发断言
 * @param e 要返回的表达式
 * @return 表达式e的值
 * 
 * @note 仅在定义了lua_assert时生效
 * @since C99
 */
#define check_exp(c, e)  (lua_assert(c), (e))

/**
 * @brief API调用检查宏：验证Lua C API的使用正确性
 * 
 * 详细说明：
 * 在调试模式下验证API调用的前置条件和参数有效性。这是Lua
 * 内部用于确保C API正确使用的重要机制，帮助开发者在早期
 * 发现API误用问题。
 * 
 * 检查内容：
 * - 函数参数的有效性（非NULL、正确类型等）
 * - Lua状态机的一致性
 * - 栈状态的正确性
 * - API调用序列的合法性
 * 
 * @param l Lua状态机指针
 * @param e 要检查的条件表达式
 * 
 * @since C99
 */
#define api_check(l, e)  lua_assert(e)

#else

/**
 * @brief 空断言宏：发布版本中的断言占位符
 * 
 * 详细说明：
 * 在发布版本中，所有断言都被定义为空操作((void)0)，确保
 * 断言代码不会影响最终产品的性能和大小。这是一种常见的
 * 条件编译技术。
 * 
 * @param c 条件表达式（在发布版本中被忽略）
 * @since C99
 */
#define lua_assert(c)    ((void)0)

/**
 * @brief 发布版本的表达式检查：只返回表达式值
 * 
 * 详细说明：
 * 在发布版本中，跳过条件检查，直接返回表达式的值。这确保
 * 了代码的语义不变，同时移除了调试开销。
 * 
 * @param c 条件（被忽略）
 * @param e 要返回的表达式
 * @return 表达式e的值
 * @since C99
 */
#define check_exp(c, e)  (e)

/**
 * @brief 发布版本的API检查：使用平台特定的轻量级检查
 * 
 * 详细说明：
 * 在发布版本中，使用luai_apicheck进行轻量级的API检查。
 * 这通常是一个平台相关的宏，可能完全禁用检查或使用
 * 更高效的验证机制。
 * 
 * @since C99
 * @see luai_apicheck
 */
#define api_check        luai_apicheck

#endif

/**
 * @brief 未使用变量标记宏：消除编译器警告
 * 
 * 详细说明：
 * 通过将变量转换为void类型来标记该变量为有意未使用，从而
 * 消除编译器的"未使用变量"警告。这在条件编译、调试代码
 * 和向后兼容性处理中特别有用。
 * 
 * 使用场景：
 * - 条件编译中可能未使用的变量
 * - 调试版本中的额外参数
 * - 接口兼容性要求的保留参数
 * - 宏展开后可能未使用的临时变量
 * 
 * 示例用法：
 * @code
 * void function_with_unused_param(int used_param, int unused_param) {
 *     UNUSED(unused_param);  // 消除编译器警告
 *     return used_param * 2;
 * }
 * @endcode
 * 
 * @param x 要标记为未使用的变量
 * @since C99
 */
#ifndef UNUSED
#define UNUSED(x)  ((void)(x))
#endif

// === 类型转换安全宏：提供类型安全的强制转换 ===

/**
 * @brief 通用类型转换宏：安全的类型强制转换
 * 
 * 详细说明：
 * 提供一个统一的类型转换接口，使类型转换更加明确和可读。
 * 虽然功能上等同于C的强制转换操作符，但提供了更好的代码
 * 可读性和维护性。
 * 
 * 安全性考虑：
 * - 明确标识所有类型转换位置
 * - 便于代码审查和类型安全分析
 * - 为将来可能的类型检查机制预留接口
 * 
 * @param t 目标类型
 * @param exp 要转换的表达式
 * @return 转换后的值
 * @since C99
 */
#ifndef cast
#define cast(t, exp)  ((t)(exp))
#endif

/**
 * @brief 字节类型转换宏：安全转换为lu_byte类型
 * 
 * 详细说明：
 * 将任意整数类型安全转换为lu_byte类型（0-255范围）。这个宏
 * 确保转换的明确性，并为将来可能的范围检查预留接口。
 * 
 * 使用场景：
 * - 虚拟机操作码的类型转换
 * - 字符串字节的提取和处理
 * - 小整数值的存储优化
 * 
 * @param i 要转换的整数值
 * @return lu_byte类型的值（0-255）
 * @warning 超出0-255范围的值会被截断
 * @since C99
 */
#define cast_byte(i)  cast(lu_byte, (i))

/**
 * @brief 数值类型转换宏：转换为Lua数值类型
 * 
 * 详细说明：
 * 将任意数值类型转换为lua_Number类型（通常是double）。这是
 * Lua中数值运算的标准类型，所有数值操作都会转换到这个类型。
 * 
 * @param i 要转换的数值
 * @return lua_Number类型的值
 * @since C99
 */
#define cast_num(i)   cast(lua_Number, (i))

/**
 * @brief 整数类型转换宏：转换为标准整数类型
 * 
 * 详细说明：
 * 将任意数值类型转换为标准的int类型。在Lua内部，某些操作
 * 需要使用标准整数类型进行计算。
 * 
 * @param i 要转换的数值
 * @return int类型的值
 * @since C99
 */
#define cast_int(i)   cast(int, (i))

/**
 * @brief 虚拟机指令类型：Lua字节码指令的数据类型
 * 
 * 详细说明：
 * 定义Lua虚拟机指令的数据类型，必须是至少4字节的无符号整数。
 * 这个类型用于存储和操作Lua字节码指令，包含操作码和操作数。
 * 
 * 技术要求：
 * - 至少4字节（32位）宽度
 * - 无符号整数类型，支持位运算
 * - 与lopcodes.h中的指令格式兼容
 * - 足够存储操作码和多个操作数
 * 
 * 指令格式：
 * - 6位操作码（定义指令类型）
 * - 8位参数A（通常是目标寄存器）
 * - 9位参数B（第一个源操作数）
 * - 9位参数C（第二个源操作数）
 * 
 * 使用场景：
 * - 字节码的编译和生成
 * - 虚拟机的指令解码和执行
 * - 指令缓存和优化
 * - 调试信息的指令关联
 * 
 * 性能考虑：
 * - 32位宽度在大多数架构上有最佳性能
 * - 支持单次内存访问读取完整指令
 * - 便于指令的批量处理和缓存
 * 
 * @since C99
 * @see lopcodes.h（指令格式详细定义）
 */
typedef lu_int32 Instruction;

/**
 * @brief Lua函数的最大栈大小：虚拟机栈的容量限制
 * 
 * 详细说明：
 * 定义单个Lua函数可以使用的最大栈槽数量。这个限制确保了
 * 虚拟机的稳定性，防止栈溢出，同时为大多数实际应用提供
 * 足够的栈空间。
 * 
 * 设计考虑：
 * - 250个栈槽平衡了功能性和安全性
 * - 足够支持深度递归和复杂表达式
 * - 防止无限递归导致的栈溢出
 * - 为栈帧管理预留适当的开销空间
 * 
 * 栈使用场景：
 * - 函数参数和局部变量存储
 * - 表达式计算的临时值
 * - 函数调用的返回地址
 * - 异常处理的状态保存
 * 
 * 影响因素：
 * - 函数的参数数量
 * - 局部变量的数量
 * - 表达式的复杂度
 * - 嵌套函数调用的深度
 * 
 * 性能影响：
 * - 较大的栈支持更复杂的操作
 * - 较小的栈减少内存使用
 * - 250是经过优化的平衡值
 * 
 * @note 这是每个函数的局部栈限制，不是全局调用栈限制
 * @since C99
 */
#define MAXSTACK  250

/**
 * @brief 字符串表的最小大小：字符串哈希表的初始容量
 * 
 * 详细说明：
 * 定义Lua字符串表的最小大小，必须是2的幂。字符串表是Lua
 * 用于存储和管理所有字符串的哈希表，使用2的幂大小可以
 * 优化哈希计算和内存分配。
 * 
 * 2的幂的优势：
 * - 哈希函数可以使用快速的位运算（hash & (size-1)）
 * - 内存分配器通常对2的幂大小有优化
 * - 扩容时可以简单地倍增大小
 * - 缓存行对齐的概率更高
 * 
 * 32的选择原因：
 * - 足够小，不会浪费内存
 * - 足够大，减少初期的哈希冲突
 * - 适合小型应用和嵌入式环境
 * - 为字符串操作提供良好的起始性能
 * 
 * 动态调整：
 * - 运行时会根据负载因子动态扩容
 * - 扩容时总是选择下一个2的幂
 * - 负载因子过高时触发重新哈希
 * 
 * 性能影响：
 * - 影响字符串创建和查找的性能
 * - 较大的表减少冲突但增加内存使用
 * - 较小的表节省内存但可能增加冲突
 * 
 * @since C99
 */
#ifndef MINSTRTABSIZE
#define MINSTRTABSIZE  32
#endif

/**
 * @brief 字符串缓冲区的最小大小：字符串操作的缓冲区限制
 * 
 * 详细说明：
 * 定义Lua字符串操作使用的缓冲区最小大小。这个缓冲区用于
 * 字符串的构建、连接、格式化等操作，32字节的大小为大多数
 * 短字符串操作提供了足够的空间。
 * 
 * 使用场景：
 * - 字符串连接操作的临时存储
 * - 数值到字符串的转换
 * - 格式化字符串的构建
 * - 字符串模式匹配的工作空间
 * 
 * 32字节的考虑：
 * - 足够容纳大多数数值的字符串表示
 * - 适合短字符串的临时操作
 * - 在栈上分配时不会造成过大开销
 * - 可以容纳常见的错误消息和提示
 * 
 * 动态扩展：
 * - 超过最小大小时会动态分配更大缓冲区
 * - 使用倍增策略减少重新分配次数
 * - 操作完成后释放额外分配的内存
 * 
 * @since C99
 */
#ifndef LUA_MINBUFFER
#define LUA_MINBUFFER  32
#endif

// === 线程同步机制：多线程环境的支持 ===

/**
 * @brief Lua状态锁定宏：进入临界区的同步机制
 * 
 * 详细说明：
 * 默认定义为空操作，允许用户在多线程环境中重新定义为实际的
 * 锁定操作。这个宏在访问Lua状态机的共享数据前调用，确保
 * 线程安全。
 * 
 * 重定义示例：
 * @code
 * #undef lua_lock
 * #define lua_lock(L) pthread_mutex_lock(&(L)->mutex)
 * @endcode
 * 
 * 使用时机：
 * - 修改Lua状态机的内部数据前
 * - 执行可能影响其他线程的操作前
 * - 进入需要原子性的代码段前
 * 
 * @param L Lua状态机指针
 * @since C99
 */
#ifndef lua_lock
#define lua_lock(L)     ((void)0)

/**
 * @brief Lua状态解锁宏：退出临界区的同步机制
 * 
 * 详细说明：
 * 与lua_lock配对使用，在完成对Lua状态机的访问后调用。
 * 默认为空操作，用户可以根据需要重新定义。
 * 
 * @param L Lua状态机指针
 * @since C99
 */
#define lua_unlock(L)   ((void)0)
#endif

/**
 * @brief 线程让步宏：协作式多任务的CPU让步机制
 * 
 * 详细说明：
 * 实现协作式多任务的CPU让步机制，通过先解锁再重新锁定来
 * 给其他线程执行的机会。这防止了长时间运行的操作独占CPU
 * 资源。
 * 
 * 工作原理：
 * 1. lua_unlock(L)：释放当前锁，允许其他线程访问
 * 2. lua_lock(L)：重新获取锁，继续执行
 * 3. 在解锁和重新锁定之间，其他线程有机会执行
 * 
 * 使用场景：
 * - 长时间运行的循环中
 * - 垃圾收集的暂停点
 * - 大量数据处理的间隙
 * - 防止饥饿的主动让步
 * 
 * 注意事项：
 * - 在让步点，状态机的状态可能被其他线程修改
 * - 需要在让步后重新验证关键状态
 * - 不应在持有临时状态的代码段中调用
 * 
 * @param L Lua状态机指针
 * @since C99
 */
#ifndef luai_threadyield
#define luai_threadyield(L)  {lua_unlock(L); lua_lock(L);}
#endif

// === 栈测试机制：内存管理的压力测试 ===

/**
 * @brief 栈重新分配测试控制宏：开发期间的压力测试机制
 * 
 * 详细说明：
 * 在非测试模式下定义为空操作，在HARDSTACKTESTS模式下执行
 * 传入的测试代码。这个机制用于对栈重新分配进行压力测试，
 * 帮助发现内存管理中的潜在问题。
 * 
 * 测试目的：
 * - 验证栈扩容和收缩的正确性
 * - 测试极端内存条件下的稳定性
 * - 发现内存泄漏和悬垂指针
 * - 验证栈指针的一致性
 * 
 * 在测试模式下可能执行的操作：
 * - 强制栈重新分配
 * - 模拟内存不足的情况
 * - 验证栈内容的完整性
 * - 检查栈指针的有效性
 * 
 * @param x 测试代码（仅在HARDSTACKTESTS模式下执行）
 * @since C99
 */
#ifndef HARDSTACKTESTS
#define condhardstacktests(x)  ((void)0)
#else
/**
 * @brief 硬栈测试模式：执行栈压力测试代码
 * 
 * 详细说明：
 * 在定义了HARDSTACKTESTS的情况下，执行传入的测试代码。
 * 这通常用于开发和调试阶段，对栈管理进行严格的测试。
 * 
 * @param x 要执行的测试代码
 * @since C99
 */
#define condhardstacktests(x)  x
#endif

#endif
