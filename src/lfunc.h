/*
** ====================================================================
** Lua 函数和闭包管理模块头文件 (lfunc.h)
** ====================================================================
** 
** 文件标识: $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
** 功能描述: 操作函数原型和闭包的辅助函数
** 版权信息: 参见 lua.h 中的版权声明
** 
** 模块概述:
** 本头文件定义了 Lua 函数系统的核心管理接口，包括函数原型、
** 闭包对象、上值管理和局部变量处理。这些函数为 Lua 的函数
** 机制提供了完整的生命周期管理和内存操作支持。
** 
** 主要功能领域:
** 1. 函数原型管理 - 字节码函数的元数据和结构
** 2. 闭包对象管理 - Lua闭包和C闭包的创建和释放
** 3. 上值系统 - 闭包环境的捕获和共享机制
** 4. 内存管理 - 函数相关对象的分配和垃圾回收
** 5. 调试支持 - 局部变量名称查询和调试信息
** 6. 大小计算 - 动态对象的内存大小计算
** 
** 核心概念:
** - Proto: 函数原型，包含字节码、常量、调试信息
** - Closure: 闭包对象，函数+环境的组合
** - UpVal: 上值对象，闭包捕获的外层变量
** - CClosure: C函数闭包
** - LClosure: Lua函数闭包
** 
** 设计目标:
** - 提供高效的函数对象管理
** - 支持闭包的动态创建和共享
** - 实现上值的智能缓存和重用
** - 为垃圾回收提供完整的对象接口
** - 支持调试器的变量查询功能
** 
** 依赖关系:
** - lobject.h: Lua 对象系统和核心类型定义
** - lstate.h: 虚拟机状态管理（间接依赖）
** - lgc.h: 垃圾回收系统（间接依赖）
** 
** 注意事项:
** - 所有分配函数可能触发垃圾回收
** - 上值管理需要正确处理引用关系
** - 闭包创建涉及复杂的内存布局
** - 函数释放需要递归清理所有依赖对象
** ====================================================================
*/

/*
** ====================================================================
** [预处理] 头文件保护和依赖包含
** ====================================================================
*/

#ifndef lfunc_h
#define lfunc_h

/*
** ====================================================================
** [依赖] 核心依赖模块包含
** ====================================================================
*/

/*
** [核心依赖] Lua 对象系统
** 
** 包含 lobject.h 以获取：
** - Proto 结构体定义（函数原型）
** - Closure 结构体定义（闭包对象）
** - CClosure 和 LClosure 结构体定义
** - UpVal 结构体定义（上值对象）
** - TValue 类型定义（Lua 值表示）
** - Table 结构体定义（环境表）
** - StkId 类型定义（栈索引）
*/
#include "lobject.h"


/*
** ====================================================================
** [实用] 闭包对象大小计算宏
** ====================================================================
*/

/*
** [实用] C 闭包对象大小计算宏
**
** 功能：计算 C 函数闭包对象的内存大小
** @param n: int 上值数量
** @return: int 所需的字节数
**
** 大小计算公式：
** sizeof(CClosure) + sizeof(TValue) * (n-1)
**
** 内存布局说明：
** - CClosure 结构体包含一个 TValue 数组成员
** - 基础结构已包含一个 TValue 的空间
** - 额外的上值需要 (n-1) 个 TValue 空间
** - 所有上值存储为 TValue 对象
**
** C 闭包特点：
** - 上值直接存储在闭包对象中
** - 不需要额外的 UpVal 对象
** - 内存布局紧凑，访问效率高
** - 上值在闭包创建时确定，不可变
**
** 使用场景：
** - 内存分配器计算分配大小
** - 垃圾回收器计算对象大小
** - 调试工具的内存分析
** - 性能分析的内存统计
**
** 注意事项：
** - n 必须大于 0，否则计算错误
** - 结果用于 luaM_malloc 等内存分配函数
** - 大小包含完整的对象头部信息
*/
#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
                         cast(int, sizeof(TValue)*((n)-1)))

/*
** [实用] Lua 闭包对象大小计算宏
**
** 功能：计算 Lua 函数闭包对象的内存大小
** @param n: int 上值数量
** @return: int 所需的字节数
**
** 大小计算公式：
** sizeof(LClosure) + sizeof(TValue*) * (n-1)
**
** 内存布局说明：
** - LClosure 结构体包含一个 UpVal* 数组成员
** - 基础结构已包含一个指针的空间
** - 额外的上值需要 (n-1) 个指针空间
** - 存储的是 UpVal 对象的指针，不是值本身
**
** Lua 闭包特点：
** - 上值通过 UpVal 对象间接访问
** - 支持上值的共享和重用
** - 允许上值的动态关闭
** - 内存布局灵活，支持复杂的作用域
**
** 与 C 闭包的区别：
** - 存储指针而非值，支持共享
** - 需要额外的 UpVal 对象管理
** - 支持更复杂的作用域规则
** - 垃圾回收处理更复杂
**
** 应用场景：
** - Lua 函数闭包的内存分配
** - 闭包对象的垃圾回收处理
** - 内存使用量的统计和分析
** - 调试工具的对象分析
*/
#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
                         cast(int, sizeof(TValue *)*((n)-1)))


/*
** ====================================================================
** [核心] 函数原型和闭包创建函数
** ====================================================================
*/

/*
** [核心] 函数原型创建函数
**
** 功能：创建新的 Lua 函数原型对象
** @param L: lua_State* Lua 虚拟机状态指针
** @return: Proto* 新创建的函数原型指针
**
** 函数原型内容：
** - 字节码指令数组：函数的可执行指令
** - 常量池：函数使用的字面量常量
** - 子函数列表：嵌套函数的原型
** - 局部变量信息：调试和作用域管理
** - 上值信息：闭包捕获的变量描述
** - 行号信息：调试和错误报告支持
**
** 初始状态：
** - 所有数组和指针初始化为空或 NULL
** - 各种计数器设置为 0
** - 分配基本的结构体内存
** - 注册到垃圾回收系统
**
** 内存管理：
** - 使用垃圾回收器分配内存
** - 自动注册为 GC 对象
** - 支持递归释放子对象
** - 线程安全的分配机制
**
** 使用场景：
** - 编译器生成新函数时
** - 代码加载和解析过程
** - 动态代码生成
** - 函数模板的创建
**
** 后续操作：
** - 需要填充字节码和常量
** - 设置调试信息和元数据
** - 建立与闭包的关联
** - 注册到函数原型表
*/
LUAI_FUNC Proto *luaF_newproto (lua_State *L);

/*
** [核心] C 函数闭包创建函数
**
** 功能：创建新的 C 函数闭包对象
** @param L: lua_State* Lua 虚拟机状态指针
** @param nelems: int 上值数量
** @param e: Table* 环境表指针
** @return: Closure* 新创建的 C 闭包指针
**
** C 闭包特性：
** - 包装 C 函数为 Lua 可调用对象
** - 支持上值的直接存储
** - 提供环境表的访问
** - 高效的调用性能
**
** 上值处理：
** - 上值直接存储在闭包对象中
** - 每个上值占用一个 TValue 空间
** - 支持任意类型的上值
** - 在闭包创建时固定数量
**
** 环境表：
** - 设置闭包的全局环境
** - 影响全局变量的访问
** - 支持沙箱和隔离机制
** - 可以为 NULL 使用默认环境
**
** 内存布局：
** - 使用 sizeCclosure(nelems) 计算大小
** - 连续的内存布局，访问高效
** - 上值数组紧跟结构体主体
** - 对齐要求满足性能需求
**
** 应用场景：
** - C 函数注册到 Lua 环境
** - 库函数的闭包封装
** - 回调函数的上下文保存
** - 插件系统的函数注册
*/
LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e);

/*
** [核心] Lua 函数闭包创建函数
**
** 功能：创建新的 Lua 函数闭包对象
** @param L: lua_State* Lua 虚拟机状态指针
** @param nelems: int 上值数量
** @param e: Table* 环境表指针
** @return: Closure* 新创建的 Lua 闭包指针
**
** Lua 闭包特性：
** - 包装 Lua 函数原型为可执行对象
** - 支持复杂的上值共享机制
** - 提供完整的词法作用域
** - 支持动态的上值关闭
**
** 上值管理：
** - 存储 UpVal 对象指针数组
** - 支持上值的共享和重用
** - 允许上值的动态关闭
** - 复杂的生命周期管理
**
** 作用域支持：
** - 完整的词法作用域实现
** - 嵌套函数的变量捕获
** - 动态作用域的支持
** - 闭包链的构建
**
** 环境表处理：
** - 设置函数的全局环境
** - 支持函数级别的环境隔离
** - 继承或重写环境设置
** - 动态环境切换支持
**
** 内存管理：
** - 使用 sizeLclosure(nelems) 计算大小
** - 指针数组的动态管理
** - 与 UpVal 对象的引用关系
** - 垃圾回收的复杂处理
**
** 关联对象：
** - 必须关联有效的 Proto 对象
** - 需要正确的 UpVal 对象设置
** - 环境表的生命周期管理
** - 调试信息的传播
*/
LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e);
/*
** ====================================================================
** [管理] 上值对象管理函数
** ====================================================================
*/

/*
** [管理] 上值对象创建函数
**
** 功能：创建新的上值对象
** @param L: lua_State* Lua 虚拟机状态指针
** @return: UpVal* 新创建的上值对象指针
**
** 上值对象结构：
** - value: TValue 存储上值的实际数据
** - next: UpVal* 上值链表的下一个节点
** - v: TValue* 指向值的位置（栈或value字段）
** - 垃圾回收标记和类型信息
**
** 初始状态：
** - value 字段初始化为 nil
** - v 指针指向自身的 value 字段
** - next 指针设置为 NULL
** - 标记为白色（垃圾回收状态）
**
** 生命周期：
** - 创建：函数需要捕获变量时
** - 打开状态：指向栈上的活动变量
** - 关闭状态：复制栈值到本地存储
** - 销毁：垃圾回收时释放
**
** 内存管理：
** - 使用垃圾回收器分配
** - 注册到全局上值链表
** - 支持自动内存回收
** - 引用计数和可达性分析
**
** 使用场景：
** - 闭包创建时的变量捕获
** - 嵌套函数的作用域处理
** - 动态作用域的实现
** - 变量生命周期的扩展
*/
LUAI_FUNC UpVal *luaF_newupval (lua_State *L);

/*
** [管理] 上值查找和重用函数
**
** 功能：查找或创建指向指定栈位置的上值对象
** @param L: lua_State* Lua 虚拟机状态指针
** @param level: StkId 栈上变量的位置
** @return: UpVal* 对应的上值对象指针
**
** 查找机制：
** - 搜索现有的打开上值链表
** - 如果找到指向相同位置的上值，直接返回
** - 如果没找到，创建新的上值对象
** - 维护上值链表的有序性
**
** 共享优化：
** - 多个闭包可以共享同一个上值
** - 避免重复创建相同位置的上值
** - 减少内存使用和管理复杂度
** - 保证变量修改的一致性
**
** 链表管理：
** - 按栈位置顺序维护上值链表
** - 新上值插入到正确的位置
** - 支持高效的查找和插入操作
** - 自动维护链表的完整性
**
** 栈位置处理：
** - level 指向栈上的具体变量位置
** - 上值的 v 指针指向该栈位置
** - 变量的修改通过上值同步
** - 支持栈的动态变化
**
** 性能优化：
** - 有序链表支持快速查找
** - 避免重复创建和分配
** - 最小化内存碎片
** - 高效的缓存利用
**
** 线程安全：
** - 每个 lua_State 维护独立的上值链表
** - 不需要跨线程同步
** - 协程间的上值隔离
** - 安全的并发访问
*/
LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);

/*
** [管理] 上值关闭函数
**
** 功能：关闭指定栈位置及以上的所有上值
** @param L: lua_State* Lua 虚拟机状态指针
** @param level: StkId 关闭的起始栈位置
**
** 关闭机制：
** - 遍历打开的上值链表
** - 找到指向 level 及以上位置的上值
** - 将栈上的值复制到上值的 value 字段
** - 更新 v 指针指向 value 字段
** - 从打开上值链表中移除
**
** 关闭时机：
** - 函数返回前关闭局部变量
** - 块作用域结束时关闭变量
** - 协程挂起时关闭活动变量
** - 错误处理时的清理操作
**
** 值拷贝：
** - 将栈上的 TValue 完整复制
** - 保持类型和垃圾回收标记
** - 处理字符串和表等引用类型
** - 确保数据的完整性
**
** 链表维护：
** - 从打开上值链表中移除已关闭的上值
** - 保持链表的有序性和完整性
** - 更新链表指针和引用
** - 处理链表为空的边界情况
**
** 内存影响：
** - 关闭的上值成为独立对象
** - 不再依赖栈的生命周期
** - 可能增加内存使用
** - 支持更长的生命周期
**
** 垃圾回收：
** - 关闭的上值仍受垃圾回收管理
** - 无引用的上值会被自动回收
** - 保持对象图的一致性
** - 支持循环引用的检测
*/
LUAI_FUNC void luaF_close (lua_State *L, StkId level);
/*
** ====================================================================
** [内存] 对象释放和清理函数
** ====================================================================
*/

/*
** [内存] 函数原型释放函数
**
** 功能：释放函数原型对象及其所有相关资源
** @param L: lua_State* Lua 虚拟机状态指针
** @param f: Proto* 要释放的函数原型指针
**
** 释放内容：
** - 字节码指令数组：释放指令内存
** - 常量池数组：释放常量对象
** - 子函数数组：递归释放子函数原型
** - 局部变量信息：释放变量名和作用域信息
** - 上值信息：释放上值描述数据
** - 行号信息：释放调试行号数组
** - 源文件名：释放文件名字符串引用
**
** 递归清理：
** - 递归释放所有子函数原型
** - 处理嵌套函数的依赖关系
** - 确保不留内存泄漏
** - 维护对象图的一致性
**
** 垃圾回收协作：
** - 由垃圾回收器调用
** - 处理循环引用的情况
** - 更新全局对象计数
** - 触发相关对象的清理
**
** 调试信息处理：
** - 释放局部变量名数组
** - 清理行号映射信息
** - 释放源文件名引用
** - 处理调试钩子的清理
**
** 常量池清理：
** - 释放字符串常量的引用
** - 处理数字和其他常量
** - 清理嵌套表和函数常量
** - 维护引用计数的正确性
**
** 内存安全：
** - 防止重复释放
** - 处理空指针的情况
** - 确保释放顺序的正确性
** - 避免访问已释放的内存
*/
LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);

/*
** [内存] 闭包对象释放函数
**
** 功能：释放闭包对象及其相关资源
** @param L: lua_State* Lua 虚拟机状态指针
** @param c: Closure* 要释放的闭包指针
**
** 闭包类型处理：
** - C 闭包：释放上值数组和闭包结构
** - Lua 闭包：处理 UpVal 指针数组
** - 不直接释放函数原型（可能被共享）
** - 处理环境表的引用释放
**
** C 闭包清理：
** - 释放存储在闭包中的上值
** - 清理 C 函数指针（无需特殊处理）
** - 释放闭包对象的内存
** - 更新垃圾回收统计
**
** Lua 闭包清理：
** - 不释放 UpVal 对象（可能被其他闭包共享）
** - 只释放指针数组和闭包结构
** - UpVal 对象由单独的 GC 处理
** - 维护上值共享的正确性
**
** 环境表处理：
** - 减少环境表的引用计数
** - 不直接释放环境表对象
** - 由垃圾回收器处理表的生命周期
** - 保持环境表的共享语义
**
** 内存布局考虑：
** - 根据闭包类型计算正确的大小
** - 处理动态分配的上值数组
** - 考虑内存对齐和填充
** - 使用正确的释放函数
**
** 垃圾回收集成：
** - 由 GC 在标记清除阶段调用
** - 处理弱引用和终结器
** - 更新内存使用统计
** - 触发相关对象的清理检查
*/
LUAI_FUNC void luaF_freeclosure (lua_State *L, Closure *c);

/*
** [内存] 上值对象释放函数
**
** 功能：释放上值对象的内存
** @param L: lua_State* Lua 虚拟机状态指针
** @param uv: UpVal* 要释放的上值对象指针
**
** 释放处理：
** - 释放 UpVal 结构体本身的内存
** - 不释放 value 字段中的 Lua 对象
** - TValue 中的对象由垃圾回收器单独处理
** - 简单的内存块释放操作
**
** 生命周期管理：
** - 由垃圾回收器在清除阶段调用
** - 确保没有其他对象引用此上值
** - 处理上值链表的完整性
** - 维护内存分配的一致性
**
** 值的处理：
** - value 字段中的 TValue 对象不需要特殊释放
** - 引用类型对象由 GC 统一管理
** - 基本类型值无需额外处理
** - 保持垃圾回收的语义一致性
**
** 链表维护：
** - 上值应该已从所有链表中移除
** - 不需要更新链表指针
** - 由调用者确保链表的一致性
** - 防止悬空指针的产生
**
** 内存统计：
** - 更新垃圾回收器的内存计数
** - 提供内存使用的准确统计
** - 支持内存分析和调优
** - 维护系统的内存平衡
**
** 错误处理：
** - 处理空指针的情况
** - 防止重复释放
** - 确保释放的原子性
** - 维护系统的稳定性
*/
LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
/*
** ====================================================================
** [调试] 局部变量信息查询函数
** ====================================================================
*/

/*
** [调试] 局部变量名称获取函数
**
** 功能：获取指定位置的局部变量名称
** @param func: const Proto* 函数原型指针
** @param local_number: int 局部变量编号（从1开始）
** @param pc: int 程序计数器位置
** @return: const char* 变量名称，如果无效则返回 NULL
**
** 变量编号：
** - local_number 从 1 开始计数
** - 0 通常表示无效或特殊用途
** - 编号对应变量在局部变量表中的位置
** - 可能包括临时变量和编译器生成的变量
**
** 作用域检查：
** - 检查变量在指定 pc 位置是否有效
** - 变量的作用域由 startpc 和 endpc 定义
** - 超出作用域的变量不会返回名称
** - 支持嵌套作用域和块级变量
**
** 调试信息依赖：
** - 需要函数原型包含完整的调试信息
** - locvars 数组存储局部变量的详细信息
** - 变量名存储为字符串对象
** - 编译时生成，运行时查询
**
** 变量类型：
** - 普通局部变量：用户定义的变量
** - 参数变量：函数的形式参数
** - 临时变量：表达式计算的中间结果
** - 编译器变量：编译器内部使用的变量
**
** 应用场景：
** - 调试器显示变量名称
** - 错误报告中的变量信息
** - 性能分析工具的变量跟踪
** - 交互式环境的变量检查
**
** 特殊情况处理：
** - 编译时优化可能移除变量信息
** - 临时变量可能没有有意义的名称
** - 某些变量可能使用内部生成的名称
** - 重复名称的变量需要作用域区分
**
** 性能考虑：
** - 线性搜索局部变量表
** - 调试信息的查询开销
** - 字符串比较和作用域检查
** - 通常在调试模式下使用
**
** 返回值处理：
** - 返回指向字符串对象内容的指针
** - 字符串生命周期由函数原型管理
** - NULL 表示变量无效或不存在
** - 不需要调用者释放返回的字符串
**
** 线程安全：
** - 只读操作，对函数原型无修改
** - 多线程环境下安全调用
** - 不涉及全局状态的修改
** - 字符串对象的不可变性保证安全
*/
LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
                                         int pc);


/*
** ====================================================================
** [总结] Lua 函数和闭包管理模块总结
** ====================================================================
**
** 本头文件是 Lua 函数系统的核心管理模块，提供了函数原型、闭包
** 对象和上值系统的完整生命周期管理。这是 Lua 语言函数机制的
** 基础设施。
**
** 核心对象体系：
**
** 1. [函数原型 (Proto)]
**    - 包含字节码、常量池、调试信息的完整函数描述
**    - 支持嵌套函数和递归定义
**    - 编译时生成，运行时共享
**    - 垃圾回收管理的复杂对象
**
** 2. [闭包对象 (Closure)]
**    - C 闭包：直接存储上值，高效调用
**    - Lua 闭包：指针数组，支持复杂作用域
**    - 函数+环境的完整执行单元
**    - 动态创建，灵活的内存布局
**
** 3. [上值对象 (UpVal)]
**    - 变量捕获的核心机制
**    - 打开/关闭状态的生命周期管理
**    - 共享和重用的优化策略
**    - 复杂的链表管理系统
**
** 功能模块划分：
**
** 1. [对象创建]
**    - luaF_newproto: 函数原型的初始化
**    - luaF_newCclosure: C 闭包的高效创建
**    - luaF_newLclosure: Lua 闭包的复杂构建
**    - luaF_newupval: 上值对象的基础分配
**
** 2. [上值管理]
**    - luaF_findupval: 智能查找和重用机制
**    - luaF_close: 作用域结束的关闭处理
**    - 有序链表的维护和优化
**    - 栈到堆的值迁移机制
**
** 3. [内存管理]
**    - luaF_freeproto: 复杂对象的递归释放
**    - luaF_freeclosure: 类型特定的清理策略
**    - luaF_freeupval: 简单对象的直接释放
**    - 垃圾回收器的完整集成
**
** 4. [调试支持]
**    - luaF_getlocalname: 变量名称的作用域查询
**    - 调试信息的完整管理
**    - 性能分析的基础支持
**    - 交互式调试的变量检查
**
** 5. [内存计算]
**    - sizeCclosure: C 闭包的紧凑布局
**    - sizeLclosure: Lua 闭包的指针数组
**    - 动态大小的精确计算
**    - 内存分配器的接口支持
**
** 设计特点：
**
** 1. [性能优化]
**    - C 闭包的直接存储策略
**    - 上值的查找和重用机制
**    - 内存布局的缓存友好性
**    - 垃圾回收的最小化开销
**
** 2. [内存效率]
**    - 动态大小的精确计算
**    - 对象共享的最大化利用
**    - 紧凑的数据结构设计
**    - 智能的内存重用策略
**
** 3. [功能完整性]
**    - 支持复杂的词法作用域
**    - 完整的闭包语义实现
**    - 强大的调试信息支持
**    - 灵活的环境表机制
**
** 4. [系统集成]
**    - 与垃圾回收器的深度集成
**    - 与编译器的紧密协作
**    - 与虚拟机的高效交互
**    - 与调试系统的完整支持
**
** 上值管理机制：
**
** 1. [状态转换]
**    打开状态 → 关闭状态 → 垃圾回收
**
** 2. [共享策略]
**    查找重用 → 创建新对象 → 维护链表 → 优化访问
**
** 3. [生命周期]
**    栈变量 → 上值捕获 → 关闭拷贝 → 独立存在 → 自动回收
**
** 闭包创建流程：
**
** 1. [大小计算]
**    确定上值数量 → 计算内存大小 → 分配内存块 → 初始化结构
**
** 2. [环境设置]
**    设置环境表 → 配置全局访问 → 建立作用域链 → 完成初始化
**
** 3. [上值绑定]
**    查找现有上值 → 创建新上值 → 建立引用关系 → 优化访问路径
**
** 内存管理策略：
**
** 1. [分配策略]
**    - 垃圾回收器统一分配
**    - 类型特定的大小计算
**    - 对齐和性能的平衡
**    - 内存池的优化利用
**
** 2. [释放策略]
**    - 标记清除的集成
**    - 递归释放的安全性
**    - 引用计数的维护
**    - 循环引用的处理
**
** 3. [优化策略]
**    - 对象重用的最大化
**    - 内存碎片的最小化
**    - 缓存局部性的优化
**    - 分配延迟的优化
**
** 与其他模块的协作：
** - lstate.c: 虚拟机状态的函数对象管理
** - lgc.c: 垃圾回收的对象生命周期
** - lvm.c: 虚拟机执行的函数调用
** - lapi.c: C API 的函数对象接口
** - lparser.c: 编译器的函数原型生成
** - ldebug.c: 调试系统的变量查询
**
** 扩展性考虑：
** - 新的闭包类型可以轻松添加
** - 上值机制支持扩展语义
** - 调试信息可以增强
** - 内存管理策略可以优化
**
** 质量保证：
** - 完整的对象生命周期管理
** - 安全的内存操作
** - 一致的垃圾回收集成
** - 可靠的调试支持
*/

#endif
