/**
 * @file lparser.h
 * @brief Lua语法解析器接口：实现从源代码到字节码的编译过程
 * 
 * 详细说明：
 * 这个头文件定义了Lua语法解析器的核心数据结构和接口，实现了从Lua源代码
 * 到字节码的完整编译过程。解析器采用递归下降的解析策略，结合了语法分析
 * 和代码生成，能够一遍扫描就生成高质量的字节码。这种设计既保证了编译
 * 效率，又生成了紧凑高效的字节码。
 * 
 * 系统架构定位：
 * - 位于Lua编译器的前端，负责语法分析和代码生成
 * - 与词法分析器(llex)紧密配合，接收词法单元流
 * - 与代码生成器(lcode)协作，生成优化的字节码指令
 * - 与对象系统(lobject)集成，创建函数原型和常量表
 * 
 * 技术特点：
 * - 递归下降解析：自顶向下的语法分析方法
 * - 一遍编译：语法分析和代码生成同时进行
 * - 表达式优化：支持常量折叠和表达式化简
 * - 跳转修补：延迟绑定的控制流代码生成
 * - 局部变量优化：寄存器分配和生命周期管理
 * - 嵌套函数支持：处理闭包和upvalue的复杂关系
 * 
 * 依赖关系：
 * - llimits.h: Lua系统限制，定义最大值和配置常量
 * - lobject.h: Lua对象系统，提供Proto和TValue定义
 * - lzio.h: 缓冲I/O系统，提供输入流抽象
 * 
 * 编译要求：
 * - C标准版本：C99或更高版本
 * - 枚举类型支持：用于表达式类型分类
 * - 联合体支持：优化内存使用的数据结构
 * - 位域支持：紧凑的upvalue描述符
 * 
 * 使用示例：
 * @code
 * #include "lparser.h"
 * #include "lzio.h"
 * 
 * // 编译Lua源代码为函数原型
 * const char *source = "function add(a, b) return a + b end";
 * size_t size = strlen(source);
 * 
 * // 创建输入流
 * ZIO z;
 * luaZ_init(L, &z, string_reader, &source);
 * 
 * // 创建缓冲区
 * Mbuffer buff;
 * luaZ_initbuffer(L, &buff);
 * 
 * // 解析源代码生成函数原型
 * Proto *main_proto = luaY_parser(L, &z, &buff, "chunk");
 * 
 * // 执行生成的字节码
 * Closure *cl = luaF_newLclosure(L, main_proto->nups, gt);
 * cl->l.p = main_proto;
 * @endcode
 * 
 * 编译流程：
 * 1. 词法分析：将源代码分解为词法单元
 * 2. 语法分析：构建抽象语法树结构
 * 3. 语义分析：类型检查和作用域分析
 * 4. 代码生成：生成优化的字节码指令
 * 5. 优化处理：常量折叠和跳转优化
 * 
 * 性能特征：
 * - 线性时间复杂度：O(n)的编译时间，n为源代码长度
 * - 内存效率：紧凑的中间表示和代码生成
 * - 寄存器优化：有效的局部变量和临时值管理
 * - 常量优化：编译时常量计算和合并
 * 
 * 错误处理：
 * - 语法错误检测：精确的错误位置和描述
 * - 错误恢复：尽可能多地检测语法错误
 * - 异常安全：编译失败时的资源清理
 * 
 * 注意事项：
 * - 解析器状态复杂，需要仔细管理嵌套上下文
 * - 代码生成过程中可能触发内存分配和垃圾收集
 * - 语法错误可能导致longjmp，需要适当的错误处理
 * - 大型源文件可能需要较多内存存储中间结果
 * 
 * @author Roberto Ierusalimschy
 * @version 1.57.1.1
 * @date 2007/12/27
 * @since Lua 5.1
 * @see llex.h, lcode.h, lobject.h
 */

#ifndef lparser_h
#define lparser_h

#include "llimits.h"
#include "lobject.h"
#include "lzio.h"

/**
 * @brief 表达式描述符类型：定义不同种类表达式的分类和特征
 * 
 * 详细说明：
 * 这个枚举定义了Lua语言中所有可能的表达式类型，每种类型都有特定的
 * 语义和代码生成策略。解析器根据表达式的类型来决定如何生成对应的
 * 字节码指令，这种分类系统是编译器优化的基础。
 * 
 * 表达式分类原则：
 * - 按值的来源和性质分类
 * - 按代码生成策略分类
 * - 按运行时访问方式分类
 * - 按优化可能性分类
 * 
 * 代码生成策略：
 * - 立即值：直接嵌入指令或常量表
 * - 寄存器值：通过寄存器访问
 * - 内存值：通过表索引或全局访问
 * - 控制流：跳转和分支指令
 * 
 * 优化机会：
 * - 常量表达式可以编译时计算
 * - 局部变量可以直接寄存器访问
 * - 全局变量需要表查找优化
 * - 函数调用可以尾调用优化
 */
typedef enum {
    /**
     * @brief 无值表达式：表示没有产生实际值的表达式
     * 
     * 用于语句或不产生值的表达式，如空语句、某些控制结构等。
     * 这种表达式类型主要用于语法分析过程中的占位符。
     */
    VVOID,

    /**
     * @brief nil值：Lua的空值类型
     * 
     * 表示Lua中的nil值，这是一个特殊的常量。代码生成时可以
     * 优化为特殊的指令或直接在寄存器中设置nil值。
     */
    VNIL,

    /**
     * @brief 布尔真值：true常量
     * 
     * 表示布尔常量true。作为编译时已知的常量，可以进行
     * 常量折叠优化和条件分支的静态分析。
     */
    VTRUE,

    /**
     * @brief 布尔假值：false常量
     * 
     * 表示布尔常量false。与VTRUE类似，支持编译时优化
     * 和静态条件分析。
     */
    VFALSE,

    /**
     * @brief 常量表值：存储在常量表中的值
     * 
     * info字段包含常量在常量表k中的索引。这种类型用于
     * 字符串、数字常量等需要存储在常量表中的值。
     * 
     * 优化特点：
     * - 编译时确定的常量
     * - 通过索引快速访问
     * - 支持常量共享和重用
     */
    VK,

    /**
     * @brief 数值常量：直接存储的数值
     * 
     * nval字段直接包含数值。小的整数和简单的浮点数
     * 可以直接嵌入表达式描述符中，避免常量表查找。
     * 
     * 优化特点：
     * - 避免常量表间接访问
     * - 支持编译时算术运算
     * - 直接嵌入指令操作数
     */
    VKNUM,

    /**
     * @brief 局部变量：存储在寄存器中的局部变量
     * 
     * info字段包含局部变量的寄存器编号。这是最高效的
     * 变量访问方式，直接通过寄存器操作。
     * 
     * 优化特点：
     * - 最快的变量访问方式
     * - 直接寄存器操作
     * - 支持寄存器重用优化
     */
    VLOCAL,

    /**
     * @brief upvalue：闭包中的外部变量引用
     * 
     * info字段包含upvalue在upvalues数组中的索引。
     * upvalue是闭包实现的核心，允许内部函数访问外部变量。
     * 
     * 特殊处理：
     * - 需要特殊的访问指令
     * - 涉及闭包的生命周期管理
     * - 可能需要变量提升（hoisting）
     */
    VUPVAL,

    /**
     * @brief 全局变量：全局环境表中的变量
     * 
     * info字段包含表的索引，aux字段包含全局名称在常量表中的索引。
     * 全局变量访问需要通过环境表进行查找。
     * 
     * 访问特点：
     * - 需要表查找操作
     * - 可能触发元方法调用
     * - 支持全局变量缓存优化
     */
    VGLOBAL,

    /**
     * @brief 表索引：表[索引]形式的访问
     * 
     * info字段包含表的寄存器编号，aux字段包含索引的寄存器编号
     * 或常量表索引。这是表访问的通用形式。
     * 
     * 访问特点：
     * - 可能触发__index元方法
     * - 支持数组和哈希表优化
     * - 需要类型检查和边界检查
     */
    VINDEXED,

    /**
     * @brief 跳转目标：无条件跳转指令
     * 
     * info字段包含跳转指令的程序计数器位置。用于
     * 实现无条件跳转和控制流转移。
     */
    VJMP,

    /**
     * @brief 可重定位表达式：地址需要后续修正的表达式
     * 
     * info字段包含指令的程序计数器位置。这种表达式的
     * 最终地址在代码生成完成后才能确定。
     * 
     * 用途：
     * - 函数调用的返回值
     * - 需要地址修正的表达式
     * - 延迟绑定的操作
     */
    VRELOCABLE,

    /**
     * @brief 非重定位表达式：结果已确定寄存器位置
     * 
     * info字段包含结果寄存器的编号。这种表达式的
     * 结果位置已经确定，不需要进一步的地址计算。
     */
    VNONRELOC,

    /**
     * @brief 函数调用：函数调用表达式
     * 
     * info字段包含函数调用指令的程序计数器位置。
     * 函数调用需要特殊的参数传递和返回值处理。
     * 
     * 特殊处理：
     * - 参数列表管理
     * - 返回值数量处理
     * - 尾调用优化
     * - 可变参数支持
     */
    VCALL,

    /**
     * @brief 可变参数：...表达式
     * 
     * info字段包含可变参数指令的程序计数器位置。
     * 用于访问函数的可变参数列表。
     * 
     * 特殊特性：
     * - 可以展开为多个值
     * - 数量在运行时确定
     * - 需要特殊的栈管理
     */
    VVARARG
} expkind;

/**
 * @brief 表达式描述符：完整描述一个表达式的所有信息
 * 
 * 详细说明：
 * 这个结构体是编译器中最重要的数据结构之一，它完整地描述了
 * 一个表达式的类型、值、位置等所有必要信息。编译器使用这个
 * 结构体来跟踪表达式的状态，生成相应的字节码指令。
 * 
 * 设计原则：
 * - 紧凑的内存布局
 * - 支持多种表达式类型
 * - 便于代码生成和优化
 * - 支持控制流分析
 * 
 * 生命周期：
 * - 在表达式解析过程中创建
 * - 在代码生成过程中使用和修改
 * - 在表达式处理完成后销毁
 */
typedef struct expdesc {
    /**
     * @brief 表达式类型：指定表达式的种类和处理方式
     * 
     * 这个字段决定了如何解释union u中的数据，以及
     * 应该生成什么样的字节码指令。
     */
    expkind k;

    /**
     * @brief 表达式值的联合体：根据类型存储不同的数据
     * 
     * 这个联合体根据k字段的值来解释：
     * - 对于VK、VLOCAL等类型，使用s.info和s.aux
     * - 对于VKNUM类型，使用nval存储数值
     */
    union {
        /**
         * @brief 结构化信息：包含索引和辅助信息
         * 
         * info: 主要信息，如寄存器编号、常量索引等
         * aux: 辅助信息，用于复杂的表达式类型
         */
        struct { int info, aux; } s;

        /**
         * @brief 数值：直接存储的Lua数字
         * 
         * 用于VKNUM类型的表达式，直接存储数值而不需要
         * 通过常量表间接访问。
         */
        lua_Number nval;
    } u;

    /**
     * @brief 真值跳转链表：条件为真时的跳转目标列表
     * 
     * 这个字段用于条件表达式的代码生成，记录了当表达式
     * 为真时需要跳转的指令位置。多个跳转位置通过链表连接。
     * 
     * 用途：
     * - 实现短路求值（short-circuit evaluation）
     * - 优化布尔表达式的代码生成
     * - 支持复杂的条件控制流
     */
    int t;

    /**
     * @brief 假值跳转链表：条件为假时的跳转目标列表
     * 
     * 与t字段对应，记录了当表达式为假时需要跳转的指令位置。
     * 这种设计支持高效的布尔表达式代码生成。
     * 
     * 优化效果：
     * - 避免不必要的布尔值具体化
     * - 支持直接的条件跳转
     * - 减少中间临时值的使用
     */
    int f;
} expdesc;

/**
 * @brief upvalue描述符：描述闭包中外部变量的信息
 * 
 * 详细说明：
 * 这个紧凑的结构体描述了upvalue的基本信息，包括它的类型和
 * 位置信息。upvalue是Lua闭包实现的核心机制，允许内部函数
 * 访问和修改外部作用域的变量。
 * 
 * 设计特点：
 * - 使用字节类型节省内存
 * - 支持不同类型的upvalue
 * - 便于快速查找和访问
 * 
 * upvalue类型：
 * - 栈上变量：仍在栈上的局部变量
 * - 闭合变量：已移到堆上的变量
 */
typedef struct upvaldesc {
    /**
     * @brief upvalue类型：指定upvalue的种类
     * 
     * 可能的值：
     * - 0：栈上的局部变量（open upvalue）
     * - 1：已闭合的upvalue（closed upvalue）
     */
    lu_byte k;

    /**
     * @brief upvalue信息：位置或索引信息
     * 
     * 根据k字段的值，这个字段有不同的含义：
     * - 对于栈上变量：栈位置索引
     * - 对于闭合变量：upvalue表中的索引
     */
    lu_byte info;
} upvaldesc;

/* 前向声明：BlockCnt结构在lparser.c中定义 */
struct BlockCnt;

/**
 * @brief 函数状态：代码生成过程中的完整上下文信息
 * 
 * 详细说明：
 * 这个结构体是编译器的核心数据结构，包含了为一个函数生成代码
 * 所需的所有状态信息。它管理着寄存器分配、常量表、局部变量、
 * upvalue等编译过程中的关键数据。
 * 
 * 生命周期：
 * - 在函数解析开始时创建
 * - 在整个函数编译过程中维护
 * - 在函数编译完成后销毁
 * 
 * 嵌套支持：
 * - 支持嵌套函数的编译
 * - 通过prev指针形成函数栈
 * - 正确处理变量作用域和upvalue
 */
typedef struct FuncState {
    /**
     * @brief 当前函数原型：正在编译的函数的元信息
     * 
     * 包含函数的字节码、常量表、局部变量信息等。
     * 这是编译结果的主要载体。
     */
    Proto *f;

    /**
     * @brief 常量表哈希：用于查找和重用常量表中的元素
     * 
     * 这个哈希表用于快速查找已存在的常量，避免重复
     * 存储相同的常量值，优化常量表的大小。
     */
    Table *h;

    /**
     * @brief 外层函数状态：指向包含当前函数的外层函数
     * 
     * 用于处理嵌套函数和upvalue的查找。通过这个指针
     * 可以访问外层作用域的变量和函数信息。
     */
    struct FuncState *prev;

    /**
     * @brief 词法分析器状态：提供词法单元流
     * 
     * 与词法分析器的接口，用于获取下一个词法单元，
     * 处理语法错误等。
     */
    struct LexState *ls;

    /**
     * @brief Lua状态：虚拟机状态的副本
     * 
     * 用于内存分配、错误处理等需要访问Lua状态的操作。
     */
    struct lua_State *L;

    /**
     * @brief 当前代码块链：管理嵌套的代码块
     * 
     * 用于处理局部变量的作用域、break/continue语句的
     * 目标等块级作用域相关的功能。
     */
    struct BlockCnt *bl;

    /**
     * @brief 程序计数器：下一条指令的位置
     * 
     * 等价于当前已生成的指令数量，用于指令地址计算
     * 和跳转目标的确定。
     */
    int pc;

    /**
     * @brief 最后跳转目标：最近一次跳转目标的程序计数器
     * 
     * 用于优化跳转指令，避免不必要的跳转链。
     */
    int lasttarget;

    /**
     * @brief 待处理跳转列表：指向当前程序计数器的跳转列表
     * 
     * 用于实现向前跳转的延迟绑定，当跳转目标确定后
     * 批量修正跳转指令。
     */
    int jpc;

    /**
     * @brief 第一个空闲寄存器：下一个可用的寄存器编号
     * 
     * 用于寄存器分配算法，确保每个寄存器只被一个
     * 活跃变量使用。
     */
    int freereg;

    /**
     * @brief 常量表元素数量：常量表k中的元素个数
     * 
     * 用于管理常量表的增长和索引分配。
     */
    int nk;

    /**
     * @brief 子函数数量：当前函数包含的子函数个数
     * 
     * 用于管理嵌套函数的原型数组p。
     */
    int np;

    /**
     * @brief 局部变量数量：locvars数组中的元素个数
     * 
     * 包括所有声明过的局部变量，用于调试信息和
     * 作用域管理。
     */
    short nlocvars;

    /**
     * @brief 活跃局部变量数量：当前作用域中活跃的局部变量个数
     * 
     * 用于寄存器分配和变量作用域管理，只计算当前
     * 可访问的局部变量。
     */
    lu_byte nactvar;

    /**
     * @brief upvalue数组：当前函数使用的所有upvalue
     * 
     * 每个元素描述一个upvalue的类型和位置信息，
     * 用于闭包的创建和变量访问。
     */
    upvaldesc upvalues[LUAI_MAXUPVALUES];

    /**
     * @brief 活跃变量栈：当前作用域中所有活跃变量的信息
     * 
     * 存储每个活跃局部变量在locvars数组中的索引，
     * 用于变量查找和作用域管理。
     */
    unsigned short actvar[LUAI_MAXVARS];
} FuncState;

/**
 * @brief Lua语法分析器：将源代码编译为函数原型
 * 
 * 详细说明：
 * 这是Lua编译系统的主入口函数，负责将Lua源代码完整地编译为
 * 可执行的函数原型。它集成了词法分析、语法分析、语义分析和
 * 代码生成的完整流程。
 * 
 * 编译流程：
 * 1. 初始化解析器状态和函数状态
 * 2. 逐个读取和解析词法单元
 * 3. 根据语法规则构建语法树
 * 4. 同时生成对应的字节码指令
 * 5. 处理常量表、局部变量和upvalue
 * 6. 完成函数原型的构建
 * 
 * 输入处理：
 * - 通过ZIO抽象输入流读取源代码
 * - 支持字符串、文件等多种输入源
 * - 使用缓冲机制提高读取效率
 * 
 * 错误处理：
 * - 检测和报告语法错误
 * - 提供准确的错误位置信息
 * - 通过longjmp进行错误恢复
 * 
 * 内存管理：
 * - 所有分配的内存都通过Lua的内存管理器
 * - 支持垃圾收集和内存限制
 * - 编译失败时自动清理中间结果
 * 
 * 优化特性：
 * - 编译时常量计算和折叠
 * - 寄存器分配优化
 * - 跳转指令优化
 * - 尾调用识别和优化
 * 
 * 调试支持：
 * - 生成行号信息用于调试
 * - 保留局部变量名称
 * - 支持调试钩子和断点
 * 
 * @param L lua_State指针，当前Lua虚拟机状态
 * @param z 输入流指针，提供源代码数据
 * @param buff 缓冲区指针，用于词法分析的临时存储
 * @param name 源代码名称，用于错误报告和调试信息
 * @return 编译生成的函数原型，失败时不返回（longjmp）
 * 
 * @note 编译失败时通过longjmp进行错误处理，不会正常返回
 * @warning 编译过程可能分配大量内存，需要考虑内存限制
 * @see llex.h, lcode.h, lobject.h
 */
LUAI_FUNC Proto *luaY_parser(lua_State *L, ZIO *z, Mbuffer *buff,
                                            const char *name);

#endif
