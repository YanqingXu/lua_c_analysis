/*
** ====================================================================
** Lua 语法分析器 (Lua Parser)
** ====================================================================
** 
** 文件作用：
** 本文件定义了 Lua 语言的语法分析器，负责将词法分析器产生的 Token 流
** 解析为抽象语法树，并生成相应的字节码。这是编译过程的核心阶段。
**
** 核心功能：
** 1. [解析] 递归下降语法分析和 AST 构建
** 2. [表达式] 表达式解析和操作符优先级处理  
** 3. [语句] 语句解析和控制流分析
** 4. [作用域] 变量作用域管理和符号表维护
** 5. [代码生成] 字节码生成和优化
** 6. [错误恢复] 语法错误检测和恢复策略
**
** 设计特点：
** - 递归下降 LL(1) 语法分析算法
** - 表达式的操作符优先级解析
** - 增量式的字节码生成
** - 多层嵌套作用域的管理
** - 详细的错误位置和上下文信息
** - UpValue 捕获和闭包支持
**
** 依赖关系：
** - llimits.h: 系统限制和配置常量
** - lobject.h: 基础对象系统和数据类型
** - lzio.h: 输入流抽象和缓冲管理
**
** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/

#ifndef lparser_h
#define lparser_h

#include "llimits.h"
#include "lobject.h"
#include "lzio.h"


#ifndef lparser_h
#define lparser_h

#include "llimits.h"
#include "lobject.h"
#include "lzio.h"

/*
** ====================================================================
** [枚举] 表达式类型分类系统
** ====================================================================
*/

/*
** [枚举] 表达式种类描述符
**
** 功能：定义表达式在语法分析和代码生成过程中的不同状态和类型
** 
** 设计原理：
** - 表达式有多种表示形式和计算状态
** - 不同类型需要不同的代码生成策略
** - 支持延迟求值和优化
** - 简化语法分析器的状态管理
**
** 分类体系：
** 1. 立即值表达式：编译时已知的常量
** 2. 变量引用表达式：需要运行时获取的值
** 3. 计算表达式：需要执行指令的复合表达式
** 4. 控制流表达式：涉及跳转和分支的表达式
*/
typedef enum {
  /*
  ** [立即值] 编译时确定的常量表达式
  */
  VVOID,        /* 无值表达式
                ** - 表示不产生值的表达式
                ** - 如某些语句或空表达式
                ** - 不生成加载指令
                ** - 用于语法结构的占位 */
                
  VNIL,         /* nil 字面量
                ** - Lua 的 nil 常量值
                ** - 编译时已确定的类型
                ** - 生成 LOADNIL 指令
                ** - 表示空值或未定义状态 */
                
  VTRUE,        /* true 字面量
                ** - 布尔真值常量
                ** - 编译时确定的布尔值
                ** - 生成 LOADBOOL 指令
                ** - 用于逻辑表达式和条件 */
                
  VFALSE,       /* false 字面量
                ** - 布尔假值常量
                ** - 编译时确定的布尔值
                ** - 生成 LOADBOOL 指令
                ** - 用于逻辑表达式和条件 */
  
  /*
  ** [常量池] 常量表中的值
  */
  VK,           /* 常量池索引
                ** - info: 常量在 k 表中的索引
                ** - 字符串、大数值等存储在常量池
                ** - 生成 LOADK 指令
                ** - 节省指令空间和重复存储 */
                
  VKNUM,        /* 数值常量
                ** - nval: 直接存储的数值
                ** - 小整数和简单浮点数
                ** - 可能内联到指令中
                ** - 避免常量池查找开销 */
  
  /*
  ** [变量引用] 运行时变量访问
  */
  VLOCAL,       /* 局部变量
                ** - info: 局部变量的寄存器编号
                ** - 函数栈帧中的变量
                ** - 直接寄存器访问
                ** - 最高效的变量访问方式 */
                
  VUPVAL,       /* 上值变量
                ** - info: 上值在 upvalues 数组中的索引
                ** - 闭包捕获的外层变量
                ** - 生成 GETUPVAL 指令
                ** - 支持嵌套作用域访问 */
                
  VGLOBAL,      /* 全局变量
                ** - info: 环境表的寄存器
                ** - aux: 变量名在常量池中的索引
                ** - 生成 GETGLOBAL 指令
                ** - 通过环境表进行查找 */
  
  /*
  ** [索引访问] 表索引和复合访问
  */
  VINDEXED,     /* 表索引访问
                ** - info: 表对象的寄存器
                ** - aux: 索引的寄存器或常量池索引
                ** - 生成 GETTABLE 指令
                ** - 支持动态键访问 */
  
  /*
  ** [指令引用] 需要执行指令的表达式
  */
  VJMP,         /* 跳转指令
                ** - info: 跳转指令的 PC 位置
                ** - 用于条件表达式和短路求值
                ** - 需要后续的跳转目标修正
                ** - 支持控制流优化 */
                
  VRELOCABLE,   /* 可重定位表达式
                ** - info: 生成指令的 PC 位置
                ** - 指令的目标寄存器可以改变
                ** - 支持表达式结果的优化放置
                ** - 减少不必要的移动指令 */
                
  VNONRELOC,    /* 非重定位表达式
                ** - info: 结果寄存器编号
                ** - 指令已生成且目标寄存器固定
                ** - 表达式结果已经确定位置
                ** - 需要移动指令来改变位置 */
  
  /*
  ** [函数调用] 特殊的表达式类型
  */
  VCALL,        /* 函数调用表达式
                ** - info: 调用指令的 PC 位置
                ** - 表示函数调用的返回值
                ** - 可能返回多个值
                ** - 需要特殊的结果处理 */
                
  VVARARG       /* 可变参数表达式
                ** - info: VARARG 指令的 PC 位置
                ** - 表示 ... 参数的展开
                ** - 可能产生多个值
                ** - 用于可变参数函数 */
} expkind;

/*
** ====================================================================
** [结构] 表达式描述符
** ====================================================================
*/

/*
** [结构] 表达式描述符
**
** 功能：完整描述一个表达式的类型、值和控制流信息
** 
** 设计目标：
** - 统一不同类型表达式的表示
** - 支持延迟代码生成和优化
** - 管理控制流和跳转链表
** - 提供表达式求值的完整上下文
**
** 字段说明：
*/
typedef struct expdesc {
  expkind k;            /* 表达式种类
                        ** - 决定表达式的处理方式
                        ** - 影响代码生成策略
                        ** - 表达式的基本分类标识 */
  
  union {
    /*
    ** [复合信息] 通用信息存储
    */
    struct { 
      int info;         /* 主要信息
                        ** - 寄存器编号、指令 PC、常量索引等
                        ** - 根据表达式类型有不同含义
                        ** - 代码生成的关键参数 */
                        
      int aux;          /* 辅助信息
                        ** - 第二个参数或索引
                        ** - 用于复合表达式的完整描述
                        ** - 如表索引访问的索引部分 */
    } s;
    
    /*
    ** [数值] 直接存储的数值常量
    */
    lua_Number nval;    /* 数值常量值
                        ** - VKNUM 类型的直接数值存储
                        ** - 避免常量池的间接访问
                        ** - 用于数值字面量的优化 */
  } u;
  
  /*
  ** [控制流] 跳转链表管理
  ** 
  ** 用于支持短路求值和条件表达式的实现
  */
  int t;                /* 为真时跳转的补丁链表
                        ** - 存储需要在表达式为真时跳转的指令位置
                        ** - 用于 and/or 操作符的短路求值
                        ** - 条件表达式的优化实现
                        ** - 链表头指针，指向第一个待修正指令 */
                        
  int f;                /* 为假时跳转的补丁链表
                        ** - 存储需要在表达式为假时跳转的指令位置
                        ** - 支持否定条件和复杂逻辑
                        ** - 条件分支的另一个分支
                        ** - 与 t 链表配合实现完整控制流 */
} expdesc;


/*
** ====================================================================
** [结构] UpValue 描述符
** ====================================================================
*/

/*
** [结构] UpValue 描述符
**
** 功能：描述函数捕获的上层作用域变量信息
** 
** 设计目标：
** - 记录 UpValue 的来源和类型
** - 支持嵌套函数的变量捕获
** - 优化 UpValue 的访问和管理
** - 提供闭包创建的必要信息
**
** UpValue 机制：
** - 允许内层函数访问外层函数的局部变量
** - 实现 Lua 闭包的核心机制
** - 支持变量的生命周期延长
** - 处理变量的共享和同步
*/
typedef struct upvaldesc {
  lu_byte k;            /* UpValue 类型标识
                        ** - 0: 来自局部变量（local variable）
                        ** - 1: 来自上层 UpValue（nested upvalue）
                        ** 
                        ** 类型说明：
                        ** - 局部变量：直接从外层函数的寄存器捕获
                        ** - 嵌套 UpValue：从外层函数的 UpValue 转发
                        ** - 影响 UpValue 的创建和访问方式
                        ** - 决定闭包的 UpValue 链表结构 */
                        
  lu_byte info;         /* UpValue 信息索引
                        ** - k=0 时：外层函数中局部变量的寄存器编号
                        ** - k=1 时：外层函数中 UpValue 的索引
                        ** 
                        ** 索引用途：
                        ** - 在闭包创建时确定 UpValue 来源
                        ** - 运行时 UpValue 访问的关键参数
                        ** - 支持多层嵌套的 UpValue 传递
                        ** - 闭包对象的 UpValue 数组构建 */
} upvaldesc;

/*
** ====================================================================
** [前置声明] 块计数器结构
** ====================================================================
*/

/*
** [前置声明] 块计数器结构体
**
** 说明：BlockCnt 结构体在 lparser.c 中定义
** 
** 作用：
** - 管理语法块的嵌套层次
** - 跟踪块内的局部变量
** - 处理 break 和 continue 等控制流
** - 维护作用域的正确性
**
** 设计考虑：
** - 在头文件中只需前置声明
** - 具体实现细节隐藏在源文件中
** - 减少头文件的复杂性和依赖
*/
struct BlockCnt;  /* 在 lparser.c 中定义的块计数器 */

/*
** ====================================================================
** [结构] 函数编译状态
** ====================================================================
*/

/*
** [结构] 函数编译状态
**
** 功能：维护单个函数编译过程中的所有状态信息
** 
** 核心职责：
** 1. [字节码] 字节码生成和管理
** 2. [常量] 常量池维护和优化
** 3. [变量] 局部变量和 UpValue 管理
** 4. [作用域] 嵌套作用域和符号表
** 5. [跳转] 跳转指令和控制流处理
** 6. [优化] 代码优化和寄存器分配
**
** 嵌套支持：
** - 支持函数嵌套定义的编译
** - 维护函数编译的调用栈
** - 处理 UpValue 的跨函数传递
** - 管理不同函数间的依赖关系
*/
typedef struct FuncState {
  /*
  ** [核心对象] 函数原型和常量管理
  */
  Proto *f;             /* 当前函数的原型对象
                        ** - 存储函数的字节码、常量、调试信息
                        ** - 编译结果的最终载体
                        ** - 包含函数签名和元数据
                        ** - 运行时执行的基础结构 */
                        
  Table *h;             /* 常量查找哈希表
                        ** - 用于常量的快速查找和重用
                        ** - 避免重复常量的存储
                        ** - 优化常量池的大小和访问
                        ** - 提高编译效率和内存使用 */
  
  /*
  ** [上下文链接] 编译上下文的连接
  */
  struct FuncState *prev; /* 外层函数的编译状态
                          ** - 指向包含此函数的外层函数
                          ** - 支持嵌套函数的编译
                          ** - UpValue 解析的关键链接
                          ** - 形成函数编译的调用栈 */
                          
  struct LexState *ls;    /* 词法分析器状态
                          ** - 连接到词法分析器
                          ** - 获取 Token 流和源码信息
                          ** - 错误报告的位置信息
                          ** - 语法分析的输入源 */
                          
  struct lua_State *L;    /* Lua 虚拟机状态
                          ** - 连接到主要 Lua 运行时
                          ** - 内存分配和 GC 服务
                          ** - 错误处理和异常传播
                          ** - 对象创建和管理服务 */
  
  /*
  ** [块管理] 作用域和控制结构
  */
  struct BlockCnt *bl;    /* 当前块链表
                          ** - 指向当前活动的语法块
                          ** - 管理嵌套的块结构
                          ** - 处理局部变量的作用域
                          ** - 支持 break/continue 等控制流 */
  
  /*
  ** [代码生成] 字节码生成状态
  */
  int pc;               /* 下一条指令的位置
                        ** - 等价于 ncode（代码数量）
                        ** - 新指令生成的目标位置
                        ** - 跳转指令的目标计算基础
                        ** - 代码大小和增长管理 */
                        
  int lasttarget;       /* 最后跳转目标的 PC
                        ** - 最近一次跳转目标指令的位置
                        ** - 用于跳转优化和合并
                        ** - 避免不必要的跳转指令
                        ** - 代码生成的优化基础 */
                        
  int jpc;              /* 待处理跳转到 PC 的列表
                        ** - 需要跳转到当前位置的指令链表
                        ** - 用于前向跳转的地址修正
                        ** - 控制流合并和优化
                        ** - break/continue 等语句的实现 */
  
  /*
  ** [寄存器管理] 寄存器分配和使用
  */
  int freereg;          /* 第一个空闲寄存器
                        ** - 下一个可分配的寄存器编号
                        ** - 寄存器分配算法的核心状态
                        ** - 局部变量和临时值的存储管理
                        ** - 函数调用参数的准备基础 */
  
  /*
  ** [数组计数] 各种数组的元素数量
  */
  int nk;               /* 常量数组 k 的元素数量
                        ** - 函数原型中常量的总数
                        ** - 常量池大小的管理
                        ** - 新常量添加的索引基础
                        ** - 内存使用和优化的参考 */
                        
  int np;               /* 子函数数组 p 的元素数量
                        ** - 嵌套函数原型的数量
                        ** - 函数闭包创建的依据
                        ** - 嵌套编译状态的管理
                        ** - 函数依赖关系的记录 */
  
  /*
  ** [变量管理] 局部变量和作用域
  */
  short nlocvars;       /* 局部变量数组的元素数量
                        ** - 函数中所有局部变量的总数
                        ** - 包括不同作用域的变量
                        ** - 调试信息和变量名记录
                        ** - 变量生命周期管理 */
                        
  lu_byte nactvar;      /* 当前活跃局部变量的数量
                        ** - 当前作用域中可访问的变量数
                        ** - 变量栈的当前高度
                        ** - 新变量分配的寄存器基础
                        ** - 作用域管理的关键指标 */
  
  /*
  ** [数组存储] 固定大小的编译时数组
  */
  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* UpValue 描述符数组
                                         ** - 存储函数捕获的所有 UpValue
                                         ** - 闭包创建时的 UpValue 映射
                                         ** - 支持最多 LUAI_MAXUPVALUES 个
                                         ** - 嵌套函数访问的变量记录 */
                                         
  unsigned short actvar[LUAI_MAXVARS];   /* 活跃变量栈
                                         ** - 记录当前活跃的局部变量
                                         ** - 索引指向 locvars 数组
                                         ** - 支持作用域的进入和退出
                                         ** - 变量名解析和冲突检测 */
} FuncState;

/*
** ====================================================================
** [函数] 语法分析器公共接口
** ====================================================================
*/

/*
** [核心] 语法分析器主函数
**
** 功能：完整解析 Lua 源代码并生成函数原型
** @param L: lua_State* Lua 虚拟机状态
** @param z: ZIO* 输入流接口
** @param buff: Mbuffer* 词法分析缓冲区
** @param name: const char* 源代码名称（用于错误报告）
** @return: Proto* 解析生成的函数原型
**
** 解析过程：
** 1. [初始化] 设置语法分析器和词法分析器状态
** 2. [解析] 递归下降解析语法结构
** 3. [生成] 增量生成字节码指令
** 4. [优化] 执行局部代码优化
** 5. [完成] 构建最终的函数原型对象
**
** 语法分析特点：
** - LL(1) 递归下降算法
** - 单遍扫描和代码生成
** - 操作符优先级解析
** - 错误恢复和报告
** - 嵌套函数的完整支持
**
** 输入处理：
** - 支持多种输入源（文件、字符串、内存）
** - 统一的输入流抽象接口
** - 错误位置的精确追踪
** - 源代码名称的调试支持
**
** 输出结果：
** - 完整的函数原型对象
** - 包含字节码、常量、调试信息
** - 支持即时执行或序列化存储
** - 与虚拟机执行引擎兼容
**
** 错误处理：
** - 详细的语法错误报告
** - 精确的错误位置信息
** - 错误恢复和继续解析
** - 用户友好的错误消息
*/
LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
                                            const char *name);


#endif
