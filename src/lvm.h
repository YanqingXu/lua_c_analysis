/*
** ====================================================================
** Lua 虚拟机 (Lua Virtual Machine)
** ====================================================================
** 
** 文件作用：
** 本文件定义了 Lua 虚拟机的核心接口，这是 Lua 语言执行引擎的心脏。
** 虚拟机负责执行字节码指令，实现 Lua 语言的所有运行时语义。
**
** 核心功能：
** 1. [执行] 字节码指令的解释执行
** 2. [类型转换] 动态类型系统的转换和强制转换  
** 3. [比较运算] 值比较和关系运算的实现
** 4. [表操作] 表的索引、赋值和访问控制
** 5. [字符串] 字符串连接和操作
** 6. [元方法] 运算符重载和元方法调用
**
** 设计特点：
** - 基于栈的虚拟机架构
** - 动态类型系统的完整支持
** - 高效的字节码解释执行
** - 元方法系统的深度集成
** - 垃圾回收的协调配合
** - 错误处理和异常传播
**
** 虚拟机架构：
** - 指令集：简洁而强大的字节码指令
** - 执行栈：基于栈的操作数管理
** - 寄存器：虚拟寄存器的高效分配
** - 调用栈：函数调用和返回的管理
** - 异常处理：错误传播和恢复机制
**
** 依赖关系：
** - ldo.h: 执行控制和调用栈管理
** - lobject.h: 基础对象系统和值类型
** - ltm.h: 元方法系统和运算符重载
**
** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lvm_h
#define lvm_h

#include "ldo.h"
#include "lobject.h"
#include "ltm.h"

/*
** ====================================================================
** [宏定义] 类型检查和转换宏
** ====================================================================
*/

/*
** [转换] 字符串转换检查宏
**
** 功能：检查值是否为字符串或可转换为字符串
** @param L: lua_State* Lua 状态机指针
** @param o: TValue* 要检查的值
** @return: 非零值表示是字符串或转换成功
**
** 转换逻辑：
** 1. [类型检查] 首先检查是否已经是字符串类型
** 2. [快速返回] 如果是字符串则直接返回真值
** 3. [转换尝试] 否则调用 luaV_tostring 尝试转换
** 4. [结果判断] 根据转换结果返回成功或失败
**
** 转换规则：
** - 字符串类型：直接返回真值
** - 数值类型：转换为字符串表示
** - 其他类型：调用 __tostring 元方法
** - 无法转换：返回假值
**
** 性能优化：
** - 字符串类型的快速路径检查
** - 避免不必要的函数调用
** - 短路求值减少计算开销
**
** 使用场景：
** - 字符串连接操作的预检查
** - 输出函数的参数验证
** - 字符串操作函数的类型检查
** - 模板系统和字符串处理
*/
#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))

/*
** [转换] 数值转换检查宏
**
** 功能：检查值是否为数值或可转换为数值
** @param o: TValue* 要检查的值（可能被修改）
** @param n: TValue* 转换结果的存储位置
** @return: 非零值表示是数值或转换成功
**
** 转换逻辑：
** 1. [类型检查] 检查是否已经是数值类型
** 2. [快速返回] 如果是数值则直接返回真值
** 3. [转换调用] 否则调用 luaV_tonumber 尝试转换
** 4. [结果更新] 转换成功时更新原值为转换结果
**
** 转换规则：
** - 数值类型：直接返回真值
** - 字符串类型：尝试解析为数值
** - 其他类型：调用 __tonumber 元方法（如果存在）
** - 无法转换：返回假值
**
** 重要特性：
** - 转换成功时会修改原值
** - 支持就地转换避免额外分配
** - 保持类型转换的一致性
** - 错误时不修改原值
**
** 使用场景：
** - 算术运算的操作数检查
** - 数值比较操作的预处理
** - 数学函数的参数验证
** - 类型强制转换的实现
*/
#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
                         (((o) = luaV_tonumber(o,n)) != NULL))

/*
** [比较] 对象相等性检查宏
**
** 功能：检查两个 Lua 值是否相等
** @param L: lua_State* Lua 状态机指针
** @param o1: TValue* 第一个比较值
** @param o2: TValue* 第二个比较值
** @return: 非零值表示两个值相等
**
** 比较逻辑：
** 1. [类型检查] 首先比较两个值的类型
** 2. [快速失败] 类型不同则直接返回不相等
** 3. [值比较] 类型相同时调用 luaV_equalval 比较值
** 4. [元方法] 必要时调用 __eq 元方法
**
** 相等性规则：
** - 不同类型的值永远不相等（除了数值子类型）
** - 相同类型按照类型特定的规则比较
** - 表和用户数据可能有 __eq 元方法
** - nil, boolean 按照值比较
** - 字符串按照内容比较（内部化优化）
** - 数值按照数学相等性比较
**
** 性能优化：
** - 类型检查的快速路径
** - 字符串内部化的指针比较
** - 元方法的缓存查找
** - 避免不必要的深度比较
**
** 使用场景：
** - == 操作符的实现
** - 表键查找和比较
** - 条件语句的相等性检查
** - 集合操作和去重算法
*/
#define equalobj(L,o1,o2) \
	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))

/*
** ====================================================================
** [函数] 虚拟机核心函数声明
** ====================================================================
*/

/*
** [比较] 小于比较函数
**
** 功能：实现 Lua 值的小于比较操作
** @param L: lua_State* Lua 状态机指针
** @param l: const TValue* 左操作数
** @param r: const TValue* 右操作数
** @return: int 非零值表示 l < r
**
** 比较逻辑：
** 1. [类型检查] 检查操作数的类型兼容性
** 2. [直接比较] 对于基本类型进行直接比较
** 3. [元方法] 对于复杂类型调用 __lt 元方法
** 4. [异常处理] 处理类型不兼容的错误情况
**
** 支持的比较：
** - 数值：数学大小比较
** - 字符串：字典序比较
** - 其他类型：通过 __lt 元方法
**
** 元方法调用：
** - 优先检查左操作数的元表
** - 然后检查右操作数的元表
** - 调用找到的 __lt 元方法
** - 处理元方法调用的结果
**
** 使用场景：
** - < 操作符的实现
** - 排序算法的比较函数
** - 条件语句的关系检查
** - 数据结构的有序维护
*/
LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);

/*
** [比较] 值相等性比较函数
**
** 功能：实现 Lua 值的详细相等性比较
** @param L: lua_State* Lua 状态机指针
** @param t1: const TValue* 第一个比较值
** @param t2: const TValue* 第二个比较值
** @return: int 非零值表示两个值相等
**
** 比较详情：
** 1. [基本类型] 对基本类型进行值比较
** 2. [引用类型] 对引用类型进行引用或内容比较
** 3. [元方法] 调用 __eq 元方法进行自定义比较
** 4. [特殊情况] 处理 NaN、nil 等特殊值
**
** 类型特定规则：
** - nil：只与 nil 相等
** - boolean：值相等
** - number：数学相等（包括 NaN 处理）
** - string：内容相等（内部化优化）
** - table/userdata：引用相等或 __eq 元方法
** - function/thread：引用相等
**
** 元方法处理：
** - 检查两个值的元表
** - 只有相同元表且有 __eq 方法时才调用
** - 确保元方法调用的对称性
** - 处理元方法执行的异常
**
** 使用场景：
** - equalobj 宏的底层实现
** - 表键查找的精确比较
** - 集合操作的元素比较
** - 调试和测试的值检查
*/
LUAI_FUNC int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2);

/*
** [转换] 数值转换函数
**
** 功能：尝试将 Lua 值转换为数值
** @param obj: const TValue* 要转换的源值
** @param n: TValue* 转换结果的存储位置
** @return: const TValue* 成功时返回结果指针，失败时返回 NULL
**
** 转换策略：
** 1. [类型检查] 检查源值是否已经是数值
** 2. [字符串解析] 尝试将字符串解析为数值
** 3. [元方法] 调用 __tonumber 元方法（如果存在）
** 4. [结果存储] 将转换结果存储到指定位置
**
** 字符串解析：
** - 支持整数和浮点数格式
** - 处理科学计数法
** - 跳过前导和尾随空白
** - 严格的数值格式验证
**
** 转换结果：
** - 成功：返回指向结果的指针
** - 失败：返回 NULL，不修改结果存储
** - 精度：保持最大可能的精度
** - 类型：根据值选择整数或浮点数
**
** 使用场景：
** - tonumber 宏的底层实现
** - 算术运算的操作数转换
** - 数值输入的解析和验证
** - 类型强制转换的核心逻辑
*/
LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);

/*
** [转换] 字符串转换函数
**
** 功能：将 Lua 值转换为字符串
** @param L: lua_State* Lua 状态机指针
** @param obj: StkId 要转换的值（栈位置）
** @return: int 非零值表示转换成功
**
** 转换策略：
** 1. [类型检查] 检查值是否已经是字符串
** 2. [数值转换] 将数值格式化为字符串
** 3. [元方法] 调用 __tostring 元方法
** 4. [就地修改] 直接修改栈上的值
**
** 数值格式化：
** - 整数：十进制表示
** - 浮点数：最优精度表示
** - 特殊值：inf、-inf、nan 的处理
** - 格式化：符合 Lua 数值字面量规则
**
** 元方法处理：
** - 查找对象的 __tostring 元方法
** - 调用元方法并获取返回值
** - 验证返回值是字符串类型
** - 处理元方法调用的异常
**
** 就地转换：
** - 直接修改栈上的原值
** - 避免额外的内存分配
** - 保持栈的一致性
** - 支持垃圾回收的协调
**
** 使用场景：
** - tostring 宏的底层实现
** - 字符串连接的操作数转换
** - 输出函数的格式化
** - 调试信息的字符串化
*/
LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);

/*
** [表操作] 表索引获取函数
**
** 功能：从表中获取指定键的值
** @param L: lua_State* Lua 状态机指针
** @param t: const TValue* 表对象
** @param key: TValue* 索引键
** @param val: StkId 结果值的存储位置（栈位置）
**
** 获取过程：
** 1. [类型检查] 验证 t 是否为表类型
** 2. [直接查找] 在表的哈希部分查找键
** 3. [数组查找] 对于数值键，检查数组部分
** 4. [元方法] 如果没找到，调用 __index 元方法
** 5. [结果存储] 将找到的值存储到指定位置
**
** 查找策略：
** - 数值键：优先检查数组部分
** - 字符串键：直接在哈希部分查找
** - 其他键：在哈希部分查找
** - 键比较：使用严格的相等性比较
**
** 元方法处理：
** - 查找表的 __index 元方法
** - 如果是函数：调用 __index(table, key)
** - 如果是表：递归在元表中查找
** - 支持多层元表的继承链
**
** 性能优化：
** - 数组部分的直接索引访问
** - 哈希部分的高效查找
** - 元方法的缓存机制
** - 字符串键的内部化优化
**
** 使用场景：
** - table[key] 操作的实现
** - 属性访问和方法调用
** - 对象系统的属性获取
** - 动态属性的查找机制
*/
LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);

/*
** [表操作] 表索引设置函数
**
** 功能：设置表中指定键的值
** @param L: lua_State* Lua 状态机指针
** @param t: const TValue* 表对象
** @param key: TValue* 索引键
** @param val: StkId 要设置的值（栈位置）
**
** 设置过程：
** 1. [类型检查] 验证 t 是否为表类型
** 2. [现有检查] 检查键是否已经存在
** 3. [直接设置] 如果存在，直接更新值
** 4. [元方法] 如果不存在，调用 __newindex 元方法
** 5. [新建条目] 或者在表中创建新的键值对
**
** 设置策略：
** - 现有键：直接更新对应的值
** - 新键且无元方法：在表中创建新条目
** - 新键且有元方法：调用 __newindex
** - 数组部分：优化数值键的设置
**
** 元方法处理：
** - 查找表的 __newindex 元方法
** - 如果是函数：调用 __newindex(table, key, value)
** - 如果是表：递归在元表中设置
** - 支持访问控制和属性验证
**
** 内存管理：
** - 表的自动扩容和重哈希
** - 数组部分和哈希部分的平衡
** - 与垃圾回收器的协调
** - 写屏障的触发和处理
**
** 使用场景：
** - table[key] = value 操作的实现
** - 属性设置和对象状态修改
** - 动态对象的属性创建
** - 访问控制和数据验证
*/
LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);

/*
** [执行] 虚拟机字节码执行函数
**
** 功能：执行 Lua 字节码指令序列
** @param L: lua_State* Lua 状态机指针
** @param nexeccalls: int 嵌套执行调用的计数
**
** 执行过程：
** 1. [指令获取] 从程序计数器获取当前指令
** 2. [指令解码] 解析指令的操作码和操作数
** 3. [指令执行] 根据操作码执行相应的操作
** 4. [状态更新] 更新虚拟机状态和程序计数器
** 5. [循环执行] 继续执行直到函数返回或异常
**
** 指令系统：
** - 基于栈和寄存器的混合架构
** - 三地址指令格式
** - 丰富的指令集覆盖所有语言特性
** - 高效的指令编码和解码
**
** 执行优化：
** - 指令分发的高效实现
** - 常见指令的快速路径
** - 寄存器分配的优化
** - 函数调用的尾调用优化
**
** 错误处理：
** - 异常的捕获和传播
** - 错误恢复和栈清理
** - 调试信息的维护
** - 用户错误处理的支持
**
** 协调机制：
** - 与垃圾回收器的协调
** - 信号处理和中断响应
** - 协程切换和调度
** - C 函数调用的桥接
**
** 使用场景：
** - Lua 函数的主要执行引擎
** - 脚本解释和执行
** - 字节码的运行时环境
** - 语言特性的具体实现
*/
LUAI_FUNC void luaV_execute (lua_State *L, int nexeccalls);

/*
** [字符串] 字符串连接函数
**
** 功能：连接多个 Lua 值为一个字符串
** @param L: lua_State* Lua 状态机指针
** @param total: int 要连接的值的总数
** @param last: int 最后一个值在栈中的位置
**
** 连接过程：
** 1. [类型转换] 将所有操作数转换为字符串
** 2. [长度计算] 计算结果字符串的总长度
** 3. [内存分配] 分配足够的内存存储结果
** 4. [字符串拷贝] 依次拷贝所有字符串到结果中
** 5. [结果创建] 创建新的字符串对象并入栈
**
** 类型转换：
** - 字符串：直接使用
** - 数值：格式化为字符串
** - 其他类型：调用 tostring 转换
** - 转换失败：抛出类型错误
**
** 性能优化：
** - 预先计算总长度避免多次重分配
** - 直接内存拷贝提高效率
** - 字符串内部化的重用机制
** - 栈空间的高效利用
**
** 内存管理：
** - 临时字符串的垃圾回收
** - 大字符串的内存压力处理
** - 与 GC 的协调和同步
** - 内存分配失败的错误处理
**
** 使用场景：
** - .. 操作符的实现
** - 字符串格式化和模板
** - 文本处理和生成
** - 输出和日志记录
*/
LUAI_FUNC void luaV_concat (lua_State *L, int total, int last);

#endif
