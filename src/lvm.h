/**
 * @file lvm.h
 * @brief Lua虚拟机核心接口：定义虚拟机执行引擎的核心功能和操作接口
 * 
 * 详细说明：
 * 这个头文件定义了Lua虚拟机（LVM）的核心执行引擎接口，包含了虚拟机执行、
 * 类型转换、对象比较、表操作等关键功能。虚拟机是Lua解释器的核心组件，
 * 负责执行编译后的字节码指令，管理运行时数据类型转换和对象操作。
 * 
 * 系统架构定位：
 * lvm模块处于Lua引擎的执行层，位于语法分析器（lparser）和对象系统（lobject）
 * 之间，直接与调试系统（ldebug）、标签方法（ltm）和执行控制（ldo）模块协作。
 * 它是连接高级语言特性和底层对象操作的关键桥梁。
 * 
 * 技术特点：
 * - 基于栈的虚拟机架构，使用简单高效的指令集
 * - 动态类型系统支持，运行时类型检查和转换
 * - 元表和元方法机制，支持操作符重载和自定义行为
 * - 优化的字符串和数值处理，支持自动类型转换
 * - 内存安全的表操作，防止越界访问和类型错误
 * 
 * 依赖关系：
 * - ldo.h：执行控制和错误处理机制
 * - lobject.h：基本对象类型和操作接口
 * - ltm.h：标签方法（元方法）和元表操作
 * 
 * 性能特征：
 * - 时间复杂度：大多数操作为O(1)，表查找为O(1)平均复杂度
 * - 空间复杂度：最小化内存开销，共享字符串和优化数值存储
 * - 缓存友好性：紧凑的数据结构和局部性优化
 * 
 * 线程安全性：
 * 每个lua_State是独立的执行环境，同一状态下的操作不是线程安全的，
 * 多线程环境需要使用独立的lua_State或适当的同步机制。
 * 
 * 使用示例：
 * @code
 * // 虚拟机执行示例
 * lua_State *L = luaL_newstate();
 * 
 * // 编译并执行Lua代码
 * if (luaL_loadstring(L, "return 1 + 2") == 0) {
 *     luaV_execute(L, 0);  // 执行字节码
 *     
 *     // 获取结果并进行类型转换
 *     TValue *result = L->top - 1;
 *     if (ttype(result) == LUA_TNUMBER) {
 *         printf("结果: %g\n", nvalue(result));
 *     }
 * }
 * 
 * lua_close(L);
 * @endcode
 * 
 * 内存安全考虑：
 * 所有函数都进行严格的类型检查和边界验证，防止缓冲区溢出和类型混淆。
 * 字符串操作使用长度限制，表操作检查键值有效性。
 * 
 * 注意事项：
 * - 虚拟机操作可能触发垃圾回收，调用者需要保护临时对象
 * - 类型转换可能分配新对象，需要考虑内存使用
 * - 元方法调用可能产生递归，需要防止栈溢出
 * 
 * @author Roberto Ierusalimschy
 * @version 5.1.5
 * @date 2007-12-27
 * @since Lua 5.0
 * @see ldo.h, lobject.h, ltm.h
 */

#ifndef lvm_h
#define lvm_h

/**
 * @brief 核心依赖模块：虚拟机运行所需的基础组件
 * 
 * 这些头文件提供了虚拟机执行的基础设施：
 * - ldo.h：提供执行控制、错误处理和协程支持
 * - lobject.h：定义Lua的基本数据类型和对象操作
 * - ltm.h：实现标签方法（元方法）和元表机制
 */
#include "ldo.h"
#include "lobject.h"
#include "ltm.h"

/**
 * @brief 类型转换和检查宏定义：高效的运行时类型操作
 * 
 * 这些宏提供了Lua虚拟机中最常用的类型检查和转换操作，
 * 它们被设计为内联展开，提供最优的运行时性能。
 */

/**
 * @brief 字符串转换检查：验证对象是否可转换为字符串
 * 
 * 实现原理：
 * 1. 首先检查对象是否已经是字符串类型（LUA_TSTRING）
 * 2. 如果不是，调用luaV_tostring尝试转换
 * 3. 转换过程可能触发__tostring元方法
 * 
 * 性能优化：
 * - 使用短路求值，字符串类型直接返回true
 * - 避免不必要的函数调用和类型转换
 * 
 * 副作用：
 * 如果对象不是字符串，此宏可能修改栈上的对象，
 * 将其转换为字符串表示形式。
 * 
 * @param L Lua状态机指针，用于访问字符串池和元方法
 * @param o 要检查的TValue对象指针
 * @return 非零值表示可以转换为字符串，零表示转换失败
 * 
 * @note 此宏可能触发垃圾回收和元方法调用
 * @warning 可能修改传入的对象o，调用者需要意识到这种副作用
 */
#define tostring(L, o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))

/**
 * @brief 数值转换检查：验证对象是否可转换为数值
 * 
 * 实现原理：
 * 1. 首先检查对象是否已经是数值类型（LUA_TNUMBER）
 * 2. 如果不是，调用luaV_tonumber尝试转换
 * 3. 成功时将转换结果存储在n中，并将o指向n
 * 
 * 转换规则：
 * - 字符串：解析数字字面量（如"123"、"3.14"）
 * - 其他类型：通过__tonumber元方法转换
 * 
 * 性能优化：
 * - 数值类型直接返回true，无额外开销
 * - 使用指针赋值避免数据复制
 * 
 * @param o 要检查的TValue对象，可能被修改指向转换结果
 * @param n 用于存储转换结果的TValue对象指针
 * @return 非零值表示转换成功，零表示无法转换为数值
 * 
 * @note 转换后o指向n，调用者需要确保n的生命周期
 * @warning 此宏修改o的值，具有副作用
 */
#define tonumber(o, n) (ttype(o) == LUA_TNUMBER || \
                        (((o) = luaV_tonumber(o, n)) != NULL))

/**
 * @brief 对象相等性比较：深度比较两个Lua对象的值
 * 
 * 实现原理：
 * 1. 首先比较对象类型，类型不同则必不相等
 * 2. 类型相同时调用luaV_equalval进行值比较
 * 3. 可能触发__eq元方法进行自定义比较
 * 
 * 比较语义：
 * - 数值：按数值比较，支持整数和浮点数混合比较
 * - 字符串：按内容比较，Lua字符串是内部化的
 * - 表：默认按引用比较，可通过__eq元方法自定义
 * - 函数：按引用比较
 * - 其他类型：按类型特定规则比较
 * 
 * 性能优化：
 * - 类型不同时快速返回false
 * - 相同对象引用时快速返回true
 * - 字符串比较优化：内部化字符串可以按指针比较
 * 
 * @param L Lua状态机指针，用于元方法调用和错误处理
 * @param o1 第一个要比较的TValue对象指针
 * @param o2 第二个要比较的TValue对象指针
 * @return 非零值表示对象相等，零表示不相等
 * 
 * @note 可能触发__eq元方法，产生任意副作用
 * @warning 元方法调用可能产生错误，需要适当的错误处理
 */
#define equalobj(L, o1, o2) \
    (ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))

/**
 * @brief 虚拟机核心函数声明：Lua虚拟机的主要操作接口
 * 
 * 这些函数实现了Lua虚拟机的核心功能，包括类型转换、对象比较、
 * 表操作、字符串连接和字节码执行。它们是虚拟机运行时的基础设施。
 */

/**
 * @brief 小于比较操作：实现Lua的"<"操作符语义
 * 
 * 详细说明：
 * 实现Lua中的小于比较操作，支持数值比较、字符串比较和通过__lt元方法
 * 的自定义比较。这个函数处理了Lua中复杂的类型强制转换和元方法调用。
 * 
 * 比较规则：
 * 1. 数值比较：支持整数和浮点数的混合比较
 * 2. 字符串比较：按字典序比较，使用优化的字符串比较算法
 * 3. 其他类型：查找并调用__lt元方法
 * 4. 无法比较的类型：抛出类型错误
 * 
 * 算法复杂度：
 * - 数值比较：O(1)
 * - 字符串比较：O(min(len1, len2))
 * - 元方法调用：取决于用户实现
 * 
 * 错误处理：
 * 当比较无法进行时（如比较数字和表），函数会抛出运行时错误，
 * 错误信息会指明具体的类型冲突。
 * 
 * @param[in] L Lua状态机指针，用于错误处理和元方法调用
 * @param[in] l 左操作数，要比较的第一个值
 * @param[in] r 右操作数，要比较的第二个值
 * 
 * @return 比较结果
 * @retval 1 左操作数小于右操作数
 * @retval 0 左操作数不小于右操作数
 * 
 * @throws LUA_ERRRUN 当操作数类型无法比较时
 * 
 * @pre L != NULL && l != NULL && r != NULL
 * @post 不修改操作数的值，但可能触发垃圾回收
 * 
 * @note 可能触发__lt或__le元方法，产生任意副作用
 * @warning 元方法调用可能改变虚拟机状态或抛出错误
 * 
 * @since Lua 5.0
 * @see luaV_equalval(), luaT_gettmbyobj()
 */
LUAI_FUNC int luaV_lessthan(lua_State *L, const TValue *l, const TValue *r);

/**
 * @brief 相等性比较：实现Lua的"=="操作符深度语义
 * 
 * 详细说明：
 * 实现Lua中的相等性比较，处理所有Lua类型的相等性语义，包括
 * 数值相等、字符串相等、表引用相等和通过__eq元方法的自定义相等。
 * 
 * 相等性规则：
 * 1. 数值：按数学相等比较，NaN != NaN
 * 2. 字符串：内容相等（Lua字符串是内部化的）
 * 3. 布尔值：值相等
 * 4. nil：只与nil相等
 * 5. 表/函数/用户数据：默认按引用相等，可通过__eq重载
 * 6. 线程：按引用相等
 * 
 * 性能优化：
 * - 内部化字符串支持指针比较
 * - 相同引用的快速路径
 * - 类型不匹配的早期退出
 * 
 * 元方法处理：
 * 对于表、用户数据和具有__eq元方法的对象，会调用相应的元方法，
 * 元方法的返回值决定了比较结果。
 * 
 * @param[in] L Lua状态机指针，用于元方法调用和字符串操作
 * @param[in] t1 第一个要比较的值
 * @param[in] t2 第二个要比较的值
 * 
 * @return 相等性比较结果
 * @retval 1 两个值相等
 * @retval 0 两个值不相等
 * 
 * @pre L != NULL && t1 != NULL && t2 != NULL
 * @post 不修改操作数，但可能触发垃圾回收
 * 
 * @note 可能触发__eq元方法，产生任意副作用
 * @warning 元方法调用可能改变虚拟机状态
 * 
 * @since Lua 5.0
 * @see luaV_lessthan(), luaT_gettmbyobj()
 */
LUAI_FUNC int luaV_equalval(lua_State *L, const TValue *t1, const TValue *t2);

/**
 * @brief 数值转换：将Lua值转换为数值类型
 * 
 * 详细说明：
 * 尝试将任意Lua值转换为数值，支持字符串解析和元方法转换。
 * 这是Lua自动类型转换机制的核心函数之一。
 * 
 * 转换规则：
 * 1. 数值：直接返回原值
 * 2. 字符串：解析数字字面量，支持整数和浮点数
 * 3. 其他类型：查找并调用__tonumber元方法
 * 4. 无法转换：返回NULL
 * 
 * 字符串解析：
 * - 支持十进制、十六进制（0x前缀）
 * - 支持科学记数法（1e10、1.5e-3）
 * - 忽略前导和尾随空白字符
 * - 严格模式：只解析完整的数字字符串
 * 
 * 内存管理：
 * 如果需要分配新的TValue来存储转换结果，函数会使用传入的n参数，
 * 调用者负责确保n指向有效的内存区域。
 * 
 * @param[in] obj 要转换的Lua值，保持不变
 * @param[out] n 用于存储转换结果的TValue，转换成功时存储数值
 * 
 * @return 转换结果指针
 * @retval obj 如果obj本身就是数值，返回obj指针
 * @retval n 如果转换成功，返回存储结果的n指针
 * @retval NULL 如果无法转换为数值
 * 
 * @pre obj != NULL && n != NULL
 * @post 成功时n包含有效的数值，失败时n内容未定义
 * 
 * @note 字符串解析使用C标准库函数，遵循locale设置
 * @warning 转换可能触发__tonumber元方法，产生副作用
 * 
 * @since Lua 5.0
 * @see luaV_tostring(), lua_tonumber()
 */
LUAI_FUNC const TValue *luaV_tonumber(const TValue *obj, TValue *n);

/**
 * @brief 字符串转换：将栈顶对象转换为字符串
 * 
 * 详细说明：
 * 将栈上指定位置的对象转换为字符串表示，支持数值格式化和
 * 元方法转换。转换后的字符串会替换栈上的原对象。
 * 
 * 转换规则：
 * 1. 字符串：无需转换，直接返回成功
 * 2. 数值：格式化为字符串，使用Lua的数值格式规则
 * 3. 布尔值：转换为"true"或"false"
 * 4. nil：转换为"nil"
 * 5. 其他类型：查找并调用__tostring元方法
 * 
 * 数值格式化：
 * - 整数：十进制格式，无小数点
 * - 浮点数：自动选择最简洁的表示形式
 * - 特殊值：inf、-inf、nan
 * - 使用C的printf格式化规则
 * 
 * 内存管理：
 * 新创建的字符串会被添加到Lua的字符串池中，自动进行内部化。
 * 函数可能触发垃圾回收来回收内存。
 * 
 * 栈操作：
 * 函数直接修改栈上的对象，将原对象替换为字符串对象，
 * 栈的大小和其他位置的对象保持不变。
 * 
 * @param[in] L Lua状态机指针，用于内存分配和元方法调用
 * @param[in] obj 栈上要转换的对象位置，会被修改为字符串
 * 
 * @return 转换结果
 * @retval 1 转换成功，obj现在指向字符串对象
 * @retval 0 转换失败，obj保持原值不变
 * 
 * @pre L != NULL && obj指向栈上有效位置
 * @post 成功时obj指向字符串对象，失败时obj不变
 * 
 * @note 可能触发垃圾回收和__tostring元方法
 * @warning 元方法调用可能产生错误或修改虚拟机状态
 * 
 * @since Lua 5.0
 * @see luaV_tonumber(), luaS_new()
 */
LUAI_FUNC int luaV_tostring(lua_State *L, StkId obj);

/**
 * @brief 表取值操作：实现Lua的表索引访问（t[key]）
 * 
 * 详细说明：
 * 实现Lua中的表索引操作，处理数组部分的快速访问、哈希部分的查找
 * 和__index元方法的调用。这是Lua表访问的核心实现。
 * 
 * 查找策略：
 * 1. 数组部分：整数键的快速索引，O(1)时间复杂度
 * 2. 哈希部分：使用开放地址法的哈希表，平均O(1)复杂度
 * 3. 元表查找：递归查找__index元方法
 * 4. 默认值：未找到时返回nil
 * 
 * 优化特性：
 * - 整数键优化：1到数组大小的键直接访问数组部分
 * - 字符串键优化：利用字符串内部化的哈希值
 * - 元表缓存：避免重复的元表查找
 * - 类型特化：针对不同键类型的优化路径
 * 
 * 元方法处理：
 * 当表中不存在指定键时，会查找__index元方法：
 * - 如果__index是函数，调用__index(t, key)
 * - 如果__index是表，递归在该表中查找key
 * - 支持多层元表链的递归查找
 * 
 * 类型处理：
 * - nil键：直接返回nil，不进行查找
 * - NaN键：视为不存在，返回nil
 * - 其他类型：正常哈希查找
 * 
 * @param[in] L Lua状态机指针，用于元方法调用和错误处理
 * @param[in] t 要查找的表对象，必须是table类型
 * @param[in] key 查找的键，可以是任意Lua值
 * @param[out] val 存储查找结果的位置，在栈上
 * 
 * @pre L != NULL && t != NULL && key != NULL && val指向栈上有效位置
 * @pre t必须是LUA_TTABLE类型的对象
 * @post val包含查找到的值，如果未找到则为nil
 * 
 * @note 可能触发__index元方法，产生任意副作用
 * @warning 元方法调用可能改变表结构或抛出错误
 * @warning 函数可能触发垃圾回收，影响对象生命周期
 * 
 * @since Lua 5.0
 * @see luaV_settable(), luaH_get(), luaT_gettmbyobj()
 */
LUAI_FUNC void luaV_gettable(lua_State *L, const TValue *t, TValue *key,
                             StkId val);

/**
 * @brief 表赋值操作：实现Lua的表索引赋值（t[key] = value）
 * 
 * 详细说明：
 * 实现Lua中的表赋值操作，处理数组部分的直接赋值、哈希部分的插入
 * 和__newindex元方法的调用。支持表的动态扩展和重哈希。
 * 
 * 赋值策略：
 * 1. 现有键：直接更新对应的值
 * 2. 新键：根据键类型选择存储位置（数组或哈希部分）
 * 3. 表扩展：必要时自动扩展数组或重新哈希
 * 4. 元方法：当键不存在时可能调用__newindex
 * 
 * 内存管理：
 * - 动态数组扩展：使用启发式算法确定新大小
 * - 哈希表重哈希：当负载因子过高时重新分配
 * - 垃圾回收友好：及时更新引用计数和标记
 * 
 * 性能优化：
 * - 整数键优化：连续整数键存储在数组部分
 * - 增量重哈希：避免长时间的停顿
 * - 写屏障：支持增量垃圾回收
 * - 类型特化：针对常见操作的快速路径
 * 
 * 元方法处理：
 * 当为不存在的键赋值时，会查找__newindex元方法：
 * - 如果__newindex是函数，调用__newindex(t, key, value)
 * - 如果__newindex是表，在该表中进行赋值
 * - 只有当原表中确实不存在该键时才调用元方法
 * 
 * 特殊情况：
 * - nil值赋值：删除对应的键值对，释放内存
 * - nil键赋值：抛出错误，nil不能作为表键
 * - NaN键赋值：抛出错误，NaN不能作为表键
 * 
 * @param[in] L Lua状态机指针，用于内存分配和元方法调用
 * @param[in] t 要修改的表对象，必须是table类型
 * @param[in] key 赋值的键，不能是nil或NaN
 * @param[in] val 要赋的值，在栈上，可以是任意Lua值
 * 
 * @pre L != NULL && t != NULL && key != NULL && val指向栈上有效位置
 * @pre t必须是LUA_TTABLE类型的对象
 * @pre key不能是nil或NaN
 * @post 表中key对应的值被设置为val，或调用了相应的元方法
 * 
 * @throws LUA_ERRRUN 当key为nil或NaN时
 * @throws LUA_ERRMEM 当内存分配失败时
 * 
 * @note 可能触发__newindex元方法和垃圾回收
 * @warning 可能导致表重新分配，使已有的指针失效
 * @warning 元方法调用可能产生错误或修改虚拟机状态
 * 
 * @since Lua 5.0
 * @see luaV_gettable(), luaH_set(), luaT_gettmbyobj()
 */
LUAI_FUNC void luaV_settable(lua_State *L, const TValue *t, TValue *key,
                             StkId val);

/**
 * @brief 虚拟机字节码执行：Lua虚拟机的核心执行引擎
 * 
 * 详细说明：
 * 这是Lua虚拟机的心脏，负责执行编译后的字节码指令。实现了一个
 * 基于栈的虚拟机，使用高效的指令分发和优化的操作实现。
 * 
 * 虚拟机架构：
 * - 基于栈的设计：操作数在栈上传递，简化指令格式
 * - 寄存器窗口：函数调用时分配固定的栈窗口
 * - 指令格式：32位固定长度指令，包含操作码和操作数
 * - 跳转优化：相对跳转和条件跳转的优化实现
 * 
 * 执行循环：
 * 1. 取指令：从当前函数的字节码数组中读取指令
 * 2. 译码：解析指令的操作码和操作数
 * 3. 执行：根据操作码执行相应的操作
 * 4. 更新：更新程序计数器和其他状态
 * 5. 循环：继续执行下一条指令
 * 
 * 指令集特性：
 * - 算术运算：加减乘除、取模、幂运算
 * - 逻辑运算：与或非、比较操作
 * - 表操作：索引访问、赋值、长度计算
 * - 控制流：条件跳转、循环、函数调用
 * - 变量操作：局部变量、全局变量、闭包变量
 * 
 * 优化技术：
 * - 指令融合：常见操作序列的优化
 * - 跳转预测：减少分支预测失败的开销
 * - 内联缓存：加速方法调用和属性访问
 * - 尾调用优化：避免栈空间的无限增长
 * 
 * 错误处理：
 * - 运行时错误：类型错误、算术错误、访问错误
 * - 栈溢出：深度递归和栈空间耗尽
 * - 内存错误：分配失败和垃圾回收
 * - 用户错误：通过error()函数抛出的错误
 * 
 * 调试支持：
 * - 断点支持：调试钩子和单步执行
 * - 调用栈：维护完整的调用链信息
 * - 行号映射：字节码位置到源码行号的映射
 * - 变量检查：局部变量和闭包变量的访问
 * 
 * @param[in] L Lua状态机指针，包含执行栈和全局状态
 * @param[in] nexeccalls 当前的执行调用深度，用于防止栈溢出
 * 
 * @pre L != NULL
 * @pre L->ci指向有效的调用信息
 * @pre 栈上有足够的空间执行当前函数
 * @post 函数执行完成或遇到错误，更新虚拟机状态
 * 
 * @throws LUA_ERRRUN 执行时错误（类型错误、算术错误等）
 * @throws LUA_ERRMEM 内存分配失败
 * @throws LUA_ERRERR 错误处理函数本身出错
 * @throws LUA_YIELD 协程让出执行权
 * 
 * @note 这是一个可能长时间运行的函数，支持中断和让出
 * @warning 执行过程中可能修改整个虚拟机状态
 * @warning 可能触发垃圾回收，影响对象生命周期
 * 
 * @since Lua 5.0
 * @see luaD_call(), luaF_newLclosure(), luaG_checkcode()
 */
LUAI_FUNC void luaV_execute(lua_State *L, int nexeccalls);

/**
 * @brief 字符串连接操作：实现Lua的字符串连接运算符（..）
 * 
 * 详细说明：
 * 实现Lua中的字符串连接操作，支持多个值的连接、自动类型转换
 * 和高效的内存管理。这是Lua字符串操作的核心函数之一。
 * 
 * 连接算法：
 * 1. 收集阶段：遍历栈上的所有操作数，计算总长度
 * 2. 转换阶段：将非字符串值转换为字符串表示
 * 3. 分配阶段：分配足够大的内存缓冲区
 * 4. 复制阶段：按顺序复制所有字符串内容
 * 5. 内部化：将结果字符串添加到字符串池
 * 
 * 类型转换：
 * - 字符串：直接使用，无需转换
 * - 数值：格式化为字符串，使用标准格式
 * - 其他类型：调用相应的__tostring元方法
 * - 转换失败：抛出类型错误
 * 
 * 内存优化：
 * - 一次分配：预先计算总长度，避免多次重分配
 * - 增量复制：按块复制数据，提高缓存效率
 * - 字符串内部化：避免重复的字符串对象
 * - 垃圾回收友好：及时释放临时对象
 * 
 * 性能特征：
 * - 时间复杂度：O(n)，其中n是结果字符串的长度
 * - 空间复杂度：O(n)，需要额外空间存储结果
 * - 优化策略：连续的字符串连接会被优化
 * 
 * 栈操作：
 * 函数操作栈顶的多个值，从栈位置(top-total)到(top-1)的所有值
 * 都会被连接，连接后的结果替换这些值，栈顶指针相应调整。
 * 
 * 错误处理：
 * - 类型错误：无法转换为字符串的值
 * - 内存错误：分配结果字符串失败
 * - 长度错误：结果字符串过长（超过SIZE_MAX）
 * 
 * @param[in] L Lua状态机指针，用于内存分配和类型转换
 * @param[in] total 要连接的值的总数，从栈顶开始计数
 * @param[in] last 最后一个要连接的值在栈中的位置（相对于栈顶）
 * 
 * @pre L != NULL
 * @pre total > 0 && last >= 0
 * @pre 栈上有至少total个值可用于连接
 * @post 栈顶的total个值被连接结果替换，栈大小减少(total-1)
 * 
 * @throws LUA_ERRRUN 类型转换失败或无法连接的类型
 * @throws LUA_ERRMEM 内存分配失败或结果字符串过长
 * 
 * @note 可能触发__tostring元方法和垃圾回收
 * @warning 可能产生很长的字符串，消耗大量内存
 * @warning 元方法调用可能产生副作用或错误
 * 
 * @since Lua 5.0
 * @see luaV_tostring(), luaS_newlstr(), luaZ_buffer
 */
LUAI_FUNC void luaV_concat(lua_State *L, int total, int last);

#endif
