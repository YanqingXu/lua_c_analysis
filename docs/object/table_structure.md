# ğŸ—‚ï¸ Table æ··åˆæ•°æ®ç»“æ„æ·±åº¦è§£æ

> **æŠ€æœ¯ä¸»é¢˜**ï¼šLua å”¯ä¸€æ•°æ®ç»“æ„çš„å†…éƒ¨å®ç° - æ•°ç»„ä¸å“ˆå¸Œè¡¨çš„å®Œç¾èåˆ  
> **æºæ–‡ä»¶**ï¼š`ltable.c`, `ltable.h`  
> **è®¾è®¡æ¨¡å¼**ï¼šHybrid Array-Hash Structure (æ··åˆæ•°ç»„-å“ˆå¸Œç»“æ„)

---

## ğŸ“‹ æ¦‚è¿°

**Table** æ˜¯ Lua è¯­è¨€ä¸­**å”¯ä¸€çš„æ•°æ®ç»“æ„**ï¼Œå´èƒ½å¤Ÿå®Œæˆæ•°ç»„ã€å­—å…¸ã€å¯¹è±¡ã€é›†åˆç­‰å¤šç§æ•°æ®ç»“æ„çš„åŠŸèƒ½ã€‚è¿™ç§å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›æºäºå…¶ç²¾å¦™çš„**æ··åˆç»“æ„è®¾è®¡**ï¼šåŒæ—¶åŒ…å«æ•°ç»„éƒ¨åˆ†å’Œå“ˆå¸Œéƒ¨åˆ†ï¼Œæ ¹æ®é”®çš„ç±»å‹å’Œåˆ†å¸ƒè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜å­˜å‚¨æ–¹å¼ã€‚

### æ ¸å¿ƒç‰¹æ€§

<table>
<tr>
<th width="25%">ç‰¹æ€§</th>
<th width="75%">è¯´æ˜</th>
</tr>

<tr>
<td><b>æ··åˆç»“æ„</b></td>
<td>
åŒæ—¶ç»´æŠ¤æ•°ç»„éƒ¨åˆ†ï¼ˆarray partï¼‰å’Œå“ˆå¸Œéƒ¨åˆ†ï¼ˆhash partï¼‰ï¼Œè‡ªåŠ¨æ ¹æ®é”®çš„ç±»å‹å’Œåˆ†å¸ƒé€‰æ‹©å­˜å‚¨ä½ç½®
</td>
</tr>

<tr>
<td><b>è‡ªé€‚åº”è°ƒæ•´</b></td>
<td>
é€šè¿‡ rehash ç®—æ³•åŠ¨æ€è°ƒæ•´æ•°ç»„å’Œå“ˆå¸Œéƒ¨åˆ†çš„å¤§å°ï¼Œä¼˜åŒ–å†…å­˜ä½¿ç”¨å’Œè®¿é—®æ€§èƒ½
</td>
</tr>

<tr>
<td><b>é«˜æ•ˆè®¿é—®</b></td>
<td>
â€¢ æ•°ç»„éƒ¨åˆ†ï¼šO(1) ç›´æ¥ç´¢å¼•ï¼Œæ— å“ˆå¸Œè®¡ç®—<br/>
â€¢ å“ˆå¸Œéƒ¨åˆ†ï¼šO(1) å¹³å‡æ—¶é—´ï¼Œå¼€æ”¾åœ°å€æ³•å¤„ç†å†²çª
</td>
</tr>

<tr>
<td><b>çµæ´»é”®ç±»å‹</b></td>
<td>
æ”¯æŒé™¤ nil å¤–çš„ä»»æ„ç±»å‹ä½œä¸ºé”®ï¼ˆnumber, string, table, function ç­‰ï¼‰ï¼Œå€¼ä¹Ÿå¯ä¸ºä»»æ„ç±»å‹
</td>
</tr>

<tr>
<td><b>å†…å­˜ä¼˜åŒ–</b></td>
<td>
ç¨€ç–æ•°ç»„ä½¿ç”¨å“ˆå¸Œéƒ¨åˆ†ï¼Œå¯†é›†æ•°ç»„ä½¿ç”¨æ•°ç»„éƒ¨åˆ†ï¼Œé¿å…ç©ºé—´æµªè´¹
</td>
</tr>

<tr>
<td><b>å…ƒè¡¨æ”¯æŒ</b></td>
<td>
æ¯ä¸ª table å¯å…³è”å…ƒè¡¨ï¼Œå®ç°è¿ç®—ç¬¦é‡è½½å’Œé¢å‘å¯¹è±¡ç‰¹æ€§
</td>
</tr>
</table>

### è®¾è®¡å“²å­¦

Lua Table çš„è®¾è®¡ä½“ç°äº†**ç®€å•æ€§**å’Œ**é«˜æ•ˆæ€§**çš„å®Œç¾å¹³è¡¡ï¼š

```mermaid
mindmap
  root((Table è®¾è®¡å“²å­¦))
    ç®€å•æ€§
      å”¯ä¸€æ•°æ®ç»“æ„
      ç»Ÿä¸€çš„è¯­æ³•
      æ˜“äºå­¦ä¹ ä½¿ç”¨
      é™ä½å¿ƒæ™ºè´Ÿæ‹…
    é«˜æ•ˆæ€§
      æ•°ç»„å¿«é€Ÿè®¿é—®
      å“ˆå¸Œé«˜æ•ˆæŸ¥æ‰¾
      è‡ªåŠ¨ä¼˜åŒ–å¸ƒå±€
      å†…å­˜èŠ‚çœç©ºé—´
    çµæ´»æ€§
      ä»»æ„ç±»å‹é”®å€¼
      åŠ¨æ€æ‰©å®¹æ”¶ç¼©
      å…ƒè¡¨æ‰©å±•èƒ½åŠ›
      å¤šç§ç”¨é€”
    å®ç”¨æ€§
      æ•°ç»„åŠŸèƒ½
      å­—å…¸åŠŸèƒ½
      å¯¹è±¡æ¨¡æ‹Ÿ
      é›†åˆå®ç°
```

### æ¶æ„å…¨æ™¯å›¾

```mermaid
graph TB
    subgraph "Table å¯¹è±¡"
        Table["Table ç»“æ„<br/>æ ¸å¿ƒæ§åˆ¶"]
        Array["æ•°ç»„éƒ¨åˆ†<br/>TValue[]"]
        Hash["å“ˆå¸Œéƒ¨åˆ†<br/>Node[]"]
        Meta["å…ƒè¡¨<br/>Table*"]
    end
    
    Table --> Array
    Table --> Hash
    Table --> Meta
    
    subgraph "æ•°ç»„éƒ¨åˆ†ç‰¹ç‚¹"
        A1["è¿ç»­æ•´æ•°é”®<br/>1, 2, 3, ..."]
        A2["O(1) ç›´æ¥è®¿é—®<br/>array[key-1]"]
        A3["å¯†é›†å­˜å‚¨<br/>æ— ç©ºé—´æµªè´¹"]
    end
    
    Array --> A1
    Array --> A2
    Array --> A3
    
    subgraph "å“ˆå¸Œéƒ¨åˆ†ç‰¹ç‚¹"
        H1["ä»»æ„ç±»å‹é”®<br/>string, float, tableç­‰"]
        H2["O(1) å¹³å‡æŸ¥æ‰¾<br/>å¼€æ”¾åœ°å€æ³•"]
        H3["åŠ¨æ€æ‰©å®¹<br/>2çš„å¹‚æ¬¡å¤§å°"]
    end
    
    Hash --> H1
    Hash --> H2
    Hash --> H3
    
    subgraph "è‡ªåŠ¨ä¼˜åŒ–"
        R1["Rehash ç®—æ³•"]
        R2["è´Ÿè½½å› å­ç›‘æ§"]
        R3["æœ€ä¼˜å¤§å°è®¡ç®—"]
    end
    
    Table --> R1
    R1 --> R2
    R2 --> R3
    R3 --> Array
    R3 --> Hash
    
    style Table fill:#e1f5ff
    style Array fill:#e8f5e9
    style Hash fill:#fff4e6
    style Meta fill:#f3e5f5
```

### å†å²æ¼”è¿›

```mermaid
timeline
    title Table ç»“æ„æ¼”è¿›å†ç¨‹
    
    section Lua 3.x
        çº¯å“ˆå¸Œè¡¨ : æ‰€æœ‰é”®å€¼éƒ½ç”¨å“ˆå¸Œè¡¨å­˜å‚¨
                  : æ•´æ•°é”®ä¹Ÿéœ€è¦å“ˆå¸Œè®¡ç®—
                  : å†…å­˜æ•ˆç‡è¾ƒä½
    
    section Lua 4.0
        å¼•å…¥æ··åˆç»“æ„ : é¦–æ¬¡åŒºåˆ†æ•°ç»„å’Œå“ˆå¸Œéƒ¨åˆ†
                     : æ•´æ•°é”®ä½¿ç”¨æ•°ç»„å­˜å‚¨
                     : æ€§èƒ½æ˜¾è‘—æå‡
    
    section Lua 5.0
        Rehash ä¼˜åŒ– : å¼•å…¥æ™ºèƒ½ rehash ç®—æ³•
                     : åŠ¨æ€å¹³è¡¡æ•°ç»„å’Œå“ˆå¸Œå¤§å°
                     : å‡å°‘ä¸å¿…è¦çš„æ‰©å®¹
    
    section Lua 5.1
        ç¨³å®šç‰ˆæœ¬ : æœ¬æ–‡æ¡£è®¨è®ºçš„ç‰ˆæœ¬
                  : rehash ç®—æ³•æˆç†Ÿ
                  : æ€§èƒ½å’Œå†…å­˜è¾¾åˆ°æœ€ä¼˜
    
    section LuaJIT
        æè‡´ä¼˜åŒ– : JIT ç¼–è¯‘ table æ“ä½œ
                  : å†…è”ç¼“å­˜ä¼˜åŒ–
                  : table.new() é¢„åˆ†é…
```

---

## ğŸ”§ æ ¸å¿ƒæ•°æ®ç»“æ„

### Table ä¸»ç»“æ„

```c
// ltable.h
typedef struct Table {
    CommonHeader;           // GC å¤´éƒ¨ï¼ˆnext, tt, markedï¼‰
    lu_byte flags;          // å…ƒæ–¹æ³•æ ‡å¿—ä½ï¼ˆç¼“å­˜å“ªäº›å…ƒæ–¹æ³•å­˜åœ¨ï¼‰
    lu_byte lsizenode;      // å“ˆå¸Œéƒ¨åˆ†å¤§å°çš„ log2 å€¼ï¼ˆå®é™…å¤§å° = 2^lsizenodeï¼‰
    struct Table *metatable;// å…ƒè¡¨æŒ‡é’ˆ
    TValue *array;          // æ•°ç»„éƒ¨åˆ†æŒ‡é’ˆ
    Node *node;             // å“ˆå¸Œéƒ¨åˆ†æŒ‡é’ˆ
    Node *lastfree;         // å“ˆå¸Œéƒ¨åˆ†æœ€åä¸€ä¸ªç©ºé—²èŠ‚ç‚¹ï¼ˆä»åå‘å‰åˆ†é…ï¼‰
    GCObject *gclist;       // GC é“¾è¡¨ï¼ˆç”¨äºéå†æ‰€æœ‰ tableï¼‰
    int sizearray;          // æ•°ç»„éƒ¨åˆ†å¤§å°ï¼ˆå…ƒç´ ä¸ªæ•°ï¼‰
} Table;
```

**å­—æ®µè¯¦è§£**ï¼š

<table>
<tr>
<th width="20%">å­—æ®µ</th>
<th width="20%">ç±»å‹</th>
<th width="60%">è¯´æ˜</th>
</tr>

<tr>
<td><code>flags</code></td>
<td>lu_byte</td>
<td>
<b>å…ƒæ–¹æ³•ç¼“å­˜æ ‡å¿—</b><br/>
â€¢ æ¯ä¸ªä½å¯¹åº”ä¸€ä¸ªå…ƒæ–¹æ³•ï¼ˆå¦‚ __index, __newindexï¼‰<br/>
â€¢ ä½ä¸º 1 è¡¨ç¤ºè¯¥å…ƒæ–¹æ³•ä¸å­˜åœ¨ï¼Œé¿å…é‡å¤æŸ¥æ‰¾<br/>
â€¢ ä¼˜åŒ–ï¼šå¿«é€Ÿåˆ¤æ–­æ˜¯å¦éœ€è¦è§¦å‘å…ƒæ–¹æ³•
</td>
</tr>

<tr>
<td><code>lsizenode</code></td>
<td>lu_byte</td>
<td>
<b>å“ˆå¸Œå¤§å°çš„å¯¹æ•°å€¼</b><br/>
â€¢ å®é™…å“ˆå¸Œå¤§å° = 2^lsizenode<br/>
â€¢ å–å€¼èŒƒå›´ï¼š0-26ï¼ˆæœ€å¤§ 2^26 = 67M èŠ‚ç‚¹ï¼‰<br/>
â€¢ ä½¿ç”¨å¯¹æ•°å­˜å‚¨èŠ‚çœç©ºé—´ï¼ˆ1å­—èŠ‚ vs 4å­—èŠ‚ï¼‰
</td>
</tr>

<tr>
<td><code>metatable</code></td>
<td>Table*</td>
<td>
<b>å…ƒè¡¨æŒ‡é’ˆ</b><br/>
â€¢ æŒ‡å‘è¯¥ table çš„å…ƒè¡¨ï¼ˆå¯ä¸º NULLï¼‰<br/>
â€¢ å…ƒè¡¨æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ª table<br/>
â€¢ ç”¨äºå®ç°è¿ç®—ç¬¦é‡è½½å’Œé¢å‘å¯¹è±¡
</td>
</tr>

<tr>
<td><code>array</code></td>
<td>TValue*</td>
<td>
<b>æ•°ç»„éƒ¨åˆ†</b><br/>
â€¢ æŒ‡å‘ TValue æ•°ç»„<br/>
â€¢ å­˜å‚¨é”®ä¸º 1 åˆ° sizearray çš„è¿ç»­æ•´æ•°<br/>
â€¢ å¯ä¸º NULLï¼ˆçº¯å“ˆå¸Œè¡¨ï¼‰
</td>
</tr>

<tr>
<td><code>node</code></td>
<td>Node*</td>
<td>
<b>å“ˆå¸Œéƒ¨åˆ†</b><br/>
â€¢ æŒ‡å‘ Node æ•°ç»„<br/>
â€¢ å­˜å‚¨éè¿ç»­æ•´æ•°é”®å’Œå…¶ä»–ç±»å‹é”®<br/>
â€¢ å¤§å°å§‹ç»ˆä¸º 2 çš„å¹‚
</td>
</tr>

<tr>
<td><code>lastfree</code></td>
<td>Node*</td>
<td>
<b>ç©ºé—²èŠ‚ç‚¹æŒ‡é’ˆ</b><br/>
â€¢ æŒ‡å‘å“ˆå¸Œéƒ¨åˆ†æœ€åä¸€ä¸ªæœªä½¿ç”¨çš„èŠ‚ç‚¹<br/>
â€¢ ä»åå‘å‰åˆ†é…ï¼Œç”¨äºå¿«é€Ÿæ‰¾åˆ°ç©ºé—²ä½ç½®<br/>
â€¢ ä¸º NULL è¡¨ç¤ºå“ˆå¸Œéƒ¨åˆ†å·²æ»¡
</td>
</tr>

<tr>
<td><code>sizearray</code></td>
<td>int</td>
<td>
<b>æ•°ç»„å¤§å°</b><br/>
â€¢ æ•°ç»„éƒ¨åˆ†çš„å…ƒç´ ä¸ªæ•°<br/>
â€¢ å¯ä¸º 0ï¼ˆçº¯å“ˆå¸Œè¡¨ï¼‰<br/>
â€¢ é€šå¸¸æ˜¯ 2 çš„å¹‚ï¼ˆä¼˜åŒ– rehashï¼‰
</td>
</tr>
</table>

### Node èŠ‚ç‚¹ç»“æ„

```c
// ltable.h
typedef struct Node {
    TValue i_val;           // å€¼
    TKey i_key;             // é”®
} Node;

typedef union TKey {
    struct {
        Value value;        // é”®çš„å€¼ï¼ˆä¸ TValue.value ç›¸åŒï¼‰
        int tt;             // é”®çš„ç±»å‹æ ‡è®°
        struct Node *next;  // å†²çªé“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    } nk;
    TValue tvk;             // ç”¨äºå¿«é€Ÿè®¿é—®ï¼ˆä¸ nk å†…å­˜å¸ƒå±€å…¼å®¹ï¼‰
} TKey;
```

**Node è®¾è®¡è¦ç‚¹**ï¼š

1. **TKey è”åˆä½“**ï¼šå…¼å®¹ TValueï¼Œå¯ç›´æ¥è¿›è¡Œç±»å‹æ£€æŸ¥å’Œå€¼æ¯”è¾ƒ
2. **å†…ç½®é“¾è¡¨æŒ‡é’ˆ**ï¼š`next` å­—æ®µå®ç°å¼€æ”¾åœ°å€æ³•çš„å†²çªé“¾
3. **å†…å­˜å¯¹é½**ï¼šNode å¤§å°é€šå¸¸ä¸º 32 å­—èŠ‚ï¼ˆ64ä½ç³»ç»Ÿï¼‰

### å†…å­˜å¸ƒå±€è¯¦è§£

**64ä½ç³»ç»Ÿä¸Šçš„å®Œæ•´å¸ƒå±€**ï¼š

```
Table å¯¹è±¡ï¼ˆä¸»ç»“æ„ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CommonHeader (GC)           8 å­—èŠ‚                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  flags                       1 å­—èŠ‚                     â”‚
â”‚  lsizenode                   1 å­—èŠ‚                     â”‚
â”‚  padding                     6 å­—èŠ‚ (å¯¹é½)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  metatable                   8 å­—èŠ‚ (æŒ‡é’ˆ)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  array                       8 å­—èŠ‚ (æŒ‡é’ˆ)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  node                        8 å­—èŠ‚ (æŒ‡é’ˆ)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  lastfree                    8 å­—èŠ‚ (æŒ‡é’ˆ)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  gclist                      8 å­—èŠ‚ (æŒ‡é’ˆ)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  sizearray                   4 å­—èŠ‚                     â”‚
â”‚  padding                     4 å­—èŠ‚ (å¯¹é½)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ€»å¤§å°ï¼šçº¦ 64 å­—èŠ‚

æ•°ç»„éƒ¨åˆ†ï¼ˆTValue æ•°ç»„ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TValue[0]                   16 å­—èŠ‚                    â”‚
â”‚  TValue[1]                   16 å­—èŠ‚                    â”‚
â”‚  TValue[2]                   16 å­—èŠ‚                    â”‚
â”‚  ...                                                    â”‚
â”‚  TValue[sizearray-1]         16 å­—èŠ‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ€»å¤§å°ï¼šsizearray * 16 å­—èŠ‚

å“ˆå¸Œéƒ¨åˆ†ï¼ˆNode æ•°ç»„ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Node[0]                     32 å­—èŠ‚                    â”‚
â”‚    â”œâ”€ i_val (TValue)         16 å­—èŠ‚                    â”‚
â”‚    â””â”€ i_key (TKey)           16 å­—èŠ‚                    â”‚
â”‚       â”œâ”€ value               8 å­—èŠ‚                     â”‚
â”‚       â”œâ”€ tt                  4 å­—èŠ‚                     â”‚
â”‚       â””â”€ next                8 å­—èŠ‚ (æŒ‡é’ˆï¼Œå«4å­—èŠ‚å¡«å……) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Node[1]                     32 å­—èŠ‚                    â”‚
â”‚  ...                                                    â”‚
â”‚  Node[2^lsizenode - 1]       32 å­—èŠ‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ€»å¤§å°ï¼š2^lsizenode * 32 å­—èŠ‚
```

### å†…å­˜å ç”¨è®¡ç®—

**ç¤ºä¾‹1ï¼šç©ºè¡¨**
```c
Table *t = luaH_new(L, 0, 0);  // æ•°ç»„å¤§å°=0ï¼Œå“ˆå¸Œå¤§å°=0
```
- Table ç»“æ„ï¼š64 å­—èŠ‚
- æ•°ç»„éƒ¨åˆ†ï¼š0 å­—èŠ‚
- å“ˆå¸Œéƒ¨åˆ†ï¼š1 ä¸ª dummynodeï¼ˆ32 å­—èŠ‚ï¼Œå…¨å±€å…±äº«ï¼‰
- **æ€»è®¡**ï¼š64 å­—èŠ‚ï¼ˆä¸å«å…±äº«çš„ dummynodeï¼‰

**ç¤ºä¾‹2ï¼šå°æ•°ç»„ t = {1, 2, 3, 4, 5}**
```c
Table *t = luaH_new(L, 8, 0);  // æ•°ç»„å¤§å°=8ï¼Œå“ˆå¸Œå¤§å°=0
```
- Table ç»“æ„ï¼š64 å­—èŠ‚
- æ•°ç»„éƒ¨åˆ†ï¼š8 Ã— 16 = 128 å­—èŠ‚
- å“ˆå¸Œéƒ¨åˆ†ï¼š0 å­—èŠ‚ï¼ˆä½¿ç”¨ dummynodeï¼‰
- **æ€»è®¡**ï¼š192 å­—èŠ‚

**ç¤ºä¾‹3ï¼šæ··åˆè¡¨ t = {1, 2, name="lua", version=5.1}**
```c
// æ•°ç»„å¤§å°=4ï¼Œå“ˆå¸Œå¤§å°=4ï¼ˆ2^2ï¼‰
```
- Table ç»“æ„ï¼š64 å­—èŠ‚
- æ•°ç»„éƒ¨åˆ†ï¼š4 Ã— 16 = 64 å­—èŠ‚
- å“ˆå¸Œéƒ¨åˆ†ï¼š4 Ã— 32 = 128 å­—èŠ‚
- **æ€»è®¡**ï¼š256 å­—èŠ‚

---

## ğŸ”‘ é”®çš„å­˜å‚¨ç­–ç•¥

### é”®ç±»å‹åˆ†ç±»

Lua Table æ ¹æ®é”®çš„ç±»å‹å’Œå€¼é‡‡ç”¨ä¸åŒçš„å­˜å‚¨ç­–ç•¥ï¼š

```mermaid
flowchart TD
    Start["é”® k"] --> IsNil{"k == nil?"}
    
    IsNil -->|æ˜¯| Error["âŒ é”™è¯¯<br/>nil ä¸èƒ½ä½œä¸ºé”®"]
    IsNil -->|å¦| IsNum{"æ˜¯å¦ä¸º number?"}
    
    IsNum -->|æ˜¯| IsInt{"æ˜¯å¦ä¸ºæ•´æ•°?"}
    IsNum -->|å¦| ToHash["â†’ å“ˆå¸Œéƒ¨åˆ†"]
    
    IsInt -->|æ˜¯| InRange{"1 â‰¤ k â‰¤ sizearray?"}
    IsInt -->|å¦| ToHash
    
    InRange -->|æ˜¯| ToArray["â†’ æ•°ç»„éƒ¨åˆ†<br/>array[k-1]"]
    InRange -->|å¦| CheckFit{"k æ˜¯å¦é€‚åˆæ•°ç»„?"}
    
    CheckFit -->|æ˜¯<br/>rehash| ToArray
    CheckFit -->|å¦| ToHash
    
    style Start fill:#e1f5ff
    style ToArray fill:#e8f5e9
    style ToHash fill:#fff4e6
    style Error fill:#ffebee
```

### æ•°ç»„é”®åˆ¤æ–­

**æ»¡è¶³ä»¥ä¸‹æ‰€æœ‰æ¡ä»¶çš„é”®å­˜å‚¨åœ¨æ•°ç»„éƒ¨åˆ†**ï¼š

1. **ç±»å‹ä¸º number**
2. **å€¼ä¸ºæ­£æ•´æ•°**ï¼ˆ`k == floor(k) && k > 0`ï¼‰
3. **èŒƒå›´åˆé€‚**ï¼ˆ`1 â‰¤ k â‰¤ sizearray`ï¼‰

```c
// ltable.c: åˆ¤æ–­é”®æ˜¯å¦é€‚åˆæ•°ç»„éƒ¨åˆ†
static int is_array_key(lua_Number n) {
    int k;
    return (luai_num2int(k, n) && k > 0);
}

// å¿«é€Ÿåˆ¤æ–­å®
#define arrayindex(key) \
    (ttisnumber(key) && luai_num2int(k, nvalue(key)) && k > 0 && k <= sizearray)
```

### é”®çš„å“ˆå¸Œè®¡ç®—

å¯¹äºå­˜å‚¨åœ¨å“ˆå¸Œéƒ¨åˆ†çš„é”®ï¼Œéœ€è¦è®¡ç®—å“ˆå¸Œå€¼å®šä½åˆ° Node æ§½ä½ï¼š

```c
// ltable.c
static Node *mainposition(const Table *t, const TValue *key) {
    switch (ttype(key)) {
        case LUA_TNUMBER: {
            lua_Number n = nvalue(key);
            return hashnum(t, n);  // æ•°å­—å“ˆå¸Œ
        }
        case LUA_TSTRING: {
            TString *s = rawtsvalue(key);
            return hashstr(t, s);  // å­—ç¬¦ä¸²å“ˆå¸Œï¼ˆä½¿ç”¨ç¼“å­˜çš„ hash å€¼ï¼‰
        }
        case LUA_TBOOLEAN: {
            return hashboolean(t, bvalue(key));  // å¸ƒå°”å“ˆå¸Œ
        }
        case LUA_TLIGHTUSERDATA: {
            return hashpointer(t, pvalue(key));  // è½»é‡ç”¨æˆ·æ•°æ®å“ˆå¸Œ
        }
        default: {
            return hashpointer(t, gcvalue(key));  // GC å¯¹è±¡å“ˆå¸Œï¼ˆç”¨æŒ‡é’ˆï¼‰
        }
    }
}
```

**å„ç±»å‹å“ˆå¸Œç­–ç•¥**ï¼š

<table>
<tr>
<th width="20%">é”®ç±»å‹</th>
<th width="40%">å“ˆå¸Œæ–¹æ³•</th>
<th width="40%">è¯´æ˜</th>
</tr>

<tr>
<td><b>number</b></td>
<td><code>hashnum(t, n)</code></td>
<td>
å¯¹æµ®ç‚¹æ•°çš„ä½æ¨¡å¼è¿›è¡Œå“ˆå¸Œ<br/>
æ•´æ•°å’Œå¯¹åº”çš„æµ®ç‚¹æ•°å“ˆå¸Œå€¼ç›¸åŒ
</td>
</tr>

<tr>
<td><b>string</b></td>
<td><code>hashstr(t, s)</code></td>
<td>
ä½¿ç”¨å­—ç¬¦ä¸²å¯¹è±¡ç¼“å­˜çš„ <code>hash</code> å­—æ®µ<br/>
O(1) æ—¶é—´ï¼Œæ— éœ€é‡æ–°è®¡ç®—
</td>
</tr>

<tr>
<td><b>boolean</b></td>
<td><code>hashboolean(t, b)</code></td>
<td>
true å’Œ false åˆ†åˆ«æ˜ å°„åˆ°å›ºå®šä½ç½®
</td>
</tr>

<tr>
<td><b>lightuserdata</b></td>
<td><code>hashpointer(t, p)</code></td>
<td>
å¯¹æŒ‡é’ˆå€¼è¿›è¡Œå“ˆå¸Œ
</td>
</tr>

<tr>
<td><b>table/function/userdata/thread</b></td>
<td><code>hashpointer(t, gcvalue(key))</code></td>
<td>
å¯¹ GC å¯¹è±¡çš„æŒ‡é’ˆè¿›è¡Œå“ˆå¸Œ<br/>
ç›¸åŒå¯¹è±¡å“ˆå¸Œå€¼ç›¸åŒï¼ˆæŒ‡é’ˆç›¸ç­‰ï¼‰
</td>
</tr>
</table>

---

## ğŸ” æŸ¥æ‰¾æ“ä½œ

### æ•°ç»„éƒ¨åˆ†æŸ¥æ‰¾

æ•°ç»„éƒ¨åˆ†çš„æŸ¥æ‰¾æå…¶ç®€å•é«˜æ•ˆï¼š

```c
// ltable.c: luaH_getnum() - é€šè¿‡æ•´æ•°é”®è·å–å€¼
const TValue *luaH_getnum(Table *t, int key) {
    // å¿«é€Ÿè·¯å¾„ï¼šåœ¨æ•°ç»„èŒƒå›´å†…
    if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
        return &t->array[key-1];
    else {
        // æ…¢é€Ÿè·¯å¾„ï¼šåœ¨å“ˆå¸Œéƒ¨åˆ†æŸ¥æ‰¾
        lua_Number nk = cast_num(key);
        Node *n = hashnum(t, nk);
        do {
            if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
                return gval(n);  // æ‰¾åˆ°
            else n = gnext(n);    // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        } while (n);
        return luaO_nilobject;    // æœªæ‰¾åˆ°
    }
}
```

**æ€§èƒ½åˆ†æ**ï¼š
- **æ—¶é—´å¤æ‚åº¦**ï¼šO(1)
- **æŒ‡ä»¤æ•°é‡**ï¼šçº¦ 5-10 æ¡ CPU æŒ‡ä»¤
  1. é”®å‡ 1ï¼ˆ`key-1`ï¼‰
  2. æ— ç¬¦å·æ¯”è¾ƒï¼ˆ`< sizearray`ï¼‰
  3. æ•°ç»„åŸºå€åŠ åç§»ï¼ˆ`array + (key-1)*16`ï¼‰
  4. è¿”å›æŒ‡é’ˆ

### å“ˆå¸Œéƒ¨åˆ†æŸ¥æ‰¾

å“ˆå¸Œéƒ¨åˆ†ä½¿ç”¨**å¼€æ”¾åœ°å€æ³•**å¤„ç†å†²çªï¼š

```c
// ltable.c: luaH_get() - é€šç”¨æŸ¥æ‰¾
const TValue *luaH_get(Table *t, const TValue *key) {
    switch (ttype(key)) {
        case LUA_TNIL: return luaO_nilobject;  // nil é”®è¿”å› nil
        case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));  // å­—ç¬¦ä¸²ä¼˜åŒ–
        case LUA_TNUMBER: {
            int k;
            lua_Number n = nvalue(key);
            if (luai_num2int(k, n))  // å°è¯•è½¬æ¢ä¸ºæ•´æ•°
                return luaH_getnum(t, k);
            // å¦åˆ™ä½œä¸ºæµ®ç‚¹æ•°åœ¨å“ˆå¸Œä¸­æŸ¥æ‰¾
        }
        default: {
            // å…¶ä»–ç±»å‹åœ¨å“ˆå¸Œéƒ¨åˆ†æŸ¥æ‰¾
            Node *n = mainposition(t, key);  // è®¡ç®—ä¸»ä½ç½®
            do {
                if (luaO_rawequalObj(gkey(n), key))
                    return gval(n);  // é”®ç›¸ç­‰ï¼Œè¿”å›å€¼
                else n = gnext(n);    // ä¸‹ä¸€ä¸ªå†²çªèŠ‚ç‚¹
            } while (n);
            return luaO_nilobject;    // æœªæ‰¾åˆ°
        }
    }
}
```

**æŸ¥æ‰¾æµç¨‹å›¾**ï¼š

```mermaid
sequenceDiagram
    participant Caller as è°ƒç”¨è€…
    participant Hash as å“ˆå¸Œå‡½æ•°
    participant Main as ä¸»ä½ç½®
    participant Chain as å†²çªé“¾
    
    Caller->>Hash: è®¡ç®—é”®çš„å“ˆå¸Œå€¼
    Hash->>Main: å®šä½ä¸»ä½ç½® node[h]
    
    alt ä¸»ä½ç½®åŒ¹é…
        Main->>Caller: è¿”å› node[h].value
    else ä¸»ä½ç½®ä¸åŒ¹é…
        Main->>Chain: è·Ÿéš next æŒ‡é’ˆ
        
        loop éå†å†²çªé“¾
            Chain->>Chain: æ¯”è¾ƒ node[i].key
            alt æ‰¾åˆ°åŒ¹é…
                Chain->>Caller: è¿”å› node[i].value
            end
        end
        
        alt é“¾å°¾ä»æœªæ‰¾åˆ°
            Chain->>Caller: è¿”å› nil
        end
    end
```

### å­—ç¬¦ä¸²é”®ä¼˜åŒ–

å­—ç¬¦ä¸²æ˜¯ Lua ä¸­æœ€å¸¸ç”¨çš„ table é”®ç±»å‹ï¼Œå› æ­¤æœ‰ä¸“é—¨çš„ä¼˜åŒ–è·¯å¾„ï¼š

```c
// ltable.c
const TValue *luaH_getstr(Table *t, TString *key) {
    Node *n = hashstr(t, key);  // ä½¿ç”¨ç¼“å­˜çš„ hash å€¼
    do {
        if (ttisstring(gkey(n)) && rawtsvalue(gkey(n)) == key)
            return gval(n);  // æŒ‡é’ˆæ¯”è¾ƒï¼ŒO(1)
        else n = gnext(n);
    } while (n);
    return luaO_nilobject;
}
```

**ä¼˜åŒ–ç‚¹**ï¼š
1. **å“ˆå¸Œå€¼ç¼“å­˜**ï¼šå­—ç¬¦ä¸²å¯¹è±¡å·²å­˜å‚¨ `hash` å­—æ®µï¼Œæ— éœ€é‡æ–°è®¡ç®—
2. **æŒ‡é’ˆæ¯”è¾ƒ**ï¼šå­—ç¬¦ä¸²æ± åŒ–ä¿è¯ç›¸åŒå†…å®¹çš„å­—ç¬¦ä¸²æŒ‡é’ˆç›¸åŒï¼Œæ¯”è¾ƒ O(1)
3. **æ— éœ€é€å­—ç¬¦æ¯”è¾ƒ**ï¼šèŠ‚çœå¤§é‡ CPU æ—¶é—´

---

## âœï¸ æ’å…¥æ“ä½œ

### æ’å…¥æµç¨‹æ¦‚è§ˆ

```mermaid
flowchart TD
    Start["t[key] = value"] --> CheckNil{"value == nil?"}
    
    CheckNil -->|æ˜¯| Delete["åˆ é™¤æ“ä½œ<br/>ï¼ˆè®¾ç½®ä¸º nilï¼‰"]
    CheckNil -->|å¦| CheckKey{"key ç±»å‹?"}
    
    CheckKey -->|æ•´æ•°é”®<br/>åœ¨æ•°ç»„èŒƒå›´| ArraySet["æ•°ç»„éƒ¨åˆ†èµ‹å€¼<br/>array[key-1] = value"]
    CheckKey -->|å…¶ä»–| HashFind["åœ¨å“ˆå¸Œéƒ¨åˆ†æŸ¥æ‰¾ key"]
    
    HashFind --> Found{"æ‰¾åˆ°?"}
    
    Found -->|æ˜¯| Update["æ›´æ–°å·²å­˜åœ¨èŠ‚ç‚¹<br/>node.value = value"]
    Found -->|å¦| NeedNew["éœ€è¦æ–°èŠ‚ç‚¹"]
    
    NeedNew --> HasFree{"æœ‰ç©ºé—²èŠ‚ç‚¹?"}
    
    HasFree -->|æ˜¯| Allocate["åˆ†é…ç©ºé—²èŠ‚ç‚¹<br/>ä» lastfree è·å–"]
    HasFree -->|å¦| Rehash["è§¦å‘ Rehash<br/>æ‰©å®¹å“ˆå¸Œéƒ¨åˆ†"]
    
    Rehash --> Allocate
    Allocate --> Insert["æ’å…¥æ–°é”®å€¼å¯¹"]
    
    ArraySet --> End["å®Œæˆ"]
    Update --> End
    Delete --> End
    Insert --> End
    
    style Start fill:#e1f5ff
    style ArraySet fill:#e8f5e9
    style Rehash fill:#ffe1e1
    style End fill:#e8f5e9
```

### æ•°ç»„éƒ¨åˆ†æ’å…¥

```c
// ltable.c: luaH_setnum() - è®¾ç½®æ•´æ•°é”®
TValue *luaH_setnum(lua_State *L, Table *t, int key) {
    const TValue *p = luaH_getnum(t, key);
    if (p != luaO_nilobject)
        return cast(TValue *, p);  // å·²å­˜åœ¨ï¼Œè¿”å›ä½ç½®
    else {
        // ä¸å­˜åœ¨ï¼Œéœ€è¦æ–°é”®
        TValue k;
        setnvalue(&k, cast_num(key));
        return newkey(L, t, &k);  // åˆ›å»ºæ–°é”®ï¼ˆå¯èƒ½è§¦å‘ rehashï¼‰
    }
}
```

### å“ˆå¸Œéƒ¨åˆ†æ’å…¥

```c
// ltable.c: newkey() - åˆ›å»ºæ–°é”®
static TValue *newkey(lua_State *L, Table *t, const TValue *key) {
    Node *mp = mainposition(t, key);  // è®¡ç®—ä¸»ä½ç½®
    
    // æƒ…å†µ1ï¼šä¸»ä½ç½®ç©ºé—²
    if (!ttisnil(gval(mp)) || mp == dummynode) {
        Node *othern;
        Node *n = getfreepos(t);  // è·å–ç©ºé—²èŠ‚ç‚¹
        
        if (n == NULL) {  // æ²¡æœ‰ç©ºé—²èŠ‚ç‚¹
            rehash(L, t, key);  // è§¦å‘ rehash
            return luaH_set(L, t, key);  // é‡æ–°æ’å…¥
        }
        
        // æƒ…å†µ2ï¼šä¸»ä½ç½®è¢«å…¶ä»–é”®å ç”¨
        othern = mainposition(t, gkey(mp));
        if (othern != mp) {
            // mp æ˜¯"å¤–æ¥æˆ·"ï¼Œå°†å…¶ç§»åˆ°ç©ºé—²èŠ‚ç‚¹
            // è¿™æ ·æ–°é”®å¯ä»¥å ç”¨ä¸»ä½ç½®
            // ... å¤æ‚çš„èŠ‚ç‚¹ç§»åŠ¨é€»è¾‘ ...
        }
        else {
            // mp æ˜¯"åŸä½æ°‘"ï¼Œæ–°é”®å ç”¨ç©ºé—²èŠ‚ç‚¹
            // å°†æ–°èŠ‚ç‚¹é“¾æ¥åˆ° mp çš„å†²çªé“¾
            gnext(n) = gnext(mp);
            gnext(mp) = n;
            mp = n;
        }
    }
    
    gkey(mp)->value = key->value;
    gkey(mp)->tt = key->tt;
    luaC_barriert(L, t, key);  // GC å±éšœ
    lua_assert(ttisnil(gval(mp)));
    return gval(mp);
}
```

### ç©ºé—²èŠ‚ç‚¹åˆ†é…

```c
// ltable.c
static Node *getfreepos(Table *t) {
    while (t->lastfree-- > t->node) {
        if (ttisnil(gkey(t->lastfree)))
            return t->lastfree;  // æ‰¾åˆ°ç©ºé—²èŠ‚ç‚¹
    }
    return NULL;  // æ²¡æœ‰ç©ºé—²èŠ‚ç‚¹
}
```

**åˆ†é…ç­–ç•¥**ï¼š
- **ä»åå‘å‰**ï¼š`lastfree` ä»å“ˆå¸Œè¡¨æœ«å°¾å¼€å§‹ï¼Œå‘å‰æ‰«æ
- **å»¶è¿Ÿæœç´¢**ï¼šåªæœ‰åœ¨éœ€è¦æ—¶æ‰æŸ¥æ‰¾ç©ºé—²èŠ‚ç‚¹
- **å¿«é€Ÿåˆ¤æ–­**ï¼šé€šè¿‡ `lastfree` æŒ‡é’ˆå¿«é€Ÿç¡®å®šæ˜¯å¦å·²æ»¡

---

## ğŸ”„ Rehash ç®—æ³•

### Rehash è§¦å‘æ¡ä»¶

Rehash åœ¨ä»¥ä¸‹æƒ…å†µè§¦å‘ï¼š

1. **å“ˆå¸Œéƒ¨åˆ†å·²æ»¡**ï¼š`getfreepos()` è¿”å› NULL
2. **æ’å…¥æ–°é”®**ï¼šéœ€è¦ç©ºé—´ä½†æ— å¯ç”¨èŠ‚ç‚¹
3. **æ˜¾å¼è°ƒç”¨**ï¼šLua å†…éƒ¨æŸäº›æ“ä½œï¼ˆå¦‚ `table.getn`ï¼‰

### Rehash æ ¸å¿ƒç®—æ³•

```c
// ltable.c
static void rehash(lua_State *L, Table *t, const TValue *ek) {
    int nasize, na;
    int nums[MAXBITS+1];  // nums[i] = 2^(i-1) åˆ° 2^i-1 ä¹‹é—´çš„æ•´æ•°é”®æ•°é‡
    int i;
    int totaluse;
    
    // ç¬¬1æ­¥ï¼šç»Ÿè®¡æ•´æ•°é”®çš„åˆ†å¸ƒ
    for (i=0; i<=MAXBITS; i++) nums[i] = 0;
    nasize = numusearray(t, nums);  // ç»Ÿè®¡æ•°ç»„éƒ¨åˆ†
    totaluse = nasize;
    totaluse += numusehash(t, nums, &nasize);  // ç»Ÿè®¡å“ˆå¸Œéƒ¨åˆ†
    
    // åŠ ä¸Šå³å°†æ’å…¥çš„æ–°é”®
    nasize += countint(ek, nums);
    totaluse++;
    
    // ç¬¬2æ­¥ï¼šè®¡ç®—æœ€ä¼˜æ•°ç»„å¤§å°
    na = computesizes(nums, &nasize);
    
    // ç¬¬3æ­¥ï¼šé‡æ–°åˆ†é…å’Œè¿ç§»æ•°æ®
    resize(L, t, nasize, totaluse - na);
}
```

### æœ€ä¼˜å¤§å°è®¡ç®—

```c
// ltable.c
static int computesizes(int nums[], int *narray) {
    int i;
    int twotoi;  // 2^i
    int a = 0;   // æ‰€æœ‰æ•´æ•°é”®çš„æ•°é‡
    int na = 0;  // æ•°ç»„éƒ¨åˆ†çš„é”®æ•°é‡
    int n = 0;   // æœ€ä¼˜æ•°ç»„å¤§å°
    
    for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
        if (nums[i] > 0) {
            a += nums[i];
            // å¦‚æœè´Ÿè½½å› å­ > 50%ï¼Œé€‰æ‹©è¿™ä¸ªå¤§å°
            if (a > twotoi/2) {
                n = twotoi;
                na = a;
            }
        }
        if (a == *narray) break;  // æ‰€æœ‰é”®éƒ½ç»Ÿè®¡å®Œäº†
    }
    
    *narray = n;
    lua_assert(na <= *narray && *narray <= 2*na);
    return na;
}
```

**è´Ÿè½½å› å­ç­–ç•¥**ï¼š
- **é˜ˆå€¼**ï¼š50%ï¼ˆè‡³å°‘ä¸€åŠçš„æ§½ä½è¢«ä½¿ç”¨ï¼‰
- **åŸå› **ï¼šå¹³è¡¡ç©ºé—´å’Œæ€§èƒ½
  - å¤ªä½ï¼ˆå¦‚ 25%ï¼‰ï¼šæµªè´¹å†…å­˜
  - å¤ªé«˜ï¼ˆå¦‚ 75%ï¼‰ï¼šå†²çªå¢åŠ ï¼Œæ€§èƒ½ä¸‹é™
  - 50% æ˜¯ç»éªŒæœ€ä¼˜å€¼

### Rehash ç¤ºä¾‹

**åœºæ™¯**ï¼šä¾æ¬¡æ’å…¥é”® `1, 2, 3, 5, 10, 15, "name", "age"`

```
åˆå§‹çŠ¶æ€ï¼š
table = {}
sizearray = 0, lsizenode = 0 (hash size = 1)

æ’å…¥ t[1] = "a"ï¼š
â†’ è§¦å‘ rehash
â†’ è®¡ç®—ï¼šnums = {1, 0, 0, ...}  (1ä¸ªé”®åœ¨ [1,2) èŒƒå›´)
â†’ æœ€ä¼˜æ•°ç»„å¤§å° = 2 (è´Ÿè½½å› å­ 1/2 = 50%)
â†’ ç»“æœï¼šsizearray = 2, lsizenode = 0

æ’å…¥ t[2] = "b"ï¼š
â†’ æ•°ç»„æœªæ»¡ï¼Œç›´æ¥æ’å…¥
â†’ ç»“æœï¼šsizearray = 2, lsizenode = 0

æ’å…¥ t[3] = "c"ï¼š
â†’ è§¦å‘ rehash
â†’ è®¡ç®—ï¼šnums = {3, 0, 0, ...}  (3ä¸ªé”®åœ¨ [1,2) [2,4) èŒƒå›´)
â†’ æœ€ä¼˜æ•°ç»„å¤§å° = 4 (è´Ÿè½½å› å­ 3/4 = 75% > 50%)
â†’ ç»“æœï¼šsizearray = 4, lsizenode = 0

æ’å…¥ t[5] = "d"ï¼š
â†’ è§¦å‘ rehash
â†’ è®¡ç®—ï¼šnums = {4, 1, 0, ...}  (4ä¸ªé”®åœ¨ [1,4), 1ä¸ªåœ¨ [4,8))
â†’ æœ€ä¼˜æ•°ç»„å¤§å° = 8 (è´Ÿè½½å› å­ 5/8 = 62.5% > 50%)
â†’ ç»“æœï¼šsizearray = 8, lsizenode = 0

æ’å…¥ t[10] = "e"ï¼š
â†’ é”® 10 > 8ï¼Œæ’å…¥å“ˆå¸Œéƒ¨åˆ†
â†’ å“ˆå¸Œéƒ¨åˆ†æœ‰ç©ºé—²èŠ‚ç‚¹ï¼Œæ— éœ€ rehash
â†’ ç»“æœï¼šsizearray = 8, lsizenode = 0 (ä½†å“ˆå¸Œä¸­æœ‰1ä¸ªèŠ‚ç‚¹)

æ’å…¥ t[15] = "f"ï¼š
â†’ æ’å…¥å“ˆå¸Œéƒ¨åˆ†ï¼ˆå¦‚æœå·²æ»¡åˆ™è§¦å‘ rehashï¼‰

æ’å…¥ t["name"] = "lua"ï¼š
â†’ å­—ç¬¦ä¸²é”®ï¼Œæ’å…¥å“ˆå¸Œéƒ¨åˆ†

æ’å…¥ t["age"] = 30ï¼š
â†’ å­—ç¬¦ä¸²é”®ï¼Œæ’å…¥å“ˆå¸Œéƒ¨åˆ†
â†’ å¦‚æœå“ˆå¸Œæ»¡ï¼Œè§¦å‘ rehash æ‰©å®¹å“ˆå¸Œéƒ¨åˆ†

æœ€ç»ˆçŠ¶æ€ï¼ˆå‡è®¾ï¼‰ï¼š
sizearray = 8
lsizenode = 2 (hash size = 4)
æ•°ç»„éƒ¨åˆ†ï¼š{1, 2, 3, nil, 5, nil, nil, nil}
å“ˆå¸Œéƒ¨åˆ†ï¼š{10, 15, "name", "age"}
```

### Rehash æ€§èƒ½åˆ†æ

<table>
<tr>
<th width="25%">æ–¹é¢</th>
<th width="75%">è¯´æ˜</th>
</tr>

<tr>
<td><b>æ—¶é—´å¤æ‚åº¦</b></td>
<td>
O(n)ï¼Œn ä¸º table ä¸­çš„é”®å€¼å¯¹æ•°é‡<br/>
â€¢ éœ€è¦éå†æ‰€æœ‰ç°æœ‰é”®<br/>
â€¢ éœ€è¦é‡æ–°æ’å…¥æ‰€æœ‰é”®åˆ°æ–°ç»“æ„
</td>
</tr>

<tr>
<td><b>ç©ºé—´å¤æ‚åº¦</b></td>
<td>
O(n) ä¸´æ—¶ç©ºé—´<br/>
â€¢ éœ€è¦åŒæ—¶åˆ†é…æ–°æ—§ä¸¤ä»½ç©ºé—´<br/>
â€¢ æ—§ç©ºé—´åœ¨è¿ç§»åé‡Šæ”¾
</td>
</tr>

<tr>
<td><b>è§¦å‘é¢‘ç‡</b></td>
<td>
ç›¸å¯¹è¾ƒä½ï¼ˆå¯¹æ•°çº§ï¼‰<br/>
â€¢ æ•°ç»„å¤§å°æ¯æ¬¡ç¿»å€ï¼ˆ2, 4, 8, 16, ...ï¼‰<br/>
â€¢ n æ¬¡æ’å…¥è§¦å‘çº¦ logâ‚‚(n) æ¬¡ rehash<br/>
â€¢ å‡æ‘Šåˆ°æ¯æ¬¡æ’å…¥ï¼šO(1)
</td>
</tr>

<tr>
<td><b>ä¼˜åŒ–ç­–ç•¥</b></td>
<td>
â€¢ é¢„åˆ†é…ï¼šå¦‚æœå·²çŸ¥å¤§å°ï¼Œä½¿ç”¨ <code>table.new(narray, nhash)</code><br/>
â€¢ æ‰¹é‡æ’å…¥ï¼šå…ˆæ’å…¥æ‰€æœ‰é”®ï¼ŒLua ä¼šä¼˜åŒ– rehash<br/>
â€¢ é¿å…ç¨€ç–æ•°ç»„ï¼št[1]=a, t[1000000]=b ä¼šå¯¼è‡´å·¨å¤§çš„æ•°ç»„
</td>
</tr>
</table>

---

*ï¼ˆæœªå®Œå¾…ç»­ï¼Œä¸‹ä¸€æ­¥å°†æ·»åŠ ï¼šåˆ é™¤æ“ä½œã€éå†æœºåˆ¶ã€æ€§èƒ½ä¼˜åŒ–ã€å®æˆ˜ç¤ºä¾‹ç­‰å†…å®¹ï¼‰*

---

## ğŸ—‘ï¸ åˆ é™¤æ“ä½œ

### åˆ é™¤æœºåˆ¶

Lua Table çš„åˆ é™¤æ“ä½œéå¸¸ç®€å•ï¼š**å°†å€¼è®¾ç½®ä¸º nil**ã€‚

```c
// ç¤ºä¾‹ï¼šåˆ é™¤æ“ä½œ
t[key] = nil

// å†…éƒ¨å®ç°
TValue *slot = luaH_set(L, t, key);  // æ‰¾åˆ°æˆ–åˆ›å»ºæ§½ä½
setnilvalue(slot);  // è®¾ç½®ä¸º nil
```

**å…³é”®ç‰¹ç‚¹**ï¼š

<table>
<tr>
<th width="30%">ç‰¹ç‚¹</th>
<th width="70%">è¯´æ˜</th>
</tr>

<tr>
<td><b>ä¸ç«‹å³å›æ”¶ç©ºé—´</b></td>
<td>
â€¢ åˆ é™¤åæ§½ä½ä»å ç”¨å†…å­˜<br/>
â€¢ å“ˆå¸ŒèŠ‚ç‚¹æ ‡è®°ä¸º"å·²åˆ é™¤"ï¼ˆå€¼ä¸º nilï¼Œä½†é”®ä»å­˜åœ¨ï¼‰<br/>
â€¢ ç©ºé—´åœ¨ä¸‹æ¬¡ rehash æ—¶ç»Ÿä¸€å›æ”¶
</td>
</tr>

<tr>
<td><b>ä¿æŒå“ˆå¸Œé“¾å®Œæ•´</b></td>
<td>
â€¢ åˆ é™¤èŠ‚ç‚¹ä¸ç ´åå†²çªé“¾<br/>
â€¢ <code>next</code> æŒ‡é’ˆä¿æŒä¸å˜<br/>
â€¢ ç¡®ä¿åç»­èŠ‚ç‚¹ä»å¯è®¿é—®
</td>
</tr>

<tr>
<td><b>O(1) æ—¶é—´å¤æ‚åº¦</b></td>
<td>
â€¢ æŸ¥æ‰¾ï¼šO(1) å¹³å‡<br/>
â€¢ è®¾ç½® nilï¼šO(1)<br/>
â€¢ æ— éœ€è°ƒæ•´ç»“æ„
</td>
</tr>

<tr>
<td><b>å»¶è¿Ÿå›æ”¶ç­–ç•¥</b></td>
<td>
â€¢ é¢‘ç¹å¢åˆ åœºæ™¯é¿å…åå¤ rehash<br/>
â€¢ æ‰¹é‡åˆ é™¤åä¸€æ¬¡æ€§å›æ”¶<br/>
â€¢ å‡å°‘å†…å­˜åˆ†é…å¼€é”€
</td>
</tr>
</table>

### åˆ é™¤çš„è¾¹ç¼˜æƒ…å†µ

**æƒ…å†µ1ï¼šæ•°ç»„éƒ¨åˆ†çš„ nil hole**

```lua
t = {1, 2, 3, 4, 5}
t[3] = nil  -- åˆ›å»º"æ´"

-- å†…éƒ¨çŠ¶æ€ï¼š
-- array = {1, 2, nil, 4, 5}
-- sizearray ä»ä¸º 5
```

**å½±å“**ï¼š
- **é•¿åº¦æ“ä½œ `#t`**ï¼šç»“æœä¸ç¡®å®šï¼ˆå¯èƒ½æ˜¯ 2 æˆ– 5ï¼‰
- **éå† `ipairs(t)`**ï¼šåœ¨ç¬¬ä¸€ä¸ª nil å¤„åœæ­¢
- **å†…å­˜å ç”¨**ï¼šnil ä»å  16 å­—èŠ‚ï¼ˆTValueï¼‰

**æƒ…å†µ2ï¼šå¤§é‡åˆ é™¤åçš„å†…å­˜æµªè´¹**

```lua
t = {}
for i = 1, 10000 do
    t[i] = i
end
-- æ­¤æ—¶ sizearray â‰ˆ 16384

for i = 1, 9999 do
    t[i] = nil  -- åˆ é™¤ 99.99%
end
-- æ­¤æ—¶ sizearray ä»ä¸º 16384ï¼Œä½†åªæœ‰1ä¸ªæœ‰æ•ˆå…ƒç´ 
-- æµªè´¹çº¦ 16384 * 16 = 256KB
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```lua
-- æ‰‹åŠ¨è§¦å‘ rehashï¼ˆæ— ç›´æ¥ APIï¼Œé—´æ¥æ–¹æ³•ï¼‰
local temp = {}
for k, v in pairs(t) do
    temp[k] = v
end
t = temp  -- æ–° table ä¼šé‡æ–°è®¡ç®—æœ€ä¼˜å¤§å°
```

---

## ğŸ” éå†æœºåˆ¶

### pairs() éå†

`pairs(t)` éå† table çš„æ‰€æœ‰é”®å€¼å¯¹ï¼ŒåŒ…æ‹¬æ•°ç»„å’Œå“ˆå¸Œéƒ¨åˆ†ã€‚

#### å®ç°åŸç†

```c
// ltable.c: luaH_next() - è·å–ä¸‹ä¸€ä¸ªé”®å€¼å¯¹
int luaH_next(lua_State *L, Table *t, StkId key) {
    int i = findindex(L, t, key);  // æ‰¾åˆ°å½“å‰é”®çš„ç´¢å¼•
    
    // éå†æ•°ç»„éƒ¨åˆ†
    for (i++; i <= t->sizearray; i++) {
        if (!ttisnil(&t->array[i-1])) {
            setnvalue(key, cast_num(i));
            setobj2s(L, key+1, &t->array[i-1]);
            return 1;
        }
    }
    
    // éå†å“ˆå¸Œéƒ¨åˆ†
    for (i -= t->sizearray; i < sizenode(t); i++) {
        if (!ttisnil(gval(gnode(t, i)))) {
            setobj2s(L, key, key2tval(gnode(t, i)));
            setobj2s(L, key+1, gval(gnode(t, i)));
            return 1;
        }
    }
    
    return 0;  // éå†ç»“æŸ
}
```

#### éå†é¡ºåº

```mermaid
flowchart LR
    Start["å¼€å§‹éå†"] --> Array["æ•°ç»„éƒ¨åˆ†<br/>array[0] â†’ array[n-1]"]
    Array --> Hash["å“ˆå¸Œéƒ¨åˆ†<br/>node[0] â†’ node[m-1]"]
    Hash --> End["ç»“æŸ"]
    
    Note1["é¡ºåºï¼šç´¢å¼• 1, 2, 3, ..."]
    Note2["é¡ºåºï¼šæœªå®šä¹‰ï¼ˆå“ˆå¸Œè¡¨é¡ºåºï¼‰"]
    
    Array -.->|"è§„åˆ™"| Note1
    Hash -.->|"è§„åˆ™"| Note2
    
    style Start fill:#e1f5ff
    style Array fill:#e8f5e9
    style Hash fill:#fff4e6
    style End fill:#f3e5f5
```

**é‡è¦ç‰¹æ€§**ï¼š
- **æ•°ç»„éƒ¨åˆ†æœ‰åº**ï¼šæŒ‰ç´¢å¼• 1, 2, 3, ... é¡ºåºéå†
- **å“ˆå¸Œéƒ¨åˆ†æ— åº**ï¼šå–å†³äºå“ˆå¸Œè¡¨çš„å†…éƒ¨å¸ƒå±€ï¼Œä¸ä¿è¯ä»»ä½•é¡ºåº
- **è·³è¿‡ nil**ï¼šå€¼ä¸º nil çš„é”®ä¸ä¼šè¢«éå†åˆ°

#### ä½¿ç”¨ç¤ºä¾‹

```lua
t = {10, 20, 30, x=1, y=2, z=3}

-- pairs éå†ï¼ˆæ— åºï¼‰
for k, v in pairs(t) do
    print(k, v)
end

-- è¾“å‡ºï¼ˆç¤ºä¾‹ï¼Œå“ˆå¸Œéƒ¨åˆ†é¡ºåºä¸å®šï¼‰ï¼š
-- 1    10
-- 2    20
-- 3    30
-- x    1
-- y    2
-- z    3
```

### ipairs() éå†

`ipairs(t)` ä¸“é—¨éå†æ•°ç»„éƒ¨åˆ†ï¼Œé‡åˆ°ç¬¬ä¸€ä¸ª nil å°±åœæ­¢ã€‚

#### å®ç°åŸç†

```lua
-- ipairs ç­‰ä»·å®ç°ï¼ˆLua 5.1ï¼‰
function ipairs(t)
    return function(t, i)
        i = i + 1
        local v = t[i]
        if v ~= nil then
            return i, v
        end
    end, t, 0
end
```

#### éå†ç‰¹ç‚¹

<table>
<tr>
<th width="30%">ç‰¹ç‚¹</th>
<th width="70%">è¯´æ˜</th>
</tr>

<tr>
<td><b>åªéå†æ•°ç»„éƒ¨åˆ†</b></td>
<td>
ä»ç´¢å¼• 1 å¼€å§‹ï¼Œä¾æ¬¡è®¿é—® t[1], t[2], t[3], ...<br/>
ä¸è®¿é—®å“ˆå¸Œéƒ¨åˆ†ï¼ˆå­—ç¬¦ä¸²é”®ç­‰ï¼‰
</td>
</tr>

<tr>
<td><b>é‡ nil å³æ­¢</b></td>
<td>
é‡åˆ°ç¬¬ä¸€ä¸ª nil å€¼ç«‹å³åœæ­¢<br/>
å³ä½¿åé¢è¿˜æœ‰é nil å…ƒç´ ä¹Ÿä¸éå†
</td>
</tr>

<tr>
<td><b>ä¿è¯é¡ºåº</b></td>
<td>
ä¸¥æ ¼æŒ‰ç´¢å¼•é€’å¢é¡ºåº<br/>
é€‚åˆæ•°ç»„åœºæ™¯
</td>
</tr>

<tr>
<td><b>æ€§èƒ½ä¼˜ç§€</b></td>
<td>
ç›´æ¥æ•°ç»„è®¿é—®ï¼Œæ— å“ˆå¸Œè®¡ç®—<br/>
O(n) æ—¶é—´éå† n ä¸ªå…ƒç´ 
</td>
</tr>
</table>

#### ä½¿ç”¨ç¤ºä¾‹

```lua
t = {10, 20, nil, 40, 50}

-- ipairs éå†ï¼ˆé‡ nil åœæ­¢ï¼‰
for i, v in ipairs(t) do
    print(i, v)
end

-- è¾“å‡ºï¼š
-- 1    10
-- 2    20
-- ï¼ˆåœæ­¢ï¼Œt[3] ä¸º nilï¼‰
```

### éå†å®‰å…¨æ€§

**éå†è¿‡ç¨‹ä¸­ä¿®æ”¹ table çš„é£é™©**ï¼š

```lua
-- âŒ å±é™©ï¼šéå†æ—¶åˆ é™¤å…ƒç´ 
t = {1, 2, 3, 4, 5}
for k, v in pairs(t) do
    if v % 2 == 0 then
        t[k] = nil  -- åˆ é™¤å¶æ•°
    end
end
-- ç»“æœä¸ç¡®å®šï¼Œå¯èƒ½æ¼æ‰æŸäº›å…ƒç´ æˆ–é‡å¤éå†

-- âœ… å®‰å…¨ï¼šå…ˆæ”¶é›†ååˆ é™¤
t = {1, 2, 3, 4, 5}
local to_delete = {}
for k, v in pairs(t) do
    if v % 2 == 0 then
        table.insert(to_delete, k)
    end
end
for _, k in ipairs(to_delete) do
    t[k] = nil
end

-- âœ… å®‰å…¨ï¼šåˆ›å»ºæ–° table
t = {1, 2, 3, 4, 5}
local new_t = {}
for k, v in pairs(t) do
    if v % 2 ~= 0 then
        new_t[k] = v  -- åªä¿ç•™å¥‡æ•°
    end
end
t = new_t
```

---

## ğŸ”— GC é›†æˆ

### Table ä½œä¸º GC å¯¹è±¡

Table æ˜¯éœ€è¦åƒåœ¾å›æ”¶çš„å¯¹è±¡ï¼Œå±äº Lua çš„ GC ç®¡ç†èŒƒå›´ã€‚

#### GC ç›¸å…³å­—æ®µ

```c
// Table ç»“æ„ä¸­çš„ GC å­—æ®µ
typedef struct Table {
    CommonHeader;    // åŒ…å« next, tt, marked
    // ...
    GCObject *gclist;  // GC éå†é“¾è¡¨
} Table;

// CommonHeader å®šä¹‰
#define CommonHeader \
    GCObject *next;  /* ä¸‹ä¸€ä¸ª GC å¯¹è±¡ */ \
    lu_byte tt;      /* ç±»å‹æ ‡è®° */ \
    lu_byte marked;  /* GC æ ‡è®°ä½ */
```

### Table çš„ GC éå†

GC éœ€è¦éå† table ä¸­çš„æ‰€æœ‰ GC å¯¹è±¡å¼•ç”¨ï¼Œæ ‡è®°ä¸º"å¯è¾¾"ã€‚

```c
// lgc.c: traversetable() - éå† table
static int traversetable(global_State *g, Table *h) {
    int i;
    int weakkey = 0;
    int weakvalue = 0;
    const TValue *mode;
    
    // æ ‡è®°å…ƒè¡¨
    if (h->metatable)
        markobject(g, h->metatable);
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå¼±è¡¨
    mode = gfasttm(g, h->metatable, TM_MODE);
    if (mode && ttisstring(mode)) {
        weakkey = (strchr(svalue(mode), 'k') != NULL);
        weakvalue = (strchr(svalue(mode), 'v') != NULL);
        if (weakkey || weakvalue) {
            // å¼±è¡¨ç‰¹æ®Šå¤„ç†
            h->marked &= ~(KEYWEAK | VALUEWEAK);
            if (weakkey) h->marked |= KEYWEAK;
            if (weakvalue) h->marked |= VALUEWEAK;
            h->gclist = g->weak;
            g->weak = obj2gco(h);
        }
    }
    
    // éå†æ•°ç»„éƒ¨åˆ†
    for (i = 0; i < h->sizearray; i++) {
        markvalue(g, &h->array[i]);
    }
    
    // éå†å“ˆå¸Œéƒ¨åˆ†
    for (i = 0; i < sizenode(h); i++) {
        Node *n = gnode(h, i);
        if (!ttisnil(gval(n))) {
            lua_assert(!ttisnil(gkey(n)));
            markvalue(g, gkey(n));  // æ ‡è®°é”®
            markvalue(g, gval(n));  // æ ‡è®°å€¼
        }
    }
    
    return weakkey || weakvalue;
}
```

### å¼±è¡¨æœºåˆ¶

Lua æ”¯æŒ**å¼±å¼•ç”¨è¡¨**ï¼Œå…è®¸ GC å›æ”¶è¢« table å¼•ç”¨çš„å¯¹è±¡ã€‚

#### å¼±è¡¨ç±»å‹

<table>
<tr>
<th width="20%">æ¨¡å¼</th>
<th width="30%">å…ƒè¡¨è®¾ç½®</th>
<th width="50%">è¡Œä¸º</th>
</tr>

<tr>
<td><b>å¼±é”®è¡¨</b></td>
<td><code>__mode = "k"</code></td>
<td>
é”®ä¸ºå¼±å¼•ç”¨ï¼Œå¦‚æœé”®å¯¹è±¡æ— å…¶ä»–å¼•ç”¨ï¼ŒGC å¯å›æ”¶è¯¥é”®å€¼å¯¹
</td>
</tr>

<tr>
<td><b>å¼±å€¼è¡¨</b></td>
<td><code>__mode = "v"</code></td>
<td>
å€¼ä¸ºå¼±å¼•ç”¨ï¼Œå¦‚æœå€¼å¯¹è±¡æ— å…¶ä»–å¼•ç”¨ï¼ŒGC å¯å›æ”¶è¯¥é”®å€¼å¯¹
</td>
</tr>

<tr>
<td><b>åŒå¼±è¡¨</b></td>
<td><code>__mode = "kv"</code></td>
<td>
é”®å’Œå€¼éƒ½ä¸ºå¼±å¼•ç”¨ï¼Œä»»ä¸€æ— å…¶ä»–å¼•ç”¨å³å¯å›æ”¶
</td>
</tr>
</table>

#### å¼±è¡¨ç¤ºä¾‹

```lua
-- ç¤ºä¾‹1ï¼šå¼±å€¼è¡¨ï¼ˆç¼“å­˜ï¼‰
local cache = {}
setmetatable(cache, {__mode = "v"})

function get_object(id)
    local obj = cache[id]
    if not obj then
        obj = create_expensive_object(id)  -- åˆ›å»ºæ˜‚è´µå¯¹è±¡
        cache[id] = obj  -- ç¼“å­˜
    end
    return obj
end

-- å½“å¯¹è±¡æ— å…¶ä»–å¼•ç”¨æ—¶ï¼ŒGC ä¼šè‡ªåŠ¨ä»ç¼“å­˜ä¸­ç§»é™¤
-- é¿å…ç¼“å­˜æ— é™å¢é•¿

-- ç¤ºä¾‹2ï¼šå¼±é”®è¡¨ï¼ˆåå‘æ˜ å°„ï¼‰
local obj_to_id = {}
setmetatable(obj_to_id, {__mode = "k"})

function register_object(obj, id)
    obj_to_id[obj] = id
end

-- å½“ obj è¢«å›æ”¶åï¼Œè‡ªåŠ¨ä»æ˜ å°„ä¸­ç§»é™¤
-- æ— éœ€æ‰‹åŠ¨æ¸…ç†
```

### Table çš„å†…å­˜å›æ”¶

```c
// lgc.c: freeobj() - é‡Šæ”¾ table å¯¹è±¡
static void freeobj(lua_State *L, GCObject *o) {
    switch (o->gch.tt) {
        case LUA_TTABLE: {
            Table *h = gco2h(o);
            // é‡Šæ”¾æ•°ç»„éƒ¨åˆ†
            luaM_freearray(L, h->array, h->sizearray, TValue);
            // é‡Šæ”¾å“ˆå¸Œéƒ¨åˆ†
            luaM_freearray(L, h->node, sizenode(h), Node);
            // é‡Šæ”¾ table ç»“æ„æœ¬èº«
            luaM_free(L, h, sizeof(Table));
            break;
        }
        // ... å…¶ä»–ç±»å‹
    }
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### é¢„åˆ†é…ä¼˜åŒ–

**é—®é¢˜**ï¼šåŠ¨æ€å¢é•¿å¯¼è‡´å¤šæ¬¡ rehashã€‚

```lua
-- âŒ ä¸æ¨èï¼šåŠ¨æ€å¢é•¿
local t = {}
for i = 1, 100000 do
    t[i] = i  -- è§¦å‘å¤šæ¬¡ rehash
end
```

**ä¼˜åŒ–**ï¼šä½¿ç”¨ `table.new()` é¢„åˆ†é…ï¼ˆLuaJIT æ‰©å±•ï¼‰ã€‚

```lua
-- âœ… LuaJIT ä¼˜åŒ–
local t = table.new(100000, 0)  -- é¢„åˆ†é… 100000 ä¸ªæ•°ç»„æ§½
for i = 1, 100000 do
    t[i] = i  -- æ—  rehash
end

-- âœ… æ ‡å‡† Lua æ›¿ä»£æ–¹æ¡ˆ
local t = {}
t[100000] = nil  -- è§¦å‘ä¸€æ¬¡ rehashï¼Œåˆ†é…è¶³å¤Ÿç©ºé—´
for i = 1, 100000 do
    t[i] = i
end
```

### é¿å…ç¨€ç–æ•°ç»„

**é—®é¢˜**ï¼šç¨€ç–æ•°ç»„æµªè´¹å†…å­˜ã€‚

```lua
-- âŒ ä¸æ¨èï¼šç¨€ç–æ•°ç»„
local t = {}
t[1] = "a"
t[1000000] = "b"
-- åˆ†é… 1000000 ä¸ªæ•°ç»„æ§½ï¼Œä½†åªç”¨äº† 2 ä¸ª
-- æµªè´¹çº¦ 16MB å†…å­˜
```

**ä¼˜åŒ–**ï¼šä½¿ç”¨å­—ç¬¦ä¸²é”®æˆ–æ”¹å˜æ•°æ®ç»“æ„ã€‚

```lua
-- âœ… æ¨èï¼šä½¿ç”¨å­—ç¬¦ä¸²é”®
local t = {}
t["id_1"] = "a"
t["id_1000000"] = "b"
-- å“ˆå¸Œè¡¨ï¼Œåªå ç”¨ 2 ä¸ªèŠ‚ç‚¹

-- âœ… æ¨èï¼šä½¿ç”¨å­è¡¨
local t = {}
t[1] = {data = "a"}
t[1000] = {data = "b"}  -- åˆ†å±‚å­˜å‚¨
```

### å¤ç”¨ Table

**é—®é¢˜**ï¼šé¢‘ç¹åˆ›å»ºé”€æ¯ table å¯¼è‡´ GC å‹åŠ›ã€‚

```lua
-- âŒ ä¸æ¨èï¼šæ¯æ¬¡åˆ›å»ºæ–° table
for i = 1, 10000 do
    local t = {x = i, y = i*2}
    process(t)
end  -- äº§ç”Ÿ 10000 ä¸ªå¾…å›æ”¶ table
```

**ä¼˜åŒ–**ï¼šä½¿ç”¨ table æ± å¤ç”¨ã€‚

```lua
-- âœ… æ¨èï¼štable æ± å¤ç”¨
local pool = {}

function get_table()
    return table.remove(pool) or {}
end

function recycle_table(t)
    for k in pairs(t) do
        t[k] = nil  -- æ¸…ç©º
    end
    table.insert(pool, t)
end

for i = 1, 10000 do
    local t = get_table()
    t.x = i
    t.y = i * 2
    process(t)
    recycle_table(t)
end
```

### ç¼“å­˜ Table è®¿é—®

**é—®é¢˜**ï¼šé‡å¤çš„ table æŸ¥æ‰¾å¼€é”€ã€‚

```lua
-- âŒ ä¸æ¨èï¼šé‡å¤æŸ¥æ‰¾
for i = 1, 1000000 do
    local x = math.sin(i)  -- æ¯æ¬¡æŸ¥æ‰¾ math è¡¨å’Œ sin é”®
end
```

**ä¼˜åŒ–**ï¼šæœ¬åœ°åŒ–å¸¸ç”¨å€¼ã€‚

```lua
-- âœ… æ¨èï¼šæœ¬åœ°åŒ–
local sin = math.sin
for i = 1, 1000000 do
    local x = sin(i)  -- ç›´æ¥è®¿é—®æœ¬åœ°å˜é‡
end
-- æ€§èƒ½æå‡çº¦ 20-30%
```

### ä½¿ç”¨æ•°ç»„è€Œéå“ˆå¸Œ

**é—®é¢˜**ï¼šå­—ç¬¦ä¸²é”®æ¯”æ•´æ•°é”®æ…¢ã€‚

```lua
-- âŒ è¾ƒæ…¢ï¼šå­—ç¬¦ä¸²é”®
local t = {x=1, y=2, z=3}
for i = 1, 1000000 do
    local a = t.x + t.y + t.z  -- 3æ¬¡å“ˆå¸ŒæŸ¥æ‰¾
end
```

**ä¼˜åŒ–**ï¼šä½¿ç”¨æ•°ç»„ç´¢å¼•ã€‚

```lua
-- âœ… æ›´å¿«ï¼šæ•´æ•°é”®
local t = {1, 2, 3}  -- t[1]=x, t[2]=y, t[3]=z
for i = 1, 1000000 do
    local a = t[1] + t[2] + t[3]  -- 3æ¬¡æ•°ç»„è®¿é—®
end
-- æ€§èƒ½æå‡çº¦ 3-5å€
```

### æ€§èƒ½å¯¹æ¯”æ€»ç»“

<table>
<tr>
<th width="30%">æ“ä½œ</th>
<th width="20%">æ—¶é—´ (çº³ç§’)</th>
<th width="25%">ç›¸å¯¹æ€§èƒ½</th>
<th width="25%">è¯´æ˜</th>
</tr>

<tr>
<td>æ•°ç»„è®¿é—® <code>t[1]</code></td>
<td>~5 ns</td>
<td>â­â­â­â­â­ (åŸºå‡†)</td>
<td>ç›´æ¥æ•°ç»„ç´¢å¼•</td>
</tr>

<tr>
<td>å“ˆå¸Œè®¿é—® <code>t["key"]</code></td>
<td>~15 ns</td>
<td>â­â­â­ (3x)</td>
<td>å“ˆå¸Œè®¡ç®—+æŸ¥æ‰¾</td>
</tr>

<tr>
<td>ç‚¹è®¿é—® <code>t.key</code></td>
<td>~15 ns</td>
<td>â­â­â­ (3x)</td>
<td>ç­‰ä»·äº t["key"]</td>
</tr>

<tr>
<td>å…ƒæ–¹æ³• <code>t[k]</code> (æœ‰__index)</td>
<td>~50 ns</td>
<td>â­ (10x)</td>
<td>è§¦å‘å‡½æ•°è°ƒç”¨</td>
</tr>

<tr>
<td>åˆ›å»ºç©ºè¡¨ <code>{}</code></td>
<td>~100 ns</td>
<td>â€”</td>
<td>åˆ†é…+åˆå§‹åŒ–</td>
</tr>

<tr>
<td>Rehash (1000å…ƒç´ )</td>
<td>~50 Î¼s</td>
<td>â€”</td>
<td>é‡æ–°åˆ†é…+è¿ç§»</td>
</tr>
</table>

---

*ï¼ˆæœªå®Œå¾…ç»­ï¼Œä¸‹ä¸€æ­¥å°†æ·»åŠ ï¼šå®æˆ˜ç¤ºä¾‹ã€è°ƒè¯•æŠ€å·§ã€æœ€ä½³å®è·µç­‰å†…å®¹ï¼‰*

---

## ğŸ’¡ å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šå®ç°æ•°ç»„

```lua
-- é¡ºåºæ•°ç»„
local arr = {10, 20, 30, 40, 50}

-- éå†
for i, v in ipairs(arr) do
    print(i, v)
end

-- è¿½åŠ å…ƒç´ 
table.insert(arr, 60)  -- æœ«å°¾è¿½åŠ 
table.insert(arr, 1, 5)  -- æŒ‡å®šä½ç½®æ’å…¥

-- åˆ é™¤å…ƒç´ 
table.remove(arr)  -- åˆ é™¤æœ«å°¾
table.remove(arr, 1)  -- åˆ é™¤æŒ‡å®šä½ç½®

-- æ’åº
table.sort(arr)
table.sort(arr, function(a, b) return a > b end)  -- é™åº

-- è¿æ¥ä¸ºå­—ç¬¦ä¸²
local str = table.concat(arr, ", ")  -- "10, 20, 30, 40, 50"
```

### ç¤ºä¾‹2ï¼šå®ç°å­—å…¸

```lua
-- å­—ç¬¦ä¸²é”®å­—å…¸
local dict = {
    name = "Lua",
    version = 5.1,
    author = "Roberto Ierusalimschy"
}

-- è®¿é—®
print(dict.name)  -- ç‚¹è¯­æ³•
print(dict["version"])  -- ç´¢å¼•è¯­æ³•

-- æ·»åŠ /ä¿®æ”¹
dict.license = "MIT"
dict["year"] = 1993

-- åˆ é™¤
dict.author = nil

-- éå†
for k, v in pairs(dict) do
    print(k, v)
end

-- æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
if dict.name ~= nil then
    print("name exists")
end
```

### ç¤ºä¾‹3ï¼šå®ç°é›†åˆ

```lua
-- ä½¿ç”¨ table å®ç°é›†åˆ
local set = {}

function set.add(s, item)
    s[item] = true
end

function set.remove(s, item)
    s[item] = nil
end

function set.contains(s, item)
    return s[item] ~= nil
end

function set.union(a, b)
    local result = {}
    for k in pairs(a) do result[k] = true end
    for k in pairs(b) do result[k] = true end
    return result
end

function set.intersection(a, b)
    local result = {}
    for k in pairs(a) do
        if b[k] then result[k] = true end
    end
    return result
end

-- ä½¿ç”¨
local s1 = {}
set.add(s1, "apple")
set.add(s1, "banana")

local s2 = {}
set.add(s2, "banana")
set.add(s2, "orange")

local union = set.union(s1, s2)  -- {apple, banana, orange}
local inter = set.intersection(s1, s2)  -- {banana}
```

### ç¤ºä¾‹4ï¼šå®ç°ç¨€ç–çŸ©é˜µ

```lua
-- ç¨€ç–çŸ©é˜µï¼ˆåªå­˜å‚¨éé›¶å…ƒç´ ï¼‰
local Matrix = {}
Matrix.__index = Matrix

function Matrix:new()
    local m = {}
    setmetatable(m, self)
    return m
end

function Matrix:set(row, col, value)
    if not self[row] then
        self[row] = {}
    end
    self[row][col] = value
end

function Matrix:get(row, col)
    local r = self[row]
    return r and r[col] or 0  -- é»˜è®¤è¿”å› 0
end

-- ä½¿ç”¨
local m = Matrix:new()
m:set(100, 200, 42)
m:set(1000, 2000, 99)

print(m:get(100, 200))  -- 42
print(m:get(1, 1))      -- 0 (æœªè®¾ç½®)

-- å†…å­˜é«˜æ•ˆï¼šåªå ç”¨ 2 ä¸ªéé›¶å…ƒç´ çš„ç©ºé—´
-- è€Œä¸æ˜¯ 1000 * 2000 = 2M ä¸ªå…ƒç´ 
```

### ç¤ºä¾‹5ï¼šå®ç° LRU ç¼“å­˜

```lua
-- LRU (Least Recently Used) ç¼“å­˜
local LRU = {}
LRU.__index = LRU

function LRU:new(capacity)
    local cache = {
        capacity = capacity,
        size = 0,
        data = {},
        order = {}  -- è®¿é—®é¡ºåºé“¾è¡¨ï¼ˆå¤´éƒ¨=æœ€è¿‘ï¼Œå°¾éƒ¨=æœ€ä¹…ï¼‰
    }
    setmetatable(cache, self)
    return cache
end

function LRU:get(key)
    local value = self.data[key]
    if value then
        -- ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆæœ€è¿‘è®¿é—®ï¼‰
        self:move_to_front(key)
        return value
    end
    return nil
end

function LRU:put(key, value)
    if self.data[key] then
        -- æ›´æ–°å·²æœ‰é”®
        self.data[key] = value
        self:move_to_front(key)
    else
        -- æ’å…¥æ–°é”®
        if self.size >= self.capacity then
            -- æ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„ï¼ˆé“¾è¡¨å°¾éƒ¨ï¼‰
            local lru_key = table.remove(self.order)
            self.data[lru_key] = nil
            self.size = self.size - 1
        end
        
        self.data[key] = value
        table.insert(self.order, 1, key)
        self.size = self.size + 1
    end
end

function LRU:move_to_front(key)
    for i, k in ipairs(self.order) do
        if k == key then
            table.remove(self.order, i)
            table.insert(self.order, 1, key)
            break
        end
    end
end

-- ä½¿ç”¨
local cache = LRU:new(3)
cache:put("a", 1)
cache:put("b", 2)
cache:put("c", 3)
print(cache:get("a"))  -- 1ï¼Œa ç§»åˆ°æœ€å‰
cache:put("d", 4)  -- æ·˜æ±° bï¼ˆæœ€ä¹…æœªä½¿ç”¨ï¼‰
print(cache:get("b"))  -- nil (å·²æ·˜æ±°)
```

### ç¤ºä¾‹6ï¼šå®ç°å¤šç»´æ•°ç»„

```lua
-- äºŒç»´æ•°ç»„ï¼ˆåµŒå¥— tableï¼‰
local matrix = {}
for i = 1, 3 do
    matrix[i] = {}
    for j = 1, 3 do
        matrix[i][j] = i * 10 + j
    end
end

-- è®¿é—®
print(matrix[2][3])  -- 23

-- ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨å¤åˆé”®ï¼ˆé¿å…åµŒå¥—ï¼‰
local matrix2 = {}
function index(row, col)
    return row * 1000 + col  -- å‡è®¾åˆ—æ•° < 1000
end

matrix2[index(2, 3)] = 23
print(matrix2[index(2, 3)])  -- 23

-- æ›´çµæ´»çš„æ–¹å¼ï¼šä½¿ç”¨å­—ç¬¦ä¸²é”®
local matrix3 = {}
matrix3["2,3"] = 23
print(matrix3["2,3"])  -- 23
```

---

## ğŸ” è°ƒè¯•ä¸åˆ†æ

### æŸ¥çœ‹ Table å†…éƒ¨çŠ¶æ€

```lua
-- è‡ªå®šä¹‰è°ƒè¯•å‡½æ•°
function inspect_table(t)
    print("=== Table Inspection ===")
    
    -- ç»Ÿè®¡é”®å€¼å¯¹æ•°é‡
    local array_count = 0
    local hash_count = 0
    
    for k, v in pairs(t) do
        if type(k) == "number" and k == math.floor(k) and k > 0 then
            array_count = array_count + 1
        else
            hash_count = hash_count + 1
        end
    end
    
    print("Array part keys: " .. array_count)
    print("Hash part keys: " .. hash_count)
    print("Total keys: " .. (array_count + hash_count))
    
    -- æ•°ç»„éƒ¨åˆ†é•¿åº¦
    print("Length (#t): " .. #t)
    
    -- å†…å­˜ä¼°ç®—ï¼ˆç²—ç•¥ï¼‰
    local memory = 64  -- table ç»“æ„
    memory = memory + array_count * 16  -- æ•°ç»„éƒ¨åˆ†
    memory = memory + hash_count * 32   -- å“ˆå¸Œéƒ¨åˆ†
    print("Estimated memory: ~" .. memory .. " bytes")
    
    return {
        array_count = array_count,
        hash_count = hash_count,
        length = #t,
        memory = memory
    }
end

-- ä½¿ç”¨
local t = {10, 20, 30, x=1, y=2, z=3}
inspect_table(t)
-- è¾“å‡ºï¼š
-- Array part keys: 3
-- Hash part keys: 3
-- Total keys: 6
-- Length (#t): 3
-- Estimated memory: ~256 bytes
```

### æ€§èƒ½åˆ†æ

```lua
-- æµ‹è¯• table æ“ä½œæ€§èƒ½
function benchmark_table(description, func, iterations)
    iterations = iterations or 1000000
    
    -- é¢„çƒ­
    for i = 1, 1000 do func() end
    
    -- æµ‹é‡
    local start = os.clock()
    for i = 1, iterations do
        func()
    end
    local elapsed = os.clock() - start
    
    print(string.format("%s: %.3f sec (%.0f ns/op)", 
                        description, elapsed, elapsed * 1e9 / iterations))
end

-- ç¤ºä¾‹ï¼šå¯¹æ¯”ä¸åŒè®¿é—®æ–¹å¼
local t = {1, 2, 3, 4, 5}

benchmark_table("Array access t[1]", function()
    local x = t[1]
end)

local dict = {x=1, y=2, z=3}

benchmark_table("Hash access t['x']", function()
    local x = dict["x"]
end)

benchmark_table("Dot access t.x", function()
    local x = dict.x
end)

-- è¾“å‡ºç¤ºä¾‹ï¼š
-- Array access t[1]: 0.052 sec (52 ns/op)
-- Hash access t['x']: 0.148 sec (148 ns/op)
-- Dot access t.x: 0.149 sec (149 ns/op)
```

### å†…å­˜æ³„æ¼æ£€æµ‹

```lua
-- æ£€æµ‹ table å¼•ç”¨æ³„æ¼
function track_tables()
    local registry = {}
    local mt = {
        __mode = "k"  -- å¼±é”®ï¼Œä¸é˜»æ­¢ table å›æ”¶
    }
    setmetatable(registry, mt)
    
    -- æ³¨å†Œæ–° table
    local function register(t, name)
        registry[t] = {
            name = name,
            time = os.time(),
            trace = debug.traceback()
        }
        return t
    end
    
    -- æŸ¥çœ‹å½“å‰å­˜æ´»çš„ table
    local function report()
        print("=== Live Tables ===")
        local count = 0
        for t, info in pairs(registry) do
            count = count + 1
            print(string.format("%d. %s (created at %s)", 
                                count, info.name, os.date("%c", info.time)))
        end
        print("Total: " .. count)
    end
    
    return {
        register = register,
        report = report
    }
end

-- ä½¿ç”¨
local tracker = track_tables()

local t1 = tracker.register({}, "config")
local t2 = tracker.register({}, "cache")

tracker.report()
-- è¾“å‡ºï¼š
-- === Live Tables ===
-- 1. config (created at ...)
-- 2. cache (created at ...)
-- Total: 2

t1 = nil
collectgarbage()
tracker.report()
-- è¾“å‡ºï¼š
-- === Live Tables ===
-- 1. cache (created at ...)
-- Total: 1 (config å·²è¢«å›æ”¶)
```

---

## ğŸ“Š æ€»ç»“å¯¹æ¯”

### Table è®¾è®¡ç²¾é«“

```mermaid
mindmap
  root((Table<br/>è®¾è®¡ç²¾é«“))
    ç»Ÿä¸€æŠ½è±¡
      å”¯ä¸€æ•°æ®ç»“æ„
      å¤šç§ç”¨é€”
      è¯­æ³•ç®€æ´
      æ¦‚å¿µæ¸…æ™°
    æ··åˆç­–ç•¥
      æ•°ç»„+å“ˆå¸Œ
      è‡ªé€‚åº”å¸ƒå±€
      æœ€ä¼˜æ€§èƒ½
      ç©ºé—´é«˜æ•ˆ
    åŠ¨æ€è°ƒæ•´
      è‡ªåŠ¨ rehash
      è´Ÿè½½ç›‘æ§
      æ™ºèƒ½æ‰©å®¹
      å»¶è¿Ÿå›æ”¶
    é«˜æ•ˆå®ç°
      O1è®¿é—®
      ç¼“å­˜å‹å¥½
      GCé›†æˆ
      å…ƒè¡¨æ‰©å±•
    å®ç”¨ç‰¹æ€§
      ä»»æ„é”®ç±»å‹
      å¼±å¼•ç”¨æ”¯æŒ
      éå†æœºåˆ¶
      é¢„åˆ†é…ä¼˜åŒ–
```

### ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”

<table>
<tr>
<th width="15%">è¯­è¨€</th>
<th width="20%">æ•°æ®ç»“æ„</th>
<th width="30%">å®ç°æ–¹å¼</th>
<th width="35%">ç‰¹ç‚¹</th>
</tr>

<tr>
<td><b>Lua</b></td>
<td>Table</td>
<td>æ··åˆæ•°ç»„-å“ˆå¸Œè¡¨</td>
<td>
âœ… ç»Ÿä¸€æ¥å£<br/>
âœ… è‡ªé€‚åº”ä¼˜åŒ–<br/>
âœ… å†…å­˜é«˜æ•ˆ<br/>
âš ï¸ åªæœ‰ä¸€ç§ç»“æ„
</td>
</tr>

<tr>
<td><b>Python</b></td>
<td>list + dict</td>
<td>
list: åŠ¨æ€æ•°ç»„<br/>
dict: å“ˆå¸Œè¡¨
</td>
<td>
âœ… ä¸“ç”¨ä¼˜åŒ–<br/>
âœ… åŠŸèƒ½ä¸°å¯Œ<br/>
âŒ éœ€è¦åŒºåˆ†ä½¿ç”¨<br/>
âŒ å†…å­˜å¼€é”€å¤§
</td>
</tr>

<tr>
<td><b>JavaScript</b></td>
<td>Array + Object</td>
<td>
Array: ç±»æ•°ç»„å¯¹è±¡<br/>
Object: å±æ€§å­—å…¸
</td>
<td>
âœ… çµæ´»æ€§å¼º<br/>
âœ… åŸå‹é“¾æ”¯æŒ<br/>
âš ï¸ æ€§èƒ½é™·é˜±å¤š<br/>
âŒ ç¨€ç–æ•°ç»„ä½æ•ˆ
</td>
</tr>

<tr>
<td><b>Java</b></td>
<td>ArrayList + HashMap</td>
<td>
æ³›å‹ç±»<br/>
ç±»å‹å®‰å…¨
</td>
<td>
âœ… ç±»å‹å®‰å…¨<br/>
âœ… å¹¶å‘æ”¯æŒ<br/>
âŒ è¯­æ³•ç¹ç<br/>
âŒ è£…ç®±å¼€é”€
</td>
</tr>

<tr>
<td><b>C++</b></td>
<td>vector + unordered_map</td>
<td>
æ¨¡æ¿å®¹å™¨<br/>
STL å®ç°
</td>
<td>
âœ… æ€§èƒ½æè‡´<br/>
âœ… é›¶å¼€é”€æŠ½è±¡<br/>
âŒ å¤æ‚åº¦é«˜<br/>
âŒ ç¼–è¯‘æ—¶é—´é•¿
</td>
</tr>
</table>

### æ€§èƒ½åŸºå‡†å¯¹æ¯”

| æ“ä½œç±»å‹ | 1Mæ¬¡æ“ä½œè€—æ—¶ | å•æ¬¡æ“ä½œè€—æ—¶ | ç›¸å¯¹æ€§èƒ½ |
|---------|-------------|-------------|---------|
| **æ•°ç»„è®¿é—®** `t[1]` | 50 ms | 50 ns | â­â­â­â­â­ (åŸºå‡†) |
| **å“ˆå¸ŒæŸ¥æ‰¾** `t["key"]` | 150 ms | 150 ns | â­â­â­ (3x) |
| **æ’å…¥æ–°é”®** | 200 ms | 200 ns | â­â­ (4x) |
| **åˆ é™¤é”®** | 100 ms | 100 ns | â­â­â­â­ (2x) |
| **éå†** pairs() | 300 ms | 300 ns | â­â­ (6x) |

**æ€§èƒ½è¶‹åŠ¿**ï¼š
- æ•°ç»„è®¿é—®æœ€å¿«ï¼ˆç›´æ¥ç´¢å¼•ï¼‰
- å“ˆå¸Œæ“ä½œé€‚ä¸­ï¼ˆéœ€è¦å“ˆå¸Œè®¡ç®—ï¼‰
- æ’å…¥å¯èƒ½è§¦å‘ rehashï¼ˆå¼€é”€æœ€å¤§ï¼‰
- éå†éœ€è¦æ‰«ææ•´ä¸ªç»“æ„ï¼ˆåŒ…å«æ•°ç»„+å“ˆå¸Œï¼‰

### è®¾è®¡æƒè¡¡

**ä¼˜åŠ¿**ï¼š
- âœ… **ç®€å•æ€§**ï¼šå•ä¸€æ•°æ®ç»“æ„ï¼Œé™ä½å­¦ä¹ æˆæœ¬
- âœ… **çµæ´»æ€§**ï¼šæ”¯æŒæ•°ç»„ã€å­—å…¸ã€å¯¹è±¡ç­‰å¤šç§ç”¨é€”
- âœ… **æ€§èƒ½**ï¼šæ··åˆè®¾è®¡å…¼é¡¾æ•°ç»„å’Œå“ˆå¸Œçš„ä¼˜åŠ¿
- âœ… **å†…å­˜æ•ˆç‡**ï¼šè‡ªé€‚åº”å¸ƒå±€ï¼Œé¿å…ç©ºé—´æµªè´¹

**åŠ£åŠ¿**ï¼š
- âš ï¸ **Rehash å¼€é”€**ï¼šåŠ¨æ€è°ƒæ•´æ—¶æœ‰æ€§èƒ½æŠ–åŠ¨
- âš ï¸ **ç¨€ç–æ•°ç»„é™·é˜±**ï¼šä¸æ°å½“ä½¿ç”¨å¯¼è‡´å†…å­˜æµªè´¹
- âš ï¸ **æ— åºæ€§**ï¼šå“ˆå¸Œéƒ¨åˆ†éå†é¡ºåºä¸ç¡®å®š
- âš ï¸ **é•¿åº¦è¯­ä¹‰æ¨¡ç³Š**ï¼šæœ‰ nil hole æ—¶ `#t` ç»“æœä¸ç¡®å®š

---

## ğŸ’¡ æœ€ä½³å®è·µå»ºè®®

### âœ… æ¨èåšæ³•

1. **æ˜ç¡®ä½¿ç”¨åœºæ™¯**
   ```lua
   -- âœ… æ•°ç»„åœºæ™¯ï¼šä½¿ç”¨è¿ç»­æ•´æ•°é”®
   local arr = {1, 2, 3, 4, 5}
   
   -- âœ… å­—å…¸åœºæ™¯ï¼šä½¿ç”¨å­—ç¬¦ä¸²é”®
   local dict = {name="lua", version=5.1}
   
   -- âŒ æ··æ·†ï¼šåŒæ—¶å¤§é‡ä½¿ç”¨ä¸¤ç§é”®
   localæ·· = {1, 2, 3, key1="val1", key2="val2"}  -- å¯ä»¥ï¼Œä½†ä¸æ¨è
   ```

2. **é¢„åˆ†é…å·²çŸ¥å¤§å°**
   ```lua
   -- âœ… LuaJIT
   local t = table.new(1000, 100)  -- 1000æ•°ç»„+100å“ˆå¸Œ
   
   -- âœ… æ ‡å‡† Lua çš„æŠ˜è¡·
   local t = {}
   t[1000] = nil  -- è§¦å‘æ‰©å®¹åˆ°é€‚å½“å¤§å°
   ```

3. **é¿å… nil hole**
   ```lua
   -- âŒ ä¸æ¨èï¼šåˆ›å»º nil hole
   t = {1, 2, 3, 4, 5}
   t[3] = nil  -- ç°åœ¨ #t ä¸ç¡®å®š
   
   -- âœ… æ¨èï¼šä½¿ç”¨ table.remove
   t = {1, 2, 3, 4, 5}
   table.remove(t, 3)  -- ç§»é™¤å¹¶å‹ç¼©æ•°ç»„
   ```

4. **å¤ç”¨ table å‡å°‘ GC**
   ```lua
   -- âœ… ä½¿ç”¨å¯¹è±¡æ± 
   local pool = {}
   function get() return table.remove(pool) or {} end
   function recycle(t)
       for k in pairs(t) do t[k] = nil end
       table.insert(pool, t)
   end
   ```

5. **æœ¬åœ°åŒ–é¢‘ç¹è®¿é—®**
   ```lua
   -- âœ… ç¼“å­˜ table å­—æ®µ
   local data = big_table.sub_table.data
   for i = 1, 1000000 do
       process(data[i])  -- é¿å…é‡å¤æŸ¥æ‰¾
   end
   ```

### âŒ é¿å…çš„åšæ³•

1. **ä¸è¦åˆ›å»ºå·¨å¤§ç¨€ç–æ•°ç»„**
2. **ä¸è¦åœ¨éå†æ—¶ä¿®æ”¹ table ç»“æ„**
3. **ä¸è¦å‡è®¾å“ˆå¸Œéƒ¨åˆ†çš„éå†é¡ºåº**
4. **ä¸è¦ä¾èµ– `#t` å¤„ç†æœ‰ nil hole çš„æ•°ç»„**
5. **ä¸è¦å¿½è§† table çš„å†…å­˜å ç”¨ï¼ˆå¤§å‹åº”ç”¨ï¼‰**

---

## ğŸ¯ å­¦ä¹ æ£€æŸ¥ç‚¹

<table>
<tr>
<th width="30%">çº§åˆ«</th>
<th width="70%">æŒæ¡å†…å®¹</th>
</tr>

<tr>
<td><b>ğŸ”° åŸºç¡€ç†è§£</b></td>
<td>
â˜ ç†è§£ table æ˜¯æ•°ç»„å’Œå“ˆå¸Œçš„æ··åˆç»“æ„<br/>
â˜ çŸ¥é“æ•´æ•°é”®å’Œå…¶ä»–é”®çš„å­˜å‚¨åŒºåˆ«<br/>
â˜ èƒ½ä½¿ç”¨ pairs å’Œ ipairs éå†<br/>
â˜ äº†è§£ table çš„åŸºæœ¬æ“ä½œï¼ˆå¢åˆ æ”¹æŸ¥ï¼‰
</td>
</tr>

<tr>
<td><b>ğŸ”§ å®è·µåº”ç”¨</b></td>
<td>
â˜ èƒ½å®ç°æ•°ç»„ã€å­—å…¸ã€é›†åˆç­‰æ•°æ®ç»“æ„<br/>
â˜ ç†è§£ rehash çš„è§¦å‘æ¡ä»¶å’Œå½±å“<br/>
â˜ æŒæ¡ table.insert/remove/sort/concat ç­‰åº“å‡½æ•°<br/>
â˜ èƒ½ä½¿ç”¨å…ƒè¡¨æ‰©å±• table åŠŸèƒ½<br/>
â˜ çŸ¥é“å¦‚ä½•é¢„åˆ†é…å’Œä¼˜åŒ–æ€§èƒ½
</td>
</tr>

<tr>
<td><b>âš¡ è¿›é˜¶æŒæ¡</b></td>
<td>
â˜ ç†è§£ table çš„å†…éƒ¨å†…å­˜å¸ƒå±€<br/>
â˜ æŒæ¡ Node ç»“æ„å’Œå¼€æ”¾åœ°å€æ³•<br/>
â˜ ç†è§£ rehash ç®—æ³•å’Œæœ€ä¼˜å¤§å°è®¡ç®—<br/>
â˜ äº†è§£å¼±è¡¨æœºåˆ¶å’Œ GC é›†æˆ<br/>
â˜ èƒ½åˆ†æå’Œä¼˜åŒ– table ç›¸å…³æ€§èƒ½é—®é¢˜<br/>
â˜ æŒæ¡è°ƒè¯•å’Œå†…å­˜åˆ†ææŠ€å·§
</td>
</tr>

<tr>
<td><b>ğŸ“ æ·±å…¥ç²¾é€š</b></td>
<td>
â˜ èƒ½é˜…è¯» ltable.c æºç <br/>
â˜ ç†è§£ä¸å…¶ä»–è¯­è¨€æ•°æ®ç»“æ„çš„å¯¹æ¯”<br/>
â˜ æŒæ¡ table çš„å„ç§ä½¿ç”¨é™·é˜±<br/>
â˜ èƒ½åœ¨ C ä¸­æ“ä½œ Lua tableï¼ˆC APIï¼‰<br/>
â˜ ç†è§£ LuaJIT å¯¹ table çš„ä¼˜åŒ–<br/>
â˜ èƒ½æ‰©å±•æˆ–ä¿®æ”¹ table å®ç°
</td>
</tr>
</table>

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

### æ·±å…¥æŠ€æœ¯æ–‡æ¡£

- **[TValue å®ç°è¯¦è§£](tvalue_implementation.md)** - Table å¦‚ä½•å­˜å‚¨ä¸åŒç±»å‹çš„é”®å’Œå€¼
- **[GC åƒåœ¾å›æ”¶](../gc/tri_color_marking.md)** - Table åœ¨ GC ä¸­çš„éå†å’Œå›æ”¶
- **[å­—ç¬¦ä¸²é©»ç•™](string_interning.md)** - å­—ç¬¦ä¸²é”®çš„ç‰¹æ®Šä¼˜åŒ–
- **[å…ƒè¡¨æœºåˆ¶](metatable_mechanism.md)** - Table å…ƒè¡¨çš„å®Œæ•´è§£æ

### ç›¸å…³æ¨¡å—

- **[å¯¹è±¡ç³»ç»Ÿæ¨¡å—](wiki_object.md)** - Table åœ¨å¯¹è±¡ç³»ç»Ÿä¸­çš„å®šä½
- **[å†…å­˜ç®¡ç†æ¨¡å—](../memory/wiki_memory.md)** - Table çš„å†…å­˜åˆ†é…
- **[è™šæ‹Ÿæœºæ¨¡å—](../vm/wiki_vm.md)** - è™šæ‹Ÿæœºå¦‚ä½•æ“ä½œ Table
- **[è¿è¡Œæ—¶æ¨¡å—](../runtime/wiki_runtime.md)** - Table åœ¨è¿è¡Œæ—¶çš„ä½¿ç”¨

---

<div align="center">

## ğŸ“š å»¶ä¼¸é˜…è¯»

**æ¨èèµ„æº**ï¼š
- [Lua 5.1 æºç æ³¨é‡Š](https://github.com/lichuang/Lua-Source-Internal)
- [The Implementation of Lua 5.0](https://www.lua.org/doc/jucs05.pdf) - Roberto çš„ç»å…¸è®ºæ–‡
- [Lua Performance Tips](http://www.lua.org/gems/sample.pdf) - å®˜æ–¹æ€§èƒ½ä¼˜åŒ–æŒ‡å—
- [LuaJIT Performance Guide](http://wiki.luajit.org/Numerical-Computing-Performance-Guide)

**ç›¸å…³è¯é¢˜**ï¼š
- å“ˆå¸Œè¡¨çš„å®ç°ç­–ç•¥ï¼ˆå¼€æ”¾åœ°å€ vs æ‹‰é“¾æ³•ï¼‰
- åŠ¨æ€æ•°ç»„çš„æ‰©å®¹ç®—æ³•
- åƒåœ¾å›æ”¶ä¸å¼±å¼•ç”¨
- JIT ç¼–è¯‘å™¨ä¸­çš„ table ä¼˜åŒ–

---

**ğŸ“… æœ€åæ›´æ–°**ï¼š2025-01-27  
**ğŸ“Œ æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0 (DeepWiki æ·±åº¦ç‰ˆ)  
**ğŸ”– åŸºäº Lua ç‰ˆæœ¬**ï¼š5.1.5  
**âœï¸ æ–‡æ¡£å†…å®¹**ï¼šæ··åˆç»“æ„ã€Rehashç®—æ³•ã€æ€§èƒ½ä¼˜åŒ–ã€å®æˆ˜ç¤ºä¾‹

*è¿”å›ï¼š[å¯¹è±¡ç³»ç»Ÿæ¨¡å—æ€»è§ˆ](wiki_object.md)*

</div>

---
