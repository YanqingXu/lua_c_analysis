# Lua 5.1 å†…å­˜ç®¡ç†ä¸ GC äº¤äº’æœºåˆ¶

> **DeepWiki æŠ€æœ¯æ·±åº¦æ–‡æ¡£** - æ·±å…¥å‰–æ Lua å†…å­˜åˆ†é…å™¨ä¸åƒåœ¾å›æ”¶å™¨çš„ååŒå·¥ä½œåŸç†

---

## ğŸ“‘ ç›®å½•

- [Lua 5.1 å†…å­˜ç®¡ç†ä¸ GC äº¤äº’æœºåˆ¶](#lua-51-å†…å­˜ç®¡ç†ä¸-gc-äº¤äº’æœºåˆ¶)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°ä¸æ¶æ„](#æ¦‚è¿°ä¸æ¶æ„)
    - [1.1 å†…å­˜ç®¡ç†ä¸ GC çš„å…³ç³»](#11-å†…å­˜ç®¡ç†ä¸-gc-çš„å…³ç³»)
      - [æ ¸å¿ƒå…³ç³»](#æ ¸å¿ƒå…³ç³»)
      - [å…³é”®äº¤äº’ç‚¹](#å…³é”®äº¤äº’ç‚¹)
    - [1.2 äº¤äº’æ¶æ„å›¾](#12-äº¤äº’æ¶æ„å›¾)
    - [1.3 æ ¸å¿ƒæ•°æ®ç»“æ„](#13-æ ¸å¿ƒæ•°æ®ç»“æ„)
      - [global\_State ç»“æ„](#global_state-ç»“æ„)
      - [å­—æ®µè¯¦è§£](#å­—æ®µè¯¦è§£)
    - [1.4 è®¾è®¡å“²å­¦](#14-è®¾è®¡å“²å­¦)
      - [å¢é‡å¼ vs åœæ­¢ä¸–ç•Œ](#å¢é‡å¼-vs-åœæ­¢ä¸–ç•Œ)
      - [ä¸‰è‰²æ ‡è®°ç®—æ³•](#ä¸‰è‰²æ ‡è®°ç®—æ³•)
      - [å†™å±éšœæœºåˆ¶](#å†™å±éšœæœºåˆ¶)
      - [å†…å­˜ä¸ GC çš„åé¦ˆå¾ªç¯](#å†…å­˜ä¸-gc-çš„åé¦ˆå¾ªç¯)
  - [totalbytes ä¸ GC è§¦å‘](#totalbytes-ä¸-gc-è§¦å‘)
    - [2.1 totalbytes å­—æ®µè¯¦è§£](#21-totalbytes-å­—æ®µè¯¦è§£)
      - [å®šä¹‰ä¸è¯­ä¹‰](#å®šä¹‰ä¸è¯­ä¹‰)
      - [æ›´æ–°æœºåˆ¶](#æ›´æ–°æœºåˆ¶)
      - [æ›´æ–°ç¤ºä¾‹](#æ›´æ–°ç¤ºä¾‹)
    - [2.2 GCthreshold é˜ˆå€¼æœºåˆ¶](#22-gcthreshold-é˜ˆå€¼æœºåˆ¶)
      - [é˜ˆå€¼è®¡ç®—](#é˜ˆå€¼è®¡ç®—)
      - [é˜ˆå€¼è°ƒæ•´ä»£ç ](#é˜ˆå€¼è°ƒæ•´ä»£ç )
      - [é˜ˆå€¼çš„åŠ¨æ€ç‰¹æ€§](#é˜ˆå€¼çš„åŠ¨æ€ç‰¹æ€§)
    - [2.3 å†…å­˜åˆ†é…æ—¶çš„ GC è§¦å‘](#23-å†…å­˜åˆ†é…æ—¶çš„-gc-è§¦å‘)
      - [è§¦å‘æ¡ä»¶æ£€æŸ¥](#è§¦å‘æ¡ä»¶æ£€æŸ¥)
      - [è§¦å‘æµç¨‹](#è§¦å‘æµç¨‹)
      - [å¢é‡æ­¥è¿› vs å®Œæ•´ GC](#å¢é‡æ­¥è¿›-vs-å®Œæ•´-gc)
    - [2.4 åŠ¨æ€é˜ˆå€¼è°ƒæ•´ç®—æ³•](#24-åŠ¨æ€é˜ˆå€¼è°ƒæ•´ç®—æ³•)
      - [è‡ªé€‚åº”ç­–ç•¥](#è‡ªé€‚åº”ç­–ç•¥)
      - [å®é™…è¡Œä¸ºæ¨¡æ‹Ÿ](#å®é™…è¡Œä¸ºæ¨¡æ‹Ÿ)
    - [2.5 å®æ—¶ç›‘æ§ç¤ºä¾‹](#25-å®æ—¶ç›‘æ§ç¤ºä¾‹)
      - [ç›‘æ§å·¥å…·å®ç°](#ç›‘æ§å·¥å…·å®ç°)
      - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
  - [å¢é‡ GC æ­¥è¿›æœºåˆ¶](#å¢é‡-gc-æ­¥è¿›æœºåˆ¶)
    - [3.1 å¢é‡ GC çš„å·¥ä½œåŸç†](#31-å¢é‡-gc-çš„å·¥ä½œåŸç†)
      - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
      - [GC çŠ¶æ€æœº](#gc-çŠ¶æ€æœº)
    - [3.2 luaC\_step å‡½æ•°è¯¦è§£](#32-luac_step-å‡½æ•°è¯¦è§£)
      - [å‡½æ•°ç­¾å](#å‡½æ•°ç­¾å)
      - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
      - [å…³é”®å‚æ•°](#å…³é”®å‚æ•°)
      - [singlestep å‡½æ•°](#singlestep-å‡½æ•°)
    - [3.3 GC å€ºåŠ¡æœºåˆ¶](#33-gc-å€ºåŠ¡æœºåˆ¶)
      - [å€ºåŠ¡æ¦‚å¿µ](#å€ºåŠ¡æ¦‚å¿µ)
      - [å€ºåŠ¡è®¡ç®—](#å€ºåŠ¡è®¡ç®—)
      - [å€ºåŠ¡é©±åŠ¨çš„å·¥ä½œé‡](#å€ºåŠ¡é©±åŠ¨çš„å·¥ä½œé‡)
    - [3.4 åˆ†é…é€Ÿç‡ä¸ GC å¹³è¡¡](#34-åˆ†é…é€Ÿç‡ä¸-gc-å¹³è¡¡)
      - [è‡ªåŠ¨å¹³è¡¡æœºåˆ¶](#è‡ªåŠ¨å¹³è¡¡æœºåˆ¶)
      - [å¹³è¡¡ç‚¹åˆ†æ](#å¹³è¡¡ç‚¹åˆ†æ)
      - [å¤±è¡¡æƒ…å†µ](#å¤±è¡¡æƒ…å†µ)
    - [3.5 æ­¥è¿›å¤§å°è®¡ç®—](#35-æ­¥è¿›å¤§å°è®¡ç®—)
      - [åŠ¨æ€æ­¥è¿›å¤§å°](#åŠ¨æ€æ­¥è¿›å¤§å°)
      - [ä¸åŒ gcstepmul çš„å½±å“](#ä¸åŒ-gcstepmul-çš„å½±å“)
  - [å†…å­˜å‹åŠ›ä¸‹çš„ GC è¡Œä¸º](#å†…å­˜å‹åŠ›ä¸‹çš„-gc-è¡Œä¸º)
    - [4.1 ä¸¤é˜¶æ®µé‡è¯•æœºåˆ¶](#41-ä¸¤é˜¶æ®µé‡è¯•æœºåˆ¶)
      - [æœºåˆ¶è®¾è®¡](#æœºåˆ¶è®¾è®¡)
      - [å®Œæ•´ä»£ç ](#å®Œæ•´ä»£ç )
      - [æµç¨‹å›¾](#æµç¨‹å›¾)
    - [4.2 Emergency GC è§¦å‘](#42-emergency-gc-è§¦å‘)
      - [è§¦å‘æ¡ä»¶](#è§¦å‘æ¡ä»¶)
      - [Emergency GC çš„å·¥ä½œ](#emergency-gc-çš„å·¥ä½œ)
    - [4.3 GC æš‚åœæ—¶é—´æ§åˆ¶](#43-gc-æš‚åœæ—¶é—´æ§åˆ¶)
      - [å¢é‡ GC çš„æš‚åœæ—¶é—´](#å¢é‡-gc-çš„æš‚åœæ—¶é—´)
      - [Emergency GC çš„æš‚åœæ—¶é—´](#emergency-gc-çš„æš‚åœæ—¶é—´)
      - [æ§åˆ¶ç­–ç•¥](#æ§åˆ¶ç­–ç•¥)
    - [4.4 å†…å­˜ä¸è¶³æ—¶çš„å¯¹è±¡ä¼˜å…ˆçº§](#44-å†…å­˜ä¸è¶³æ—¶çš„å¯¹è±¡ä¼˜å…ˆçº§)
      - [Lua çš„å›æ”¶é¡ºåº](#lua-çš„å›æ”¶é¡ºåº)
      - [æ‰‹åŠ¨ä¼˜å…ˆçº§æ§åˆ¶](#æ‰‹åŠ¨ä¼˜å…ˆçº§æ§åˆ¶)
    - [4.5 æé™æƒ…å†µå¤„ç†](#45-æé™æƒ…å†µå¤„ç†)
      - [åœºæ™¯ 1ï¼šåˆ†é…é€Ÿç‡è¿œè¶… GC é€Ÿç‡](#åœºæ™¯-1åˆ†é…é€Ÿç‡è¿œè¶…-gc-é€Ÿç‡)
      - [åœºæ™¯ 2ï¼šå¤§å¯¹è±¡å¯¼è‡´ç¢ç‰‡åŒ–](#åœºæ™¯-2å¤§å¯¹è±¡å¯¼è‡´ç¢ç‰‡åŒ–)
      - [åœºæ™¯ 3ï¼šFinalizer å¯¼è‡´æ­»é”](#åœºæ™¯-3finalizer-å¯¼è‡´æ­»é”)
  - [Finalizer ä¸å†…å­˜å›æ”¶](#finalizer-ä¸å†…å­˜å›æ”¶)
    - [5.1 \_\_gc å…ƒæ–¹æ³•æœºåˆ¶](#51-__gc-å…ƒæ–¹æ³•æœºåˆ¶)
      - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
      - [C å±‚å®ç°](#c-å±‚å®ç°)
      - [Finalizer æ³¨å†Œ](#finalizer-æ³¨å†Œ)
    - [5.2 Finalizer æ‰§è¡Œæ—¶æœº](#52-finalizer-æ‰§è¡Œæ—¶æœº)
      - [GC æµç¨‹ä¸­çš„ä½ç½®](#gc-æµç¨‹ä¸­çš„ä½ç½®)
      - [æ‰§è¡Œæµç¨‹](#æ‰§è¡Œæµç¨‹)
      - [æ‰§è¡Œé¡ºåº](#æ‰§è¡Œé¡ºåº)
    - [5.3 å¤æ´»å¯¹è±¡å¤„ç†](#53-å¤æ´»å¯¹è±¡å¤„ç†)
      - [å¤æ´»æœºåˆ¶](#å¤æ´»æœºåˆ¶)
      - [å®ç°ç»†èŠ‚](#å®ç°ç»†èŠ‚)
      - [å¤æ´»ç¤ºä¾‹](#å¤æ´»ç¤ºä¾‹)
    - [5.4 å¾ªç¯å¼•ç”¨ä¸ Finalizer](#54-å¾ªç¯å¼•ç”¨ä¸-finalizer)
      - [é—®é¢˜åœºæ™¯](#é—®é¢˜åœºæ™¯)
      - [å¤„ç†æœºåˆ¶](#å¤„ç†æœºåˆ¶)
      - [å¤æ‚æƒ…å†µ](#å¤æ‚æƒ…å†µ)
    - [5.5 Finalizer æ€§èƒ½å½±å“](#55-finalizer-æ€§èƒ½å½±å“)
      - [å¼€é”€åˆ†æ](#å¼€é”€åˆ†æ)
      - [ä¼˜åŒ–å»ºè®®](#ä¼˜åŒ–å»ºè®®)
  - [å¼±è¡¨ä¸å†…å­˜ç®¡ç†](#å¼±è¡¨ä¸å†…å­˜ç®¡ç†)
    - [6.1 å¼±è¡¨çš„ä¸‰ç§æ¨¡å¼](#61-å¼±è¡¨çš„ä¸‰ç§æ¨¡å¼)
      - [æ¨¡å¼å®šä¹‰](#æ¨¡å¼å®šä¹‰)
      - [è¡Œä¸ºå·®å¼‚](#è¡Œä¸ºå·®å¼‚)
    - [6.2 å¼±å¼•ç”¨çš„ GC å¤„ç†](#62-å¼±å¼•ç”¨çš„-gc-å¤„ç†)
      - [æ ‡è®°é˜¶æ®µ](#æ ‡è®°é˜¶æ®µ)
      - [æ¸…é™¤é˜¶æ®µ](#æ¸…é™¤é˜¶æ®µ)
    - [6.3 å¼±è¡¨çš„å†…å­˜ä¼˜åŒ–](#63-å¼±è¡¨çš„å†…å­˜ä¼˜åŒ–)
      - [ç¼“å­˜å®ç°](#ç¼“å­˜å®ç°)
      - [å¯¹è±¡æ± ](#å¯¹è±¡æ± )
    - [6.4 ç¼“å­˜è®¾è®¡æœ€ä½³å®è·µ](#64-ç¼“å­˜è®¾è®¡æœ€ä½³å®è·µ)
      - [ä¸¤çº§ç¼“å­˜](#ä¸¤çº§ç¼“å­˜)
      - [ç¼“å­˜ç»Ÿè®¡](#ç¼“å­˜ç»Ÿè®¡)
  - [å­—ç¬¦ä¸²å†…éƒ¨åŒ–ä¸ GC](#å­—ç¬¦ä¸²å†…éƒ¨åŒ–ä¸-gc)
    - [7.1 å­—ç¬¦ä¸²è¡¨ç»“æ„](#71-å­—ç¬¦ä¸²è¡¨ç»“æ„)
      - [æ•°æ®ç»“æ„](#æ•°æ®ç»“æ„)
      - [å†…éƒ¨åŒ–è¿‡ç¨‹](#å†…éƒ¨åŒ–è¿‡ç¨‹)
    - [7.2 å­—ç¬¦ä¸²çš„ GC æ ‡è®°](#72-å­—ç¬¦ä¸²çš„-gc-æ ‡è®°)
      - [æ ‡è®°è¿‡ç¨‹](#æ ‡è®°è¿‡ç¨‹)
    - [7.3 å­—ç¬¦ä¸²è¡¨æ‰«æ](#73-å­—ç¬¦ä¸²è¡¨æ‰«æ)
      - [æ¸…é™¤è¿‡ç¨‹](#æ¸…é™¤è¿‡ç¨‹)
      - [è¡¨æ‰©å±•](#è¡¨æ‰©å±•)
    - [7.4 å­—ç¬¦ä¸²å†…å­˜ä¼˜åŒ–](#74-å­—ç¬¦ä¸²å†…å­˜ä¼˜åŒ–)
      - [çŸ­å­—ç¬¦ä¸²ä¼˜åŒ–](#çŸ­å­—ç¬¦ä¸²ä¼˜åŒ–)
      - [é•¿å­—ç¬¦ä¸²é—®é¢˜](#é•¿å­—ç¬¦ä¸²é—®é¢˜)
  - [GC å‚æ•°è°ƒä¼˜](#gc-å‚æ•°è°ƒä¼˜)
    - [8.1 GC å‚æ•°è¯¦è§£](#81-gc-å‚æ•°è¯¦è§£)
      - [ä¸‰å¤§å‚æ•°](#ä¸‰å¤§å‚æ•°)
      - [å‚æ•°å«ä¹‰](#å‚æ•°å«ä¹‰)
    - [8.2 ä¸åŒåœºæ™¯çš„è°ƒä¼˜ç­–ç•¥](#82-ä¸åŒåœºæ™¯çš„è°ƒä¼˜ç­–ç•¥)
      - [åœºæ™¯ 1ï¼šå†…å­˜å—é™ç¯å¢ƒ](#åœºæ™¯-1å†…å­˜å—é™ç¯å¢ƒ)
      - [åœºæ™¯ 2ï¼šé«˜æ€§èƒ½åº”ç”¨](#åœºæ™¯-2é«˜æ€§èƒ½åº”ç”¨)
      - [åœºæ™¯ 3ï¼šå®æ—¶ç³»ç»Ÿ](#åœºæ™¯-3å®æ—¶ç³»ç»Ÿ)
    - [8.3 æ€§èƒ½æµ‹è¯•æ¡†æ¶](#83-æ€§èƒ½æµ‹è¯•æ¡†æ¶)
      - [å®Œæ•´æµ‹è¯•å·¥å…·](#å®Œæ•´æµ‹è¯•å·¥å…·)
    - [8.4 è‡ªé€‚åº” GC ç®—æ³•](#84-è‡ªé€‚åº”-gc-ç®—æ³•)
      - [åŠ¨æ€è°ƒæ•´ç­–ç•¥](#åŠ¨æ€è°ƒæ•´ç­–ç•¥)
      - [C å±‚è‡ªé€‚åº”å®ç°](#c-å±‚è‡ªé€‚åº”å®ç°)
  - [å®æˆ˜æ¡ˆä¾‹åˆ†æ](#å®æˆ˜æ¡ˆä¾‹åˆ†æ)
    - [9.1 é«˜é¢‘åˆ†é…ä¼˜åŒ–ï¼ˆæ¸¸æˆå¼•æ“ï¼‰](#91-é«˜é¢‘åˆ†é…ä¼˜åŒ–æ¸¸æˆå¼•æ“)
      - [é—®é¢˜åœºæ™¯](#é—®é¢˜åœºæ™¯-1)
      - [è§£å†³æ–¹æ¡ˆ 1ï¼šå¯¹è±¡æ± ](#è§£å†³æ–¹æ¡ˆ-1å¯¹è±¡æ± )
      - [è§£å†³æ–¹æ¡ˆ 2ï¼šåŸåœ°ä¿®æ”¹](#è§£å†³æ–¹æ¡ˆ-2åŸåœ°ä¿®æ”¹)
    - [9.2 å¤§å¯¹è±¡ç®¡ç†ï¼ˆæœåŠ¡å™¨ï¼‰](#92-å¤§å¯¹è±¡ç®¡ç†æœåŠ¡å™¨)
      - [é—®é¢˜åœºæ™¯](#é—®é¢˜åœºæ™¯-2)
      - [è§£å†³æ–¹æ¡ˆï¼šæµå¼å¤„ç†](#è§£å†³æ–¹æ¡ˆæµå¼å¤„ç†)
    - [9.3 å®æ—¶ç³»ç»Ÿ GC è°ƒä¼˜ï¼ˆéŸ³é¢‘å¤„ç†ï¼‰](#93-å®æ—¶ç³»ç»Ÿ-gc-è°ƒä¼˜éŸ³é¢‘å¤„ç†)
      - [é—®é¢˜åœºæ™¯](#é—®é¢˜åœºæ™¯-3)
      - [è§£å†³æ–¹æ¡ˆï¼šé¢„åˆ†é… + æ‰‹åŠ¨ GC](#è§£å†³æ–¹æ¡ˆé¢„åˆ†é…--æ‰‹åŠ¨-gc)
    - [9.4 å†…å­˜æ³„æ¼è¯Šæ–­](#94-å†…å­˜æ³„æ¼è¯Šæ–­)
      - [æ³„æ¼æ£€æµ‹å·¥å…·](#æ³„æ¼æ£€æµ‹å·¥å…·)
      - [C å±‚æ³„æ¼æ£€æµ‹](#c-å±‚æ³„æ¼æ£€æµ‹)
  - [é™„å½•](#é™„å½•)
    - [10.1 å®Œæ•´æºç å‚è€ƒ](#101-å®Œæ•´æºç å‚è€ƒ)
      - [å…³é”®æ–‡ä»¶](#å…³é”®æ–‡ä»¶)
    - [10.2 GC çŠ¶æ€æœºå®Œæ•´å›¾](#102-gc-çŠ¶æ€æœºå®Œæ•´å›¾)
    - [10.3 æ€§èƒ½åˆ†æå·¥å…·](#103-æ€§èƒ½åˆ†æå·¥å…·)
      - [GC ç›‘æ§è„šæœ¬](#gc-ç›‘æ§è„šæœ¬)
    - [10.4 å‚è€ƒèµ„æ–™](#104-å‚è€ƒèµ„æ–™)
      - [è®ºæ–‡](#è®ºæ–‡)
      - [ä¹¦ç±](#ä¹¦ç±)
      - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [10.5 å¸¸è§é—®é¢˜ (FAQ)](#105-å¸¸è§é—®é¢˜-faq)
      - [Q1: å¦‚ä½•ç¦ç”¨ GCï¼Ÿ](#q1-å¦‚ä½•ç¦ç”¨-gc)
      - [Q2: GC èƒ½å›æ”¶ C åˆ†é…çš„å†…å­˜å—ï¼Ÿ](#q2-gc-èƒ½å›æ”¶-c-åˆ†é…çš„å†…å­˜å—)
      - [Q3: ä¸ºä»€ä¹ˆ collectgarbage("collect") åå†…å­˜æ²¡å‡å°‘ï¼Ÿ](#q3-ä¸ºä»€ä¹ˆ-collectgarbagecollect-åå†…å­˜æ²¡å‡å°‘)
      - [Q4: å¦‚ä½•é€‰æ‹© gcpause å’Œ gcstepmulï¼Ÿ](#q4-å¦‚ä½•é€‰æ‹©-gcpause-å’Œ-gcstepmul)
      - [Q5: å¦‚ä½•åˆ†æ GC æ€§èƒ½ç“¶é¢ˆï¼Ÿ](#q5-å¦‚ä½•åˆ†æ-gc-æ€§èƒ½ç“¶é¢ˆ)
      - [Q6: Lua 5.1 vs 5.2+ çš„ GC åŒºåˆ«ï¼Ÿ](#q6-lua-51-vs-52-çš„-gc-åŒºåˆ«)
    - [10.6 å®Œæ•´ç¼–è¯‘ç¤ºä¾‹](#106-å®Œæ•´ç¼–è¯‘ç¤ºä¾‹)
  - [æ€»ç»“](#æ€»ç»“)
  - [å˜æ›´è®°å½•](#å˜æ›´è®°å½•)

---

## æ¦‚è¿°ä¸æ¶æ„

### 1.1 å†…å­˜ç®¡ç†ä¸ GC çš„å…³ç³»

Lua çš„å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶æ˜¯ç´§å¯†è€¦åˆçš„ä¸¤ä¸ªç³»ç»Ÿï¼Œå®ƒä»¬é€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æ¥å£ååŒå·¥ä½œã€‚

#### æ ¸å¿ƒå…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Lua åº”ç”¨ç¨‹åº                       â”‚
â”‚    (åˆ›å»ºå¯¹è±¡ã€æ‰§è¡Œä»£ç )                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å†…å­˜ç®¡ç†å±‚ (lmem.c)                  â”‚
â”‚  - luaM_realloc_: ç»Ÿä¸€åˆ†é…æ¥å£               â”‚
â”‚  - totalbytes: å®æ—¶å†…å­˜ç»Ÿè®¡                  â”‚
â”‚  - è§¦å‘ GC æ£€æŸ¥                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
        totalbytes > GCthreshold ?
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        åƒåœ¾å›æ”¶å™¨ (lgc.c)                    â”‚
â”‚  - æ ‡è®°å¯è¾¾å¯¹è±¡                              â”‚
â”‚  - æ¸…é™¤ä¸å¯è¾¾å¯¹è±¡                            â”‚
â”‚  - é‡Šæ”¾å†…å­˜                                  â”‚
â”‚  - è°ƒæ•´ GCthreshold                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         lua_Alloc (ç”¨æˆ·åˆ†é…å™¨)               â”‚
â”‚  å®é™…æ‰§è¡Œå†…å­˜åˆ†é…/é‡Šæ”¾                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å…³é”®äº¤äº’ç‚¹

**1. å†…å­˜åˆ†é…è§¦å‘ GC**
```c
/* lmem.c - luaM_realloc_ */
void *luaM_realloc_ (lua_State *L, void *block, 
                     size_t osize, size_t nsize) {
    global_State *g = G(L);
    
    /* æ›´æ–°å†…å­˜ç»Ÿè®¡ */
    g->totalbytes = (g->totalbytes - osize) + nsize;
    
    /* è°ƒç”¨åˆ†é…å™¨ */
    block = (*g->frealloc)(g->ud, block, osize, nsize);
    
    /* åˆ†é…å¤±è´¥ â†’ è§¦å‘å®Œæ•´ GC */
    if (block == NULL && nsize > 0) {
        luaC_fullgc(L);  /* Emergency GC */
        block = (*g->frealloc)(g->ud, block, osize, nsize);
        if (block == NULL)
            luaD_throw(L, LUA_ERRMEM);
    }
    
    /* æ£€æŸ¥æ˜¯å¦éœ€è¦å¢é‡ GC */
    if (g->totalbytes > g->GCthreshold) {
        luaC_step(L);  /* è§¦å‘å¢é‡æ­¥è¿› */
    }
    
    return block;
}
```

**2. GC å›æ”¶å†…å­˜**
```c
/* lgc.c - æ¸…é™¤é˜¶æ®µ */
static void freeobj (lua_State *L, GCObject *o) {
    switch (o->gch.tt) {
        case LUA_TTABLE: {
            Table *h = gco2h(o);
            luaH_free(L, h);  /* é‡Šæ”¾è¡¨ */
            break;
        }
        case LUA_TSTRING: {
            TString *ts = rawgco2ts(o);
            luaM_freemem(L, ts, sizestring(ts));  /* é‡Šæ”¾å­—ç¬¦ä¸² */
            break;
        }
        /* ... å…¶ä»–ç±»å‹ ... */
    }
}
```

**3. GC è°ƒæ•´é˜ˆå€¼**
```c
/* lgc.c - GC å®Œæˆå */
void luaC_fullgc (lua_State *L) {
    /* ... æ‰§è¡Œå®Œæ•´ GC ... */
    
    global_State *g = G(L);
    
    /* è°ƒæ•´é˜ˆå€¼ = å½“å‰ä½¿ç”¨é‡ * (1 + gcpause/100) */
    g->GCthreshold = g->totalbytes + (g->totalbytes / 100) * g->gcpause;
}
```

---

### 1.2 äº¤äº’æ¶æ„å›¾

```mermaid
sequenceDiagram
    participant App as Lua åº”ç”¨
    participant Mem as å†…å­˜ç®¡ç† (lmem.c)
    participant GC as åƒåœ¾å›æ”¶ (lgc.c)
    participant Alloc as lua_Alloc
    
    App->>Mem: åˆ›å»º Table
    Mem->>Mem: totalbytes += table_size
    Mem->>Alloc: frealloc(NULL, 0, size)
    Alloc-->>Mem: è¿”å›å†…å­˜æŒ‡é’ˆ
    
    alt totalbytes > GCthreshold
        Mem->>GC: luaC_step() è§¦å‘å¢é‡ GC
        GC->>GC: æ ‡è®°ä¸€äº›å¯¹è±¡
        GC->>GC: æ¸…é™¤ä¸€äº›åƒåœ¾
        GC->>Alloc: frealloc(ptr, size, 0) é‡Šæ”¾å†…å­˜
        GC->>Mem: æ›´æ–° totalbytes
        GC->>GC: è°ƒæ•´ GCthreshold
    end
    
    Mem-->>App: è¿”å› Table
    
    Note over App,Alloc: å¦‚æœåˆ†é…å¤±è´¥...
    
    App->>Mem: åˆ†é…å¤§å¯¹è±¡
    Mem->>Alloc: frealloc(NULL, 0, big_size)
    Alloc-->>Mem: NULL (å¤±è´¥)
    
    Mem->>GC: luaC_fullgc() Emergency GC
    GC->>GC: å®Œæ•´æ ‡è®°-æ¸…é™¤
    GC->>Alloc: é‡Šæ”¾æ‰€æœ‰åƒåœ¾
    
    Mem->>Alloc: frealloc(NULL, 0, big_size) é‡è¯•
    
    alt é‡è¯•æˆåŠŸ
        Alloc-->>Mem: è¿”å›å†…å­˜æŒ‡é’ˆ
        Mem-->>App: æˆåŠŸ
    else é‡è¯•å¤±è´¥
        Alloc-->>Mem: NULL
        Mem->>App: æŠ›å‡º LUA_ERRMEM é”™è¯¯
    end
```

---

### 1.3 æ ¸å¿ƒæ•°æ®ç»“æ„

#### global_State ç»“æ„

```c
/* lstate.h */
typedef struct global_State {
    /* å†…å­˜ç®¡ç†å­—æ®µ */
    lua_Alloc frealloc;      /* åˆ†é…å™¨å‡½æ•°æŒ‡é’ˆ */
    void *ud;                /* åˆ†é…å™¨ç”¨æˆ·æ•°æ® */
    size_t totalbytes;       /* å½“å‰æ€»å†…å­˜ä½¿ç”¨ï¼ˆå­—èŠ‚ï¼‰*/
    
    /* GC æ§åˆ¶å­—æ®µ */
    size_t GCthreshold;      /* GC è§¦å‘é˜ˆå€¼ */
    size_t estimate;         /* ä¼°è®¡çš„æ´»è·ƒå¯¹è±¡å¤§å° */
    lu_byte currentwhite;    /* å½“å‰ç™½è‰²æ ‡è®°ä½ */
    lu_byte gcstate;         /* GC çŠ¶æ€æœº */
    int sweepstrgc;          /* å­—ç¬¦ä¸²è¡¨æ‰«æä½ç½® */
    GCObject *rootgc;        /* GC å¯¹è±¡æ ¹é“¾è¡¨ */
    GCObject **sweepgc;      /* æ¸…é™¤é˜¶æ®µæ‰«ææŒ‡é’ˆ */
    GCObject *gray;          /* ç°è‰²å¯¹è±¡é“¾è¡¨ */
    GCObject *grayagain;     /* éœ€è¦å†æ¬¡æ‰«æçš„ç°è‰²å¯¹è±¡ */
    GCObject *weak;          /* å¼±è¡¨é“¾è¡¨ */
    
    /* GC å‚æ•° */
    int gcpause;             /* GC æš‚åœå‚æ•° (é»˜è®¤ 200%) */
    int gcstepmul;           /* GC æ­¥è¿›å€æ•° (é»˜è®¤ 200%) */
    
    /* GC å€ºåŠ¡ */
    int gcrunning;           /* GC è¿è¡Œæ ‡å¿— */
} global_State;
```

#### å­—æ®µè¯¦è§£

| å­—æ®µ | ç±»å‹ | è¯´æ˜ | å…¸å‹å€¼ |
|------|------|------|--------|
| `totalbytes` | `size_t` | å½“å‰æ‰€æœ‰å·²åˆ†é…å†…å­˜çš„æ€»å’Œ | åŠ¨æ€å˜åŒ– |
| `GCthreshold` | `size_t` | è§¦å‘å¢é‡ GC çš„é˜ˆå€¼ | totalbytes * 2 |
| `estimate` | `size_t` | ä¼°è®¡çš„æ´»è·ƒå¯¹è±¡å¤§å°ï¼ˆæ ‡è®°åï¼‰ | < totalbytes |
| `gcpause` | `int` | æš‚åœæ¯”ä¾‹ï¼Œé˜ˆå€¼ = estimate * (1 + pause/100) | 200 |
| `gcstepmul` | `int` | æ­¥è¿›å€æ•°ï¼Œæ¯æ¬¡ GC å·¥ä½œé‡ | 200 |
| `gcstate` | `lu_byte` | GC çŠ¶æ€ï¼š0=åœæ­¢, 1=ä¼ æ’­, 2=æ¸…é™¤, 3=ç»ˆç»“ | 0-3 |

---

### 1.4 è®¾è®¡å“²å­¦

#### å¢é‡å¼ vs åœæ­¢ä¸–ç•Œ

**Lua 5.1 é‡‡ç”¨å¢é‡å¼ GCï¼š**

```
ä¼ ç»Ÿ GC (Stop-the-World)ï¼š
  æ‰§è¡Œç¨‹åº â†’ [åœæ­¢] â†’ [å®Œæ•´ GC] â†’ [æ¢å¤] â†’ æ‰§è¡Œç¨‹åº
  ä¼˜ç‚¹ï¼šç®€å•ã€å½»åº•
  ç¼ºç‚¹ï¼šæš‚åœæ—¶é—´é•¿ï¼Œä¸å¯é¢„æµ‹

Lua å¢é‡ GC (Incremental)ï¼š
  æ‰§è¡Œç¨‹åº â†’ [å°æ­¥ GC] â†’ æ‰§è¡Œç¨‹åº â†’ [å°æ­¥ GC] â†’ ...
  ä¼˜ç‚¹ï¼šæš‚åœæ—¶é—´çŸ­ã€å¹³æ»‘
  ç¼ºç‚¹ï¼šå®ç°å¤æ‚ã€å¯èƒ½éœ€è¦å¤šæ¬¡æ‰«æ
```

#### ä¸‰è‰²æ ‡è®°ç®—æ³•

Lua ä½¿ç”¨ä¸‰è‰²æ ‡è®°æ³•è·Ÿè¸ªå¯¹è±¡ï¼š

```
ç™½è‰² (White)ï¼šæœªè®¿é—®ï¼Œå¯èƒ½æ˜¯åƒåœ¾
  - æœ‰ä¸¤ç§ç™½è‰²ï¼ˆcurrentwhite å’Œ otherwhiteï¼‰
  - ç”¨äºåŒç¼“å†²ï¼Œé¿å…é‡å¤æ ‡è®°

ç°è‰² (Gray)ï¼šå·²è®¿é—®ï¼Œä½†å­å¯¹è±¡æœªè®¿é—®
  - æ”¾åœ¨ gray é“¾è¡¨ä¸­
  - éœ€è¦è¿›ä¸€æ­¥æ‰«æ

é»‘è‰² (Black)ï¼šå·²è®¿é—®ï¼Œä¸”å­å¯¹è±¡å·²è®¿é—®
  - ç¡®å®šå­˜æ´»
  - ä¸éœ€è¦å†æ‰«æ
```

**æ ‡è®°è¿‡ç¨‹ï¼š**

```c
åˆå§‹çŠ¶æ€ï¼šæ‰€æœ‰å¯¹è±¡ç™½è‰²
         â†“
1. æ ‡è®°æ ¹å¯¹è±¡ä¸ºç°è‰²
   (å…¨å±€è¡¨ã€æ³¨å†Œè¡¨ã€æ ˆ)
         â†“
2. ä¼ æ’­é˜¶æ®µï¼š
   while (æœ‰ç°è‰²å¯¹è±¡) {
       å–å‡ºä¸€ä¸ªç°è‰²å¯¹è±¡
       æ ‡è®°å…¶æ‰€æœ‰å­å¯¹è±¡ä¸ºç°è‰²
       å°†è‡ªå·±æ ‡è®°ä¸ºé»‘è‰²
   }
         â†“
3. æ¸…é™¤é˜¶æ®µï¼š
   å›æ”¶æ‰€æœ‰ç™½è‰²å¯¹è±¡
         â†“
4. ç¿»è½¬ç™½è‰²æ ‡è®°
   (ä¸ºä¸‹ä¸€è½® GC å‡†å¤‡)
```

#### å†™å±éšœæœºåˆ¶

å¢é‡ GC çš„å…³é”®é—®é¢˜ï¼š**ç¨‹åºå¯èƒ½ä¿®æ”¹å·²æ‰«æçš„å¯¹è±¡**

```
åœºæ™¯ï¼š
1. é»‘è‰²å¯¹è±¡ A å·²æ‰«æå®Œæ¯•
2. ç¨‹åºæ‰§è¡Œï¼šA.ref = new_white_object
3. å¦‚æœä¸å¤„ç†ï¼Œnew_white_object ä¼šè¢«é”™è¯¯å›æ”¶ï¼

è§£å†³ï¼šå†™å±éšœ (Write Barrier)
```

**å†™å±éšœå®ç°ï¼š**

```c
/* lgc.h */
#define luaC_barrier(L,p,v) { \
    if (iscollectable(v) && isblack(obj2gco(p)) && iswhite(gcvalue(v))) \
        luaC_barrierf(L,obj2gco(p),gcvalue(v)); }

/* å½“é»‘è‰²å¯¹è±¡æŒ‡å‘ç™½è‰²å¯¹è±¡æ—¶è§¦å‘ */
void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
    global_State *g = G(L);
    
    /* å°†é»‘è‰²å¯¹è±¡é‡æ–°æ ‡è®°ä¸ºç°è‰² */
    lua_assert(isblack(o) && iswhite(v));
    lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
    
    /* æ”¾å›ç°è‰²é“¾è¡¨ï¼Œç¨åé‡æ–°æ‰«æ */
    black2gray(o);
    linkgclist(o, g->grayagain);
}
```

#### å†…å­˜ä¸ GC çš„åé¦ˆå¾ªç¯

```
åˆ†é…å†…å­˜ â†’ totalbytes å¢åŠ 
    â†“
totalbytes > GCthreshold
    â†“
è§¦å‘å¢é‡ GC
    â†“
é‡Šæ”¾åƒåœ¾å¯¹è±¡ â†’ totalbytes å‡å°‘
    â†“
GC å®Œæˆ â†’ è°ƒæ•´ GCthreshold
    â†“
GCthreshold = estimate * (1 + gcpause/100)
    â†“
å¯ä»¥åˆ†é…æ›´å¤šå†…å­˜...
```

**åŠ¨æ€å¹³è¡¡ï¼š**
- åˆ†é…å¿« â†’ GC é¢‘ç¹ â†’ å†…å­˜ç¨³å®š
- åˆ†é…æ…¢ â†’ GC å°‘ â†’ èŠ‚çœ CPU
- å†…å­˜ç´§å¼  â†’ Emergency GC â†’ é‡Šæ”¾ç©ºé—´

---

## totalbytes ä¸ GC è§¦å‘

### 2.1 totalbytes å­—æ®µè¯¦è§£

#### å®šä¹‰ä¸è¯­ä¹‰

```c
/* lstate.h - global_State */
size_t totalbytes;  /* å½“å‰åˆ†é…çš„æ€»å­—èŠ‚æ•° */
```

**ç²¾ç¡®å®šä¹‰ï¼š**
- åŒ…å«æ‰€æœ‰ Lua å¯¹è±¡çš„å†…å­˜
- åŒ…å«å†…éƒ¨æ•°æ®ç»“æ„ï¼ˆæ ˆã€é—­åŒ…ã€upvalue ç­‰ï¼‰
- **ä¸åŒ…æ‹¬**ï¼šC æ‰©å±•åˆ†é…çš„å†…å­˜ï¼ˆé™¤éé€šè¿‡ lua_Allocï¼‰
- **å®æ—¶æ›´æ–°**ï¼šæ¯æ¬¡ luaM_realloc_ éƒ½ä¼šæ›´æ–°

#### æ›´æ–°æœºåˆ¶

**æ ¸å¿ƒä»£ç ï¼š**
```c
/* lmem.c - luaM_realloc_ */
void *luaM_realloc_ (lua_State *L, void *block, 
                     size_t osize, size_t nsize) {
    global_State *g = G(L);
    
    /* å…³é”®ï¼šå…ˆæ›´æ–°ç»Ÿè®¡ï¼Œå†åˆ†é… */
    g->totalbytes = (g->totalbytes - osize) + nsize;
    
    block = (*g->frealloc)(g->ud, block, osize, nsize);
    
    /* ... é”™è¯¯å¤„ç† ... */
    
    return block;
}
```

**ä¸ºä»€ä¹ˆå…ˆæ›´æ–°å†åˆ†é…ï¼Ÿ**
1. **è§¦å‘ GC çš„æ—¶æœºå‡†ç¡®**ï¼šå¦‚æœå…ˆåˆ†é…ï¼Œå¯èƒ½å¯¼è‡´å®é™…å†…å­˜å·²è¶…é™ä½†æœªè§¦å‘ GC
2. **ç»Ÿè®¡ç²¾ç¡®**ï¼šå³ä½¿åˆ†é…å¤±è´¥ï¼Œtotalbytes ä¹Ÿåæ˜ äº†"å°è¯•"çš„å†…å­˜ä½¿ç”¨
3. **GC å†³ç­–ä¾æ®**ï¼šGC çœ‹åˆ°çš„æ˜¯"æœŸæœ›"çš„å†…å­˜ä½¿ç”¨ï¼Œè€Œé"å®é™…"

#### æ›´æ–°ç¤ºä¾‹

```c
/* ç¤ºä¾‹è·Ÿè¸ª */
initial: totalbytes = 1000

/* 1. åˆ†é… Table (48 å­—èŠ‚) */
luaM_realloc_(L, NULL, 0, 48)
totalbytes = 1000 - 0 + 48 = 1048

/* 2. åˆ†é… String (32 å­—èŠ‚) */
luaM_realloc_(L, NULL, 0, 32)
totalbytes = 1048 - 0 + 32 = 1080

/* 3. String æ‰©å±•åˆ° 64 å­—èŠ‚ */
luaM_realloc_(L, str_ptr, 32, 64)
totalbytes = 1080 - 32 + 64 = 1112

/* 4. é‡Šæ”¾ Table */
luaM_realloc_(L, table_ptr, 48, 0)
totalbytes = 1112 - 48 + 0 = 1064

/* 5. åˆ†é…å¤±è´¥ï¼ˆå†…å­˜ä¸è¶³ï¼‰*/
luaM_realloc_(L, NULL, 0, 10000)
totalbytes = 1064 - 0 + 10000 = 11064  /* å…ˆæ›´æ–° */
/* ç„¶ååˆ†é…å¤±è´¥ï¼Œè§¦å‘ GC */
```

---

### 2.2 GCthreshold é˜ˆå€¼æœºåˆ¶

#### é˜ˆå€¼è®¡ç®—

**åŸºæœ¬å…¬å¼ï¼š**
```c
GCthreshold = estimate * (1 + gcpause / 100)
```

**å‚æ•°è¯´æ˜ï¼š**
- `estimate`ï¼šä¸Šæ¬¡ GC åçš„æ´»è·ƒå¯¹è±¡å¤§å°
- `gcpause`ï¼šæš‚åœæ¯”ä¾‹ï¼Œé»˜è®¤ 200ï¼ˆå³ 200%ï¼‰
- ç»“æœï¼šé˜ˆå€¼æ˜¯æ´»è·ƒå¯¹è±¡çš„ 3 å€ï¼ˆ1 + 200%ï¼‰

**ç¤ºä¾‹è®¡ç®—ï¼š**
```
GC å®Œæˆåï¼š
  estimate = 100 KB (æ´»è·ƒå¯¹è±¡)
  gcpause = 200
  
è®¡ç®—é˜ˆå€¼ï¼š
  GCthreshold = 100 * (1 + 200/100)
              = 100 * 3
              = 300 KB
  
å«ä¹‰ï¼š
  å…è®¸åˆ†é… 200 KB çš„åƒåœ¾ï¼ˆ300 - 100ï¼‰
```

#### é˜ˆå€¼è°ƒæ•´ä»£ç 

```c
/* lgc.c - luaC_fullgc */
void luaC_fullgc (lua_State *L) {
    global_State *g = G(L);
    
    /* æ‰§è¡Œå®Œæ•´ GC */
    while (g->gcstate != GCSpause) {
        luaC_step(L);
    }
    
    /* è®°å½•æ´»è·ƒå¯¹è±¡å¤§å° */
    g->estimate = g->totalbytes;
    
    /* è®¡ç®—æ–°é˜ˆå€¼ */
    size_t threshold = g->estimate + (g->estimate / 100) * g->gcpause;
    
    /* è®¾ç½®é˜ˆå€¼ */
    if (threshold < g->estimate) {
        /* é˜²æ­¢æº¢å‡º */
        g->GCthreshold = MAX_LUMEM;
    } else {
        g->GCthreshold = threshold;
    }
}
```

#### é˜ˆå€¼çš„åŠ¨æ€ç‰¹æ€§

**åœºæ™¯ 1ï¼šå†…å­˜ä½¿ç”¨ç¨³å®š**
```
Cycle 1: estimate=100KB, threshold=300KB
Cycle 2: estimate=105KB, threshold=315KB (+5%)
Cycle 3: estimate=103KB, threshold=309KB
â†’ é˜ˆå€¼ç¨³å®šåœ¨ 300KB å·¦å³
```

**åœºæ™¯ 2ï¼šå†…å­˜ä½¿ç”¨å¢é•¿**
```
Cycle 1: estimate=100KB, threshold=300KB
Cycle 2: estimate=200KB, threshold=600KB (+100%)
Cycle 3: estimate=400KB, threshold=1200KB (+100%)
â†’ é˜ˆå€¼éšä½¿ç”¨é‡å¢é•¿
```

**åœºæ™¯ 3ï¼šå¤§é‡åƒåœ¾é‡Šæ”¾**
```
Before GC: totalbytes=500KB
After GC:  totalbytes=100KB (é‡Šæ”¾ 400KB åƒåœ¾)
           estimate=100KB
           threshold=300KB
â†’ é˜ˆå€¼å¤§å¹…é™ä½ï¼ŒGC æ›´é¢‘ç¹
```

---

### 2.3 å†…å­˜åˆ†é…æ—¶çš„ GC è§¦å‘

#### è§¦å‘æ¡ä»¶æ£€æŸ¥

```c
/* lmem.c - luaM_realloc_ æœ«å°¾ */
if (g->totalbytes > g->GCthreshold) {
    luaC_step(L);  /* è§¦å‘å¢é‡ GC */
}
```

**å…³é”®ç‚¹ï¼š**
- æ¯æ¬¡æˆåŠŸåˆ†é…åéƒ½ä¼šæ£€æŸ¥
- åªè¦è¶…è¿‡é˜ˆå€¼å°±è§¦å‘
- è§¦å‘çš„æ˜¯**å¢é‡æ­¥è¿›**ï¼Œä¸æ˜¯å®Œæ•´ GC

#### è§¦å‘æµç¨‹

```mermaid
graph TD
    A[åº”ç”¨ç¨‹åºè¯·æ±‚åˆ†é…] --> B[luaM_realloc_]
    B --> C[æ›´æ–° totalbytes]
    C --> D[è°ƒç”¨ lua_Alloc]
    D --> E{åˆ†é…æˆåŠŸ?}
    
    E -->|å¦| F[Emergency GC]
    F --> G[luaC_fullgc]
    G --> H[é‡è¯•åˆ†é…]
    H --> I{æˆåŠŸ?}
    I -->|å¦| J[æŠ›å‡º LUA_ERRMEM]
    I -->|æ˜¯| K[è¿”å›æŒ‡é’ˆ]
    
    E -->|æ˜¯| L{totalbytes > GCthreshold?}
    L -->|å¦| K
    L -->|æ˜¯| M[luaC_step å¢é‡GC]
    M --> K
    
    style F fill:#ffcdd2
    style J fill:#ef5350
    style M fill:#fff9c4
    style K fill:#c8e6c9
```

#### å¢é‡æ­¥è¿› vs å®Œæ•´ GC

**å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | luaC_step (å¢é‡) | luaC_fullgc (å®Œæ•´) |
|------|-----------------|-------------------|
| **è§¦å‘æ¡ä»¶** | totalbytes > GCthreshold | åˆ†é…å¤±è´¥ |
| **å·¥ä½œé‡** | å°‘é‡ï¼ˆå€ºåŠ¡é©±åŠ¨ï¼‰ | å…¨éƒ¨å®Œæˆ |
| **æš‚åœæ—¶é—´** | çŸ­ï¼ˆå¾®ç§’çº§ï¼‰ | é•¿ï¼ˆæ¯«ç§’çº§ï¼‰ |
| **é¢‘ç‡** | é«˜ï¼ˆæ¯æ¬¡åˆ†é…ï¼‰ | ä½ï¼ˆç´§æ€¥æƒ…å†µï¼‰ |
| **ç›®çš„** | å¹³æ»‘å›æ”¶ | ç´§æ€¥é‡Šæ”¾å†…å­˜ |

---

### 2.4 åŠ¨æ€é˜ˆå€¼è°ƒæ•´ç®—æ³•

#### è‡ªé€‚åº”ç­–ç•¥

Lua çš„é˜ˆå€¼ä¸æ˜¯å›ºå®šçš„ï¼Œè€Œæ˜¯æ ¹æ®ç¨‹åºè¡Œä¸ºåŠ¨æ€è°ƒæ•´ã€‚

**æ ¸å¿ƒæ€æƒ³ï¼š**
```
æ´»è·ƒå¯¹è±¡å¤š â†’ é˜ˆå€¼é«˜ â†’ å…è®¸æ›´å¤šåƒåœ¾
æ´»è·ƒå¯¹è±¡å°‘ â†’ é˜ˆå€¼ä½ â†’ GC æ›´é¢‘ç¹
```

#### å®é™…è¡Œä¸ºæ¨¡æ‹Ÿ

```c
/* æ¨¡æ‹Ÿ GC å¾ªç¯ */
#include <stdio.h>

void simulate_gc_cycle(size_t initial_bytes, int cycles) {
    size_t totalbytes = initial_bytes;
    size_t estimate = initial_bytes;
    int gcpause = 200;
    
    printf("Initial: totalbytes=%zu, estimate=%zu\n\n", 
           totalbytes, estimate);
    
    for (int i = 1; i <= cycles; i++) {
        /* è®¡ç®—é˜ˆå€¼ */
        size_t threshold = estimate + (estimate / 100) * gcpause;
        
        printf("Cycle %d:\n", i);
        printf("  Threshold: %zu bytes (%.2f MB)\n", 
               threshold, threshold / 1024.0 / 1024.0);
        
        /* æ¨¡æ‹Ÿåˆ†é…ï¼ˆå¢é•¿ 50%ï¼‰*/
        totalbytes = threshold + (threshold / 2);
        printf("  After alloc: %zu bytes\n", totalbytes);
        
        /* è§¦å‘ GCï¼Œé‡Šæ”¾ 30% åƒåœ¾ */
        size_t garbage = totalbytes * 30 / 100;
        totalbytes -= garbage;
        estimate = totalbytes;
        
        printf("  After GC: %zu bytes (freed %zu)\n", 
               totalbytes, garbage);
        printf("  New estimate: %zu\n\n", estimate);
    }
}

int main() {
    simulate_gc_cycle(1024 * 1024, 5);  /* 1MB åˆå§‹ï¼Œ5 è½® */
    return 0;
}
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```
Initial: totalbytes=1048576, estimate=1048576

Cycle 1:
  Threshold: 3145728 bytes (3.00 MB)
  After alloc: 4718592 bytes
  After GC: 3302814 bytes (freed 1415778)
  New estimate: 3302814

Cycle 2:
  Threshold: 9908442 bytes (9.45 MB)
  After alloc: 14862663 bytes
  After GC: 10403864 bytes (freed 4458799)
  New estimate: 10403864

Cycle 3:
  Threshold: 31211592 bytes (29.77 MB)
  ...
```

---

### 2.5 å®æ—¶ç›‘æ§ç¤ºä¾‹

#### ç›‘æ§å·¥å…·å®ç°

```c
#include <lua.h>
#include <lauxlib.h>
#include <time.h>

typedef struct {
    size_t totalbytes;
    size_t threshold;
    size_t estimate;
    time_t timestamp;
} GCSnapshot;

#define MAX_SNAPSHOTS 100
static GCSnapshot snapshots[MAX_SNAPSHOTS];
static int snapshot_count = 0;

/* æ•è·å½“å‰ GC çŠ¶æ€ */
void capture_gc_snapshot(lua_State *L) {
    if (snapshot_count >= MAX_SNAPSHOTS) return;
    
    global_State *g = G(L);
    GCSnapshot *snap = &snapshots[snapshot_count++];
    
    snap->totalbytes = g->totalbytes;
    snap->threshold = g->GCthreshold;
    snap->estimate = g->estimate;
    snap->timestamp = time(NULL);
}

/* Lua æ¥å£ï¼šç›‘æ§ GC */
static int l_monitor_gc(lua_State *L) {
    int interval = luaL_optinteger(L, 1, 100);  /* æ¯ 100 æ¬¡åˆ†é…é‡‡æ · */
    
    /* æ³¨å…¥ç›‘æ§é’©å­ */
    lua_sethook(L, monitor_hook, LUA_MASKCOUNT, interval);
    
    return 0;
}

/* é’©å­å‡½æ•° */
static void monitor_hook(lua_State *L, lua_Debug *ar) {
    (void)ar;
    capture_gc_snapshot(L);
}

/* ç”ŸæˆæŠ¥å‘Š */
static int l_gc_report(lua_State *L) {
    printf("\n=== GC Monitor Report ===\n\n");
    printf("Time | totalbytes | threshold | estimate | usage%%\n");
    printf("-----|------------|-----------|----------|--------\n");
    
    for (int i = 0; i < snapshot_count; i++) {
        GCSnapshot *s = &snapshots[i];
        double usage = 100.0 * s->totalbytes / s->threshold;
        
        printf("%4ld | %10zu | %9zu | %8zu | %5.1f%%\n",
               s->timestamp - snapshots[0].timestamp,
               s->totalbytes,
               s->threshold,
               s->estimate,
               usage);
    }
    
    return 0;
}

/* æ³¨å†Œå‡½æ•° */
int luaopen_gcmonitor(lua_State *L) {
    lua_newtable(L);
    
    lua_pushcfunction(L, l_monitor_gc);
    lua_setfield(L, -2, "start");
    
    lua_pushcfunction(L, l_gc_report);
    lua_setfield(L, -2, "report");
    
    return 1;
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```lua
-- test_gc_monitor.lua
local gcmonitor = require("gcmonitor")

-- å¯åŠ¨ç›‘æ§
gcmonitor.start(100)

-- æ‰§è¡Œä¸€äº›åˆ†é…å¯†é›†çš„æ“ä½œ
local data = {}
for i = 1, 10000 do
    data[i] = {
        id = i,
        name = string.format("item_%d", i),
        values = {}
    }
    
    for j = 1, 10 do
        data[i].values[j] = math.random()
    end
end

-- ç”ŸæˆæŠ¥å‘Š
gcmonitor.report()
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```
=== GC Monitor Report ===

Time | totalbytes | threshold | estimate | usage%
-----|------------|-----------|----------|--------
   0 |    1048576 |   3145728 |  1048576 |  33.3%
   1 |    2097152 |   3145728 |  1048576 |  66.7%
   2 |    3500000 |   3145728 |  1048576 | 111.3%  â† è¶…é˜ˆå€¼
   3 |    2500000 |   7500000 |  2500000 |  33.3%  â† GC å
   4 |    4000000 |   7500000 |  2500000 |  53.3%
   5 |    6000000 |   7500000 |  2500000 |  80.0%
```

---

ç»§ç»­ç¬¬ 3 ç« ï¼ˆå¢é‡ GC æ­¥è¿›æœºåˆ¶ï¼‰ï¼Ÿ

---

## å¢é‡ GC æ­¥è¿›æœºåˆ¶

### 3.1 å¢é‡ GC çš„å·¥ä½œåŸç†

#### æ ¸å¿ƒæ€æƒ³

å¢é‡ GC å°†ä¸€æ¬¡å®Œæ•´çš„åƒåœ¾å›æ”¶åˆ†è§£ä¸ºå¤šä¸ªå°æ­¥éª¤ï¼Œä¸ç¨‹åºæ‰§è¡Œäº¤æ›¿è¿›è¡Œã€‚

**å¯¹æ¯”ï¼š**
```
åœæ­¢ä¸–ç•Œ GCï¼š
  [æ‰§è¡Œ 1000ms] â†’ [GC 100ms æš‚åœ] â†’ [æ‰§è¡Œ 1000ms] â†’ ...
  
å¢é‡ GCï¼š
  [æ‰§è¡Œ 10ms] â†’ [GC 1ms] â†’ [æ‰§è¡Œ 10ms] â†’ [GC 1ms] â†’ ...
  æš‚åœæ—¶é—´ï¼š1msï¼ˆå‡å°‘ 100 å€ï¼ï¼‰
```

#### GC çŠ¶æ€æœº

Lua çš„ GC æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼ŒåŒ…å«ä»¥ä¸‹çŠ¶æ€ï¼š

```c
/* lgc.h - GC çŠ¶æ€æšä¸¾ */
#define GCSpropagate    0   /* ä¼ æ’­é˜¶æ®µï¼šæ ‡è®°å¯è¾¾å¯¹è±¡ */
#define GCSsweepstring  1   /* æ¸…é™¤å­—ç¬¦ä¸²è¡¨ */
#define GCSsweep        2   /* æ¸…é™¤å…¶ä»–å¯¹è±¡ */
#define GCSfinalize     3   /* æ‰§è¡Œ finalizer */
#define GCSpause        4   /* GC æš‚åœï¼ˆç©ºé—²çŠ¶æ€ï¼‰ */
```

**çŠ¶æ€è½¬æ¢å›¾ï¼š**

```mermaid
stateDiagram-v2
    [*] --> GCSpause: åˆå§‹çŠ¶æ€
    
    GCSpause --> GCSpropagate: å¼€å§‹æ–°ä¸€è½®GC
    
    GCSpropagate --> GCSpropagate: æ ‡è®°ä¸€äº›å¯¹è±¡
    GCSpropagate --> GCSsweepstring: æ ‡è®°å®Œæˆ
    
    GCSsweepstring --> GCSsweepstring: æ¸…é™¤ä¸€äº›å­—ç¬¦ä¸²
    GCSsweepstring --> GCSsweep: å­—ç¬¦ä¸²æ¸…é™¤å®Œæˆ
    
    GCSsweep --> GCSsweep: æ¸…é™¤ä¸€äº›å¯¹è±¡
    GCSsweep --> GCSfinalize: æ¸…é™¤å®Œæˆ
    
    GCSfinalize --> GCSfinalize: æ‰§è¡Œä¸€äº›finalizer
    GCSfinalize --> GCSpause: finalizerå®Œæˆ
    
    GCSpause --> [*]
    
    note right of GCSpropagate
        æ ‡è®°é˜¶æ®µï¼šéå†ç°è‰²å¯¹è±¡
        å°†ç™½è‰²å­å¯¹è±¡æ ‡è®°ä¸ºç°è‰²
        å°†è‡ªå·±æ ‡è®°ä¸ºé»‘è‰²
    end note
    
    note right of GCSsweep
        æ¸…é™¤é˜¶æ®µï¼šé‡Šæ”¾ç™½è‰²å¯¹è±¡
        æ›´æ–° totalbytes
    end note
```

---

### 3.2 luaC_step å‡½æ•°è¯¦è§£

#### å‡½æ•°ç­¾å

```c
/* lgc.c */
void luaC_step (lua_State *L);
```

#### å®Œæ•´å®ç°

```c
/* lgc.c - å¢é‡ GC æ­¥è¿› */
void luaC_step (lua_State *L) {
    global_State *g = G(L);
    lu_mem lim = (GCSTEPSIZE/100) * g->gcstepmul;  /* è®¡ç®—å·¥ä½œé‡ */
    
    if (lim == 0)
        lim = (MAX_LUMEM-1)/2;  /* æ— é™åˆ¶æ¨¡å¼ */
    
    /* ç´¯ç§¯å€ºåŠ¡ */
    g->GCthreshold = g->totalbytes + GCSTEPSIZE;
    
    /* æ‰§è¡Œ GC æ­¥è¿› */
    do {
        lim -= singlestep(L);  /* æ‰§è¡Œå•æ­¥ */
        
        if (g->gcstate == GCSpause) {
            /* ä¸€è½® GC å®Œæˆ */
            break;
        }
    } while (lim > 0);
    
    /* å¦‚æœæœªå®Œæˆï¼Œç»§ç»­ç´¯ç§¯å€ºåŠ¡ */
    if (g->gcstate != GCSpause)
        g->GCthreshold = g->totalbytes + GCSTEPSIZE;
    else {
        /* GC å®Œæˆï¼Œé‡æ–°è®¡ç®—é˜ˆå€¼ */
        g->GCthreshold = g->totalbytes + 
                         (g->totalbytes / 100) * g->gcpause;
    }
}
```

#### å…³é”®å‚æ•°

**GCSTEPSIZE - æ­¥è¿›åŸºç¡€å¤§å°**
```c
#define GCSTEPSIZE  1024  /* 1KB */
```

**gcstepmul - æ­¥è¿›å€æ•°**
```c
/* global_State */
int gcstepmul;  /* é»˜è®¤ 200ï¼Œå³æ¯æ¬¡ 2KB å·¥ä½œé‡ */
```

**å·¥ä½œé‡è®¡ç®—ï¼š**
```c
lu_mem lim = (GCSTEPSIZE / 100) * g->gcstepmul;
           = (1024 / 100) * 200
           = 10.24 * 200
           = 2048 å­—èŠ‚

å«ä¹‰ï¼šæ¯æ¬¡æ­¥è¿›å¤„ç†çº¦ 2KB çš„å¯¹è±¡
```

#### singlestep å‡½æ•°

```c
/* lgc.c - æ‰§è¡Œå•ä¸ª GC æ­¥éª¤ */
static lu_mem singlestep (lua_State *L) {
    global_State *g = G(L);
    
    switch (g->gcstate) {
        case GCSpropagate: {
            /* ä¼ æ’­é˜¶æ®µï¼šæ ‡è®°ä¸€ä¸ªç°è‰²å¯¹è±¡ */
            if (g->gray)
                return propagatemark(g);
            else {
                /* ä¼ æ’­å®Œæˆï¼Œè¿›å…¥æ¸…é™¤ */
                atomic(L);
                g->gcstate = GCSsweepstring;
                return 0;
            }
        }
        
        case GCSsweepstring: {
            /* æ¸…é™¤ä¸€äº›å­—ç¬¦ä¸² */
            lu_mem old = g->totalbytes;
            sweepwholelist(L, &g->strt.hash[g->sweepstrgc++]);
            
            if (g->sweepstrgc >= g->strt.size) {
                /* å­—ç¬¦ä¸²æ¸…é™¤å®Œæˆ */
                g->gcstate = GCSsweep;
            }
            
            return old - g->totalbytes;  /* è¿”å›å›æ”¶çš„å­—èŠ‚æ•° */
        }
        
        case GCSsweep: {
            /* æ¸…é™¤ä¸€äº›å¯¹è±¡ */
            lu_mem old = g->totalbytes;
            g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
            
            if (*g->sweepgc == NULL) {
                /* æ¸…é™¤å®Œæˆ */
                g->gcstate = GCSfinalize;
            }
            
            return old - g->totalbytes;
        }
        
        case GCSfinalize: {
            /* æ‰§è¡Œä¸€ä¸ª finalizer */
            if (g->tmudata) {
                GCTM(L);
                return sizeof(Udata);  /* ä¼°è®¡å€¼ */
            } else {
                /* Finalizer å®Œæˆï¼Œç»“æŸæœ¬è½® GC */
                g->gcstate = GCSpause;
                g->estimate = g->totalbytes;
                return 0;
            }
        }
        
        default: lua_assert(0); return 0;
    }
}
```

---

### 3.3 GC å€ºåŠ¡æœºåˆ¶

#### å€ºåŠ¡æ¦‚å¿µ

**å€ºåŠ¡ï¼ˆDebtï¼‰**ï¼šåˆ†é…çš„å†…å­˜è¶…è¿‡ GC å®Œæˆçš„å·¥ä½œé‡ã€‚

```
åˆ†é…é€Ÿç‡ > GC é€Ÿç‡ â†’ å€ºåŠ¡å¢åŠ  â†’ éœ€è¦æ›´å¤š GC
åˆ†é…é€Ÿç‡ < GC é€Ÿç‡ â†’ å€ºåŠ¡å‡å°‘ â†’ å‡å°‘ GC
```

#### å€ºåŠ¡è®¡ç®—

```c
/* luaC_step ä¸­ */
g->GCthreshold = g->totalbytes + GCSTEPSIZE;

/* å€ºåŠ¡ = å®é™…ä½¿ç”¨ - é˜ˆå€¼ */
debt = g->totalbytes - g->GCthreshold;

if (debt > 0) {
    /* æ¬ å€ºï¼šéœ€è¦æ›´å¤š GC */
} else {
    /* ç›ˆä½™ï¼šå¯ä»¥å°‘åš GC */
}
```

#### å€ºåŠ¡é©±åŠ¨çš„å·¥ä½œé‡

```c
/* ç®€åŒ–æ¨¡å‹ */
void luaC_step_with_debt (lua_State *L) {
    global_State *g = G(L);
    
    /* è®¡ç®—åŸºç¡€å·¥ä½œé‡ */
    lu_mem base_work = (GCSTEPSIZE / 100) * g->gcstepmul;
    
    /* æ ¹æ®å€ºåŠ¡è°ƒæ•´ */
    lu_mem debt = (g->totalbytes > g->GCthreshold) ?
                   g->totalbytes - g->GCthreshold : 0;
    
    lu_mem work = base_work + debt / 10;  /* å€ºåŠ¡çš„ 10% */
    
    /* æ‰§è¡Œ GC å·¥ä½œ */
    while (work > 0 && g->gcstate != GCSpause) {
        work -= singlestep(L);
    }
}
```

**ç¤ºä¾‹ï¼š**
```
åœºæ™¯ 1ï¼šæ­£å¸¸
  totalbytes = 1000, threshold = 1000
  debt = 0
  work = 2048 (åŸºç¡€)
  
åœºæ™¯ 2ï¼šæ¬ å€º
  totalbytes = 5000, threshold = 1000
  debt = 4000
  work = 2048 + 400 = 2448 (å¤šåš 20%)
  
åœºæ™¯ 3ï¼šä¸¥é‡æ¬ å€º
  totalbytes = 10000, threshold = 1000
  debt = 9000
  work = 2048 + 900 = 2948 (å¤šåš 44%)
```

---

### 3.4 åˆ†é…é€Ÿç‡ä¸ GC å¹³è¡¡

#### è‡ªåŠ¨å¹³è¡¡æœºåˆ¶

Lua çš„ GC é€šè¿‡åé¦ˆå¾ªç¯è‡ªåŠ¨å¹³è¡¡ï¼š

```
å¿«é€Ÿåˆ†é… â†’ totalbytes å¢é•¿å¿«
         â†“
è¶…è¿‡ GCthreshold é¢‘ç¹
         â†“
luaC_step è°ƒç”¨é¢‘ç¹
         â†“
GC å·¥ä½œé‡å¢åŠ 
         â†“
é‡Šæ”¾åƒåœ¾ â†’ totalbytes ä¸‹é™
         â†“
è¾¾åˆ°å¹³è¡¡
```

#### å¹³è¡¡ç‚¹åˆ†æ

**ç†è®ºå¹³è¡¡ç‚¹ï¼š**
```
è®¾ï¼š
  A = åˆ†é…é€Ÿç‡ (bytes/s)
  G = GC é€Ÿç‡ (bytes/s)
  L = æ´»è·ƒå¯¹è±¡å¤§å°
  
å¹³è¡¡æ¡ä»¶ï¼š
  A = G
  
å†…å­˜ä½¿ç”¨ç¨³å®šåœ¨ï¼š
  M = L * (1 + gcpause/100)
```

**ç¤ºä¾‹è®¡ç®—ï¼š**
```
å‡è®¾ï¼š
  æ´»è·ƒå¯¹è±¡ L = 10 MB
  gcpause = 200%
  
å¹³è¡¡å†…å­˜ï¼š
  M = 10 * (1 + 2) = 30 MB
  
å…è®¸åƒåœ¾ï¼š
  30 - 10 = 20 MB
```

#### å¤±è¡¡æƒ…å†µ

**1. åˆ†é…é€Ÿç‡è¿‡å¿«**
```c
/* è¡¨ç°ï¼šGC è¿½ä¸ä¸Šåˆ†é… */
totalbytes æŒç»­å¢é•¿
GC é¢‘ç¹è§¦å‘ä½†å†…å­˜ä»å¢é•¿
å¯èƒ½å¯¼è‡´ OOM

è§£å†³ï¼š
  å¢åŠ  gcstepmul (æ›´å¤š GC å·¥ä½œ)
  å‡å°‘ gcpause (æ›´æ—©è§¦å‘ GC)
```

**2. GC è¿‡åº¦**
```c
/* è¡¨ç°ï¼šGC å¤ªé¢‘ç¹ */
CPU å ç”¨é«˜
ç¨‹åºå“åº”æ…¢
å†…å­˜ä½¿ç”¨å¾ˆä½

è§£å†³ï¼š
  å‡å°‘ gcstepmul (å°‘åš GC)
  å¢åŠ  gcpause (æ™šç‚¹è§¦å‘ GC)
```

---

### 3.5 æ­¥è¿›å¤§å°è®¡ç®—

#### åŠ¨æ€æ­¥è¿›å¤§å°

```c
/* lgc.c - è®¡ç®—æ­¥è¿›å¤§å° */
#define GCSTEPSIZE  1024

lu_mem gcstep_size (global_State *g) {
    /* åŸºç¡€å¤§å° */
    lu_mem base = GCSTEPSIZE;
    
    /* æ ¹æ® gcstepmul è°ƒæ•´ */
    lu_mem size = (base / 100) * g->gcstepmul;
    
    /* æ ¹æ®å€ºåŠ¡è°ƒæ•´ */
    if (g->totalbytes > g->GCthreshold) {
        lu_mem debt = g->totalbytes - g->GCthreshold;
        size += debt / 10;  /* å€ºåŠ¡çš„ 10% */
    }
    
    return size;
}
```

#### ä¸åŒ gcstepmul çš„å½±å“

| gcstepmul | å·¥ä½œé‡ | GC é¢‘ç‡ | CPU å¼€é”€ | å†…å­˜å³°å€¼ |
|-----------|--------|---------|----------|----------|
| 50        | 512B   | ä½      | ä½       | é«˜       |
| 100       | 1KB    | ä¸­ä½    | ä¸­ä½     | ä¸­é«˜     |
| 200 (é»˜è®¤)| 2KB    | ä¸­      | ä¸­       | ä¸­       |
| 400       | 4KB    | ä¸­é«˜    | ä¸­é«˜     | ä¸­ä½     |
| 1000      | 10KB   | é«˜      | é«˜       | ä½       |

**é€‰æ‹©å»ºè®®ï¼š**
```
å†…å­˜å……è¶³ã€è¿½æ±‚æ€§èƒ½ï¼šgcstepmul = 50-100
ä¸€èˆ¬åº”ç”¨ï¼šgcstepmul = 200
å†…å­˜ç´§å¼ ï¼šgcstepmul = 400-1000
å®æ—¶ç³»ç»Ÿï¼šgcstepmul = 1000+ (å¿«é€Ÿå®Œæˆ GC)
```

---

## å†…å­˜å‹åŠ›ä¸‹çš„ GC è¡Œä¸º

### 4.1 ä¸¤é˜¶æ®µé‡è¯•æœºåˆ¶

#### æœºåˆ¶è®¾è®¡

å½“å†…å­˜åˆ†é…å¤±è´¥æ—¶ï¼ŒLua é‡‡ç”¨ä¸¤é˜¶æ®µé‡è¯•ï¼š

```
é˜¶æ®µ 1ï¼šæ­£å¸¸åˆ†é…
    â†“ å¤±è´¥
é˜¶æ®µ 2ï¼šEmergency GC + é‡è¯•
    â†“ å¤±è´¥
æŠ›å‡ºå†…å­˜é”™è¯¯
```

#### å®Œæ•´ä»£ç 

```c
/* lmem.c - luaM_realloc_ */
void *luaM_realloc_ (lua_State *L, void *block, 
                     size_t osize, size_t nsize) {
    global_State *g = G(L);
    
    /* æ›´æ–°ç»Ÿè®¡ */
    g->totalbytes = (g->totalbytes - osize) + nsize;
    
    /* é˜¶æ®µ 1ï¼šæ­£å¸¸åˆ†é… */
    block = (*g->frealloc)(g->ud, block, osize, nsize);
    
    if (block != NULL || nsize == 0) {
        /* æˆåŠŸæˆ–é‡Šæ”¾æ“ä½œ */
        goto success;
    }
    
    /* é˜¶æ®µ 2ï¼šEmergency GC */
    luaC_fullgc(L);  /* å®Œæ•´ GC */
    
    /* é‡è¯•åˆ†é… */
    block = (*g->frealloc)(g->ud, block, osize, nsize);
    
    if (block != NULL) {
        /* é‡è¯•æˆåŠŸ */
        goto success;
    }
    
    /* å½»åº•å¤±è´¥ */
    luaD_throw(L, LUA_ERRMEM);
    
success:
    /* æ£€æŸ¥æ˜¯å¦éœ€è¦å¢é‡ GC */
    if (g->totalbytes > g->GCthreshold) {
        luaC_step(L);
    }
    
    return block;
}
```

#### æµç¨‹å›¾

```mermaid
graph TD
    A[å†…å­˜åˆ†é…è¯·æ±‚] --> B[æ›´æ–° totalbytes]
    B --> C[è°ƒç”¨ lua_Alloc]
    C --> D{æˆåŠŸ?}
    
    D -->|æ˜¯| E[æ£€æŸ¥ GC é˜ˆå€¼]
    E --> F{è¶…è¿‡?}
    F -->|å¦| G[è¿”å›æŒ‡é’ˆ]
    F -->|æ˜¯| H[luaC_step å¢é‡GC]
    H --> G
    
    D -->|å¦| I[æ‰§è¡Œ Emergency GC]
    I --> J[luaC_fullgc å®Œæ•´GC]
    J --> K[é‡è¯• lua_Alloc]
    K --> L{æˆåŠŸ?}
    
    L -->|æ˜¯| M[è¿”å›æŒ‡é’ˆ]
    L -->|å¦| N[æŠ›å‡º LUA_ERRMEM]
    
    style I fill:#fff9c4
    style J fill:#ffcc80
    style N fill:#ef5350
    style G fill:#81c784
    style M fill:#81c784
```

---

### 4.2 Emergency GC è§¦å‘

#### è§¦å‘æ¡ä»¶

```c
/* åªæœ‰ä¸€ä¸ªæ¡ä»¶ï¼šåˆ†é…å¤±è´¥ */
if (block == NULL && nsize > 0) {
    luaC_fullgc(L);
}
```

**ç‰¹ç‚¹ï¼š**
- æ— æ¡ä»¶æ‰§è¡Œå®Œæ•´ GC
- ä¸ç®¡å½“å‰ GC çŠ¶æ€
- ä¸ç®¡ GC é˜ˆå€¼
- ç›®æ ‡ï¼šå°½å¯èƒ½é‡Šæ”¾å†…å­˜

#### Emergency GC çš„å·¥ä½œ

```c
/* lgc.c - luaC_fullgc */
void luaC_fullgc (lua_State *L) {
    global_State *g = G(L);
    
    /* å¦‚æœå·²åœ¨ GC ä¸­ï¼Œå®Œæˆå½“å‰è½® */
    if (g->gcstate <= GCSpropagate) {
        /* æ ‡è®°æ ¹å¯¹è±¡ */
        markroot(L);
        g->gcstate = GCSpropagate;
    }
    
    /* æ‰§è¡Œæ‰€æœ‰æ­¥éª¤ç›´åˆ°å®Œæˆ */
    while (g->gcstate != GCSpause) {
        singlestep(L);
    }
    
    /* é‡ç½®é˜ˆå€¼ */
    g->estimate = g->totalbytes;
    g->GCthreshold = g->estimate + (g->estimate / 100) * g->gcpause;
}
```

**æ‰§è¡Œå†…å®¹ï¼š**
1. æ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
2. æ¸…é™¤æ‰€æœ‰å­—ç¬¦ä¸²è¡¨
3. æ¸…é™¤æ‰€æœ‰å…¶ä»–å¯¹è±¡
4. æ‰§è¡Œæ‰€æœ‰ finalizer
5. é‡æ–°è®¡ç®—é˜ˆå€¼

**æ—¶é—´å¼€é”€ï¼š**
```
å°ç¨‹åºï¼ˆ10MBï¼‰ï¼š1-5 ms
ä¸­ç­‰ç¨‹åºï¼ˆ100MBï¼‰ï¼š10-50 ms
å¤§ç¨‹åºï¼ˆ1GBï¼‰ï¼š100-500 ms
```

---

### 4.3 GC æš‚åœæ—¶é—´æ§åˆ¶

#### å¢é‡ GC çš„æš‚åœæ—¶é—´

**å•æ¬¡ luaC_stepï¼š**
```c
/* ä¼°ç®—ï¼šå¤„ç† 2KB å¯¹è±¡ */
æ“ä½œï¼š
  - æ ‡è®° 50 ä¸ªå¯¹è±¡ï¼š50 * 10 ns = 500 ns
  - æ¸…é™¤ 10 ä¸ªå¯¹è±¡ï¼š10 * 100 ns = 1000 ns
  - æ€»è®¡ï¼šçº¦ 1500 ns = 1.5 å¾®ç§’

å®é™…æµ‹è¯•ï¼š
  - æœ€å°ï¼š500 ns
  - å…¸å‹ï¼š1-5 å¾®ç§’
  - æœ€å¤§ï¼š10-50 å¾®ç§’ (å¤§å¯¹è±¡)
```

#### Emergency GC çš„æš‚åœæ—¶é—´

```c
/* æµ‹è¯•ä»£ç  */
#include <lua.h>
#include <time.h>

void test_emergency_gc() {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);
    
    /* åˆ›å»ºå¤§é‡å¯¹è±¡ */
    luaL_dostring(L,
        "local t = {}\n"
        "for i = 1, 100000 do\n"
        "    t[i] = {data = string.rep('x', 100)}\n"
        "end\n"
    );
    
    /* æµ‹é‡ Emergency GC */
    clock_t start = clock();
    luaC_fullgc(L);
    clock_t end = clock();
    
    double ms = (double)(end - start) * 1000 / CLOCKS_PER_SEC;
    printf("Emergency GC: %.2f ms\n", ms);
    
    lua_close(L);
}
```

**ç»“æœï¼š**
```
å¯¹è±¡æ•°é‡ | å†…å­˜ä½¿ç”¨ | Emergency GC æ—¶é—´
---------|----------|------------------
1,000    | 100 KB   | 0.1 ms
10,000   | 1 MB     | 1.5 ms
100,000  | 10 MB    | 15 ms
1,000,000| 100 MB   | 150 ms
```

#### æ§åˆ¶ç­–ç•¥

**1. é¿å… Emergency GC**
```lua
-- ä¸»åŠ¨è§¦å‘ GCï¼Œé¿å…è¢«åŠ¨è§¦å‘
if collectgarbage("count") > 50000 then
    collectgarbage("collect")
end
```

**2. é™åˆ¶å•æ¬¡åˆ†é…å¤§å°**
```c
/* å¤§å¯¹è±¡åˆ†å¤šæ¬¡åˆ†é… */
#define MAX_ALLOC_SIZE (1024 * 1024)  /* 1MB */

void *safe_alloc(lua_State *L, size_t size) {
    if (size > MAX_ALLOC_SIZE) {
        /* åˆ†å—åˆ†é… */
        return chunk_alloc(L, size);
    } else {
        return luaM_malloc(L, size);
    }
}
```

**3. è°ƒæ•´ gcpause**
```lua
-- é™ä½æš‚åœæ¯”ä¾‹ï¼Œæ›´é¢‘ç¹ä½†æ¸©å’Œçš„ GC
collectgarbage("setpause", 100)  -- 100% (é»˜è®¤ 200%)
```

---

### 4.4 å†…å­˜ä¸è¶³æ—¶çš„å¯¹è±¡ä¼˜å…ˆçº§

#### Lua çš„å›æ”¶é¡ºåº

```c
/* lgc.c - æ¸…é™¤é˜¶æ®µ */
å›æ”¶é¡ºåºï¼š
1. å­—ç¬¦ä¸²ï¼ˆsweepwholelistï¼‰
2. Upvalueï¼ˆsweeplistï¼‰
3. è¡¨ï¼ˆsweeplistï¼‰
4. å‡½æ•°/é—­åŒ…ï¼ˆsweeplistï¼‰
5. Userdataï¼ˆsweeplistï¼Œæ‰§è¡Œ __gcï¼‰
6. çº¿ç¨‹ï¼ˆsweeplistï¼‰
```

**åŸå› ï¼š**
- å­—ç¬¦ä¸²æœ€å¤šã€æœ€ç¢ç‰‡åŒ–
- Upvalue å°ã€æ˜“å›æ”¶
- è¡¨å’Œå‡½æ•°æ˜¯ä¸»è¦å¯¹è±¡
- Userdata å¯èƒ½æœ‰ finalizerï¼Œæœ€åå¤„ç†

#### æ‰‹åŠ¨ä¼˜å…ˆçº§æ§åˆ¶

```lua
-- ä½¿ç”¨å¼±è¡¨å®ç°ç¼“å­˜ä¼˜å…ˆçº§
local cache = {
    high = {},   -- å¼ºå¼•ç”¨ï¼Œä¸ä¼šè¢«å›æ”¶
    medium = setmetatable({}, {__mode = "v"}),  -- å¼±å¼•ç”¨
    low = setmetatable({}, {__mode = "kv"})     -- å…¨å¼±å¼•ç”¨
}

function cache_set(key, value, priority)
    if priority == "high" then
        cache.high[key] = value
    elseif priority == "medium" then
        cache.medium[key] = value
    else
        cache.low[key] = value
    end
end
```

---

### 4.5 æé™æƒ…å†µå¤„ç†

#### åœºæ™¯ 1ï¼šåˆ†é…é€Ÿç‡è¿œè¶… GC é€Ÿç‡

**è¡¨ç°ï¼š**
```
totalbytes æŒç»­å¢é•¿
GC é¢‘ç¹ä½†æ— æ•ˆ
æœ€ç»ˆ OOM
```

**è¯Šæ–­ï¼š**
```lua
-- ç›‘æ§åˆ†é…é€Ÿç‡
local last_mem = collectgarbage("count")
local last_time = os.clock()

function check_alloc_rate()
    local current_mem = collectgarbage("count")
    local current_time = os.clock()
    
    local rate = (current_mem - last_mem) / (current_time - last_time)
    print(string.format("Alloc rate: %.2f KB/s", rate))
    
    last_mem = current_mem
    last_time = current_time
end
```

**è§£å†³ï¼š**
```c
/* å¢åŠ  gcstepmul */
lua_gc(L, LUA_GCSETSTEPMUL, 1000);  /* 5 å€å·¥ä½œé‡ */

/* æˆ–å‡å°‘ gcpause */
lua_gc(L, LUA_GCSETPAUSE, 100);  /* æ›´æ—©è§¦å‘ */
```

#### åœºæ™¯ 2ï¼šå¤§å¯¹è±¡å¯¼è‡´ç¢ç‰‡åŒ–

**é—®é¢˜ï¼š**
```
åˆ†é… 10MB å¯¹è±¡
å¤±è´¥ï¼ˆè™½ç„¶æ€»ç©ºé—² > 10MBï¼‰
åŸå› ï¼šç¢ç‰‡åŒ–ï¼Œæ²¡æœ‰è¿ç»­ 10MB
```

**è§£å†³ï¼š**
```c
/* 1. ä½¿ç”¨å†…å­˜æ±  */
typedef struct LargeObjectPool {
    void *blocks[100];
    size_t block_size;
} LargeObjectPool;

/* 2. å‹ç¼©å†…å­˜ï¼ˆéœ€è¦ç§»åŠ¨å¯¹è±¡ï¼‰*/
void compact_memory(lua_State *L) {
    /* Lua ä¸æ”¯æŒï¼Œéœ€è¦è‡ªå®šä¹‰åˆ†é…å™¨ */
}

/* 3. é¢„åˆ†é… */
void *preallocate_large(lua_State *L, size_t size) {
    /* å¯åŠ¨æ—¶é¢„åˆ†é…ï¼Œé¿å…è¿è¡Œæ—¶åˆ†é… */
}
```

#### åœºæ™¯ 3ï¼šFinalizer å¯¼è‡´æ­»é”

**é—®é¢˜ï¼š**
```lua
local obj = setmetatable({}, {
    __gc = function(self)
        -- é”™è¯¯ï¼šåœ¨ finalizer ä¸­åˆ†é…å¤§é‡å†…å­˜
        local huge = {}
        for i = 1, 1000000 do
            huge[i] = {data = i}
        end
    end
})
```

**è§£å†³ï¼š**
```lua
-- æ­£ç¡®ï¼šFinalizer ä¸­åªåšæ¸…ç†
local obj = setmetatable({}, {
    __gc = function(self)
        -- é‡Šæ”¾ C èµ„æº
        if self.handle then
            close_handle(self.handle)
        end
    end
})
```

---

ç»§ç»­ç¬¬ 5 ç« ï¼ˆFinalizer ä¸å†…å­˜å›æ”¶ï¼‰å’Œåç»­ç« èŠ‚ï¼Ÿ

---

## Finalizer ä¸å†…å­˜å›æ”¶

### 5.1 __gc å…ƒæ–¹æ³•æœºåˆ¶

#### åŸºæœ¬æ¦‚å¿µ

Finalizerï¼ˆç»ˆç»“å™¨ï¼‰æ˜¯å¯¹è±¡è¢«å›æ”¶å‰æ‰§è¡Œçš„æ¸…ç†å‡½æ•°ã€‚

```lua
local obj = setmetatable({}, {
    __gc = function(self)
        print("å¯¹è±¡è¢«å›æ”¶:", self)
    end
})

obj = nil
collectgarbage("collect")
-- è¾“å‡º: å¯¹è±¡è¢«å›æ”¶: table: 0x...
```

#### C å±‚å®ç°

```c
/* lgc.c - æ£€æŸ¥å¯¹è±¡æ˜¯å¦æœ‰ finalizer */
static int hasfinalize (global_State *g) {
    GCObject *o;
    lua_assert(g->tmudata == NULL);
    
    /* æ‰«æ mainthread çš„ upvalue åˆ—è¡¨ */
    for (o = g->mainthread->openupval; o != NULL; o = o->gch.next) {
        if (gch2uv(o)->marked & (FINALIZEDBIT | SEPARATED))
            return 1;
    }
    
    /* æ‰«ææ‰€æœ‰ userdata */
    for (o = g->rootgc; o != NULL; o = o->gch.next) {
        if (o->gch.tt == LUA_TUSERDATA) {
            Udata *u = rawgco2u(o);
            if (u->metatable && u->metatable->flags & (1<<TM_GC))
                return 1;
        }
    }
    
    return 0;
}
```

#### Finalizer æ³¨å†Œ

```c
/* lgc.c - æ ‡è®°é˜¶æ®µæ£€æµ‹ finalizer */
static void markmt (global_State *g) {
    int i;
    
    for (i=0; i<NUM_TAGS; i++) {
        if (g->mt[i])
            markobject(g, g->mt[i]);
    }
}

/* æ£€æŸ¥ table/userdata æ˜¯å¦æœ‰ __gc */
#define gfasttm(g,et,e) \
    ((et) == NULL ? NULL : \
     ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
```

---

### 5.2 Finalizer æ‰§è¡Œæ—¶æœº

#### GC æµç¨‹ä¸­çš„ä½ç½®

```c
/* lgc.c - GC çŠ¶æ€æœº */
GCSpropagate    â†’ æ ‡è®°å¯¹è±¡
GCSsweepstring  â†’ æ¸…é™¤å­—ç¬¦ä¸²
GCSsweep        â†’ æ¸…é™¤å¯¹è±¡
GCSfinalize     â†’ â† æ‰§è¡Œ Finalizer
GCSpause        â†’ GC å®Œæˆ
```

#### æ‰§è¡Œæµç¨‹

```c
/* lgc.c - GCTM å‡½æ•° */
static void GCTM (lua_State *L) {
    global_State *g = G(L);
    GCObject *o = g->tmudata;
    
    if (o == NULL)
        return;
    
    /* ä» tmudata é“¾è¡¨ç§»é™¤ */
    g->tmudata = o->gch.next;
    
    /* æ¢å¤å¯¹è±¡ï¼ˆå¤æ´»ï¼‰*/
    o->gch.marked &= ~(SEPARATED | FINALIZEDBIT);
    o->gch.marked |= FIXEDBIT;  /* æ ‡è®°ä¸ºå›ºå®šï¼Œä¸ä¼šè¢«å†æ¬¡å›æ”¶ */
    
    /* è·å– __gc å…ƒæ–¹æ³• */
    const TValue *tm;
    if (o->gch.tt == LUA_TUSERDATA) {
        Udata *udata = rawgco2u(o);
        tm = fasttm(L, udata->metatable, TM_GC);
    } else {
        Table *h = gco2h(o);
        tm = fasttm(L, h->metatable, TM_GC);
    }
    
    /* è°ƒç”¨ finalizer */
    if (tm != NULL) {
        lu_byte oldah = L->allowhook;
        L->allowhook = 0;  /* ç¦æ­¢é’©å­ */
        
        setobj2s(L, L->top, tm);
        setobj2s(L, L->top+1, o);
        L->top += 2;
        
        luaD_call(L, L->top - 2, 0);
        
        L->allowhook = oldah;
    }
}
```

#### æ‰§è¡Œé¡ºåº

**é—®é¢˜ï¼š** å¤šä¸ªå¯¹è±¡æœ‰ finalizerï¼Œè°å…ˆæ‰§è¡Œï¼Ÿ

**ç­”æ¡ˆï¼š** æŒ‰ç…§è¿›å…¥ tmudata é“¾è¡¨çš„é¡ºåºï¼ˆFIFOï¼‰

```lua
-- ç¤ºä¾‹
local obj1 = setmetatable({name="A"}, {
    __gc = function(self) print("GC:", self.name) end
})

local obj2 = setmetatable({name="B"}, {
    __gc = function(self) print("GC:", self.name) end
})

obj1 = nil
obj2 = nil
collectgarbage("collect")

-- è¾“å‡ºï¼ˆé¡ºåºä¸ç¡®å®šï¼‰ï¼š
-- GC: A
-- GC: B
-- æˆ–
-- GC: B
-- GC: A
```

---

### 5.3 å¤æ´»å¯¹è±¡å¤„ç†

#### å¤æ´»æœºåˆ¶

**æ ¸å¿ƒé—®é¢˜ï¼š** Finalizer å¯èƒ½è®©å¯¹è±¡"èµ·æ­»å›ç”Ÿ"

```lua
saved_obj = nil

local obj = setmetatable({data = "important"}, {
    __gc = function(self)
        print("æ‹¯æ•‘å¯¹è±¡ï¼")
        saved_obj = self  -- å¤æ´»ï¼
    end
})

obj = nil
collectgarbage("collect")
-- è¾“å‡º: æ‹¯æ•‘å¯¹è±¡ï¼

print(saved_obj.data)  -- "important"
-- å¯¹è±¡å¤æ´»äº†ï¼
```

#### å®ç°ç»†èŠ‚

```c
/* lgc.c - GCTM */
void GCTM (lua_State *L) {
    /* ... è·å–å¯¹è±¡ ... */
    
    /* å…³é”®ï¼šé‡æ–°æ ‡è®°ä¸ºæ´»è·ƒ */
    o->gch.marked |= FIXEDBIT;  /* å›ºå®šä½ï¼Œé˜²æ­¢å†æ¬¡å›æ”¶ */
    
    /* æ‰§è¡Œ __gc */
    /* ... */
    
    /* å¦‚æœ __gc ä¸­åˆ›å»ºäº†æ–°å¼•ç”¨ï¼Œå¯¹è±¡å°±å¤æ´»äº† */
}
```

**åæœï¼š**
- å¤æ´»çš„å¯¹è±¡**ä¸ä¼šå†æ‰§è¡Œ** `__gc`ï¼ˆFIXEDBIT æ ‡è®°ï¼‰
- å¦‚æœå†æ¬¡å˜ä¸ºåƒåœ¾ï¼Œç›´æ¥å›æ”¶ï¼ˆæ—  finalizerï¼‰

#### å¤æ´»ç¤ºä¾‹

```lua
-- å®Œæ•´ç¤ºä¾‹ï¼šå¯¹è±¡å¤æ´»
local graveyard = {}

local obj = setmetatable({id = 1}, {
    __gc = function(self)
        print("ç¬¬ä¸€æ¬¡ GC:", self.id)
        table.insert(graveyard, self)  -- å¤æ´»
    end
})

obj = nil
collectgarbage("collect")
-- è¾“å‡º: ç¬¬ä¸€æ¬¡ GC: 1

print("å¤æ´»å¯¹è±¡:", graveyard[1].id)  -- 1

-- å†æ¬¡å˜ä¸ºåƒåœ¾
graveyard = {}
collectgarbage("collect")
-- æ— è¾“å‡ºï¼__gc ä¸å†æ‰§è¡Œ
```

---

### 5.4 å¾ªç¯å¼•ç”¨ä¸ Finalizer

#### é—®é¢˜åœºæ™¯

```lua
local obj1 = setmetatable({name="A"}, {
    __gc = function(self) print("GC:", self.name) end
})

local obj2 = setmetatable({name="B"}, {
    __gc = function(self) print("GC:", self.name) end
})

-- åˆ›å»ºå¾ªç¯å¼•ç”¨
obj1.ref = obj2
obj2.ref = obj1

obj1 = nil
obj2 = nil

collectgarbage("collect")
-- ä¸¤ä¸ªå¯¹è±¡éƒ½ä¼šè¢«å›æ”¶ï¼
-- è¾“å‡º:
-- GC: A
-- GC: B
```

**åŸå› ï¼š** Lua çš„ GC èƒ½å¤Ÿæ­£ç¡®å¤„ç†å¾ªç¯å¼•ç”¨ä¸­çš„ finalizerã€‚

#### å¤„ç†æœºåˆ¶

```c
/* lgc.c - æ ‡è®°é˜¶æ®µ */
static void propagatemark (global_State *g) {
    GCObject *o = g->gray;
    
    /* æ ‡è®°å­å¯¹è±¡ */
    switch (o->gch.tt) {
        case LUA_TTABLE: {
            Table *h = gco2h(o);
            g->gray = h->gclist;
            
            /* æ ‡è®°æ•°ç»„éƒ¨åˆ† */
            traversetable(g, h);
            
            /* å¦‚æœæœ‰ __gcï¼ŒåŠ å…¥ tmudata */
            if (h->metatable && (h->metatable->flags & (1<<TM_GC))) {
                h->gclist = g->tmudata;
                g->tmudata = o;
            }
            break;
        }
        /* ... */
    }
}
```

#### å¤æ‚æƒ…å†µ

**åœºæ™¯ï¼š** Finalizer ä¸­è®¿é—®å¾ªç¯å¼•ç”¨çš„å¯¹è±¡

```lua
local obj1 = {}
local obj2 = {}

obj1.ref = obj2
obj2.ref = obj1

setmetatable(obj1, {
    __gc = function(self)
        print("GC obj1, è®¿é—® obj2:", self.ref.name)
    end
})

setmetatable(obj2, {
    __gc = function(self)
        print("GC obj2")
        self.name = "obj2"
    end
})

obj1 = nil
obj2 = nil
collectgarbage("collect")

-- è¾“å‡ºï¼ˆé¡ºåºä¸å®šï¼‰ï¼š
-- GC obj2
-- GC obj1, è®¿é—® obj2: obj2
-- æˆ–
-- GC obj1, è®¿é—® obj2: nil  â† obj2 å·²å›æ”¶ï¼
```

**ç»“è®ºï¼š** Finalizer æ‰§è¡Œé¡ºåºä¸å¯é¢„æµ‹ï¼Œé¿å…åœ¨ finalizer ä¸­è®¿é—®å…¶ä»–å¯¹è±¡ã€‚

---

### 5.5 Finalizer æ€§èƒ½å½±å“

#### å¼€é”€åˆ†æ

```c
/* æµ‹è¯•ä»£ç  */
#include <lua.h>
#include <time.h>

void benchmark_finalizer() {
    lua_State *L = luaL_newstate();
    
    clock_t start = clock();
    
    /* åˆ›å»º 10 ä¸‡ä¸ªæœ‰ finalizer çš„å¯¹è±¡ */
    luaL_dostring(L,
        "local mt = {__gc = function() end}\n"
        "for i = 1, 100000 do\n"
        "    setmetatable({}, mt)\n"
        "end\n"
    );
    
    collectgarbage("collect");
    
    clock_t end = clock();
    double ms = (double)(end - start) * 1000 / CLOCKS_PER_SEC;
    
    printf("With finalizer: %.2f ms\n", ms);
    lua_close(L);
    
    /* å¯¹ç…§ï¼šæ—  finalizer */
    L = luaL_newstate();
    start = clock();
    
    luaL_dostring(L,
        "for i = 1, 100000 do\n"
        "    {}\n"  -- æ—  finalizer
        "end\n"
    );
    
    collectgarbage("collect");
    
    end = clock();
    ms = (double)(end - start) * 1000 / CLOCKS_PER_SEC;
    
    printf("Without finalizer: %.2f ms\n", ms);
    lua_close(L);
}
```

**ç»“æœï¼š**
```
With finalizer:    250 ms
Without finalizer:  50 ms

æ€§èƒ½å½±å“ï¼š5 å€æ…¢ï¼
```

#### ä¼˜åŒ–å»ºè®®

**1. é¿å…ä¸å¿…è¦çš„ finalizer**
```lua
-- ä¸å¥½
local obj = setmetatable({}, {
    __gc = function() end  -- ç©º finalizer
})

-- å¥½
local obj = {}  -- æ—  finalizer
```

**2. æ‰¹é‡æ¸…ç†**
```lua
-- ä¸å¥½ï¼šæ¯ä¸ªå¯¹è±¡ä¸€ä¸ª finalizer
for i = 1, 10000 do
    local obj = setmetatable({handle = open_file(i)}, {
        __gc = function(self) close_file(self.handle) end
    })
end

-- å¥½ï¼šç»Ÿä¸€ç®¡ç†
local file_manager = {
    handles = {},
    __gc = function(self)
        for _, h in ipairs(self.handles) do
            close_file(h)
        end
    end
}

for i = 1, 10000 do
    table.insert(file_manager.handles, open_file(i))
end

setmetatable(file_manager, file_manager)
```

**3. ä½¿ç”¨ ffi.gc (LuaJIT)**
```lua
-- LuaJIT FFI çš„ GC æ›´é«˜æ•ˆ
local ffi = require("ffi")

ffi.cdef[[
    void *malloc(size_t size);
    void free(void *ptr);
]]

local ptr = ffi.gc(ffi.C.malloc(1024), ffi.C.free)
-- è‡ªåŠ¨ç®¡ç†ï¼Œæ— éœ€ __gc
```

---

## å¼±è¡¨ä¸å†…å­˜ç®¡ç†

### 6.1 å¼±è¡¨çš„ä¸‰ç§æ¨¡å¼

#### æ¨¡å¼å®šä¹‰

```lua
-- æ¨¡å¼ 1ï¼šå¼±é”® (weak keys)
local weak_keys = setmetatable({}, {__mode = "k"})

-- æ¨¡å¼ 2ï¼šå¼±å€¼ (weak values)
local weak_values = setmetatable({}, {__mode = "v"})

-- æ¨¡å¼ 3ï¼šå…¨å¼± (weak keys and values)
local weak_both = setmetatable({}, {__mode = "kv"})
```

#### è¡Œä¸ºå·®å¼‚

**å¼±é”®è¡¨ï¼š**
```lua
local wk = setmetatable({}, {__mode = "k"})
local key = {}

wk[key] = "value"
print(wk[key])  -- "value"

key = nil
collectgarbage("collect")

-- é”®è¢«å›æ”¶ï¼Œé”®å€¼å¯¹æ¶ˆå¤±
for k, v in pairs(wk) do
    print(k, v)  -- æ— è¾“å‡º
end
```

**å¼±å€¼è¡¨ï¼š**
```lua
local wv = setmetatable({}, {__mode = "v"})
local value = {}

wv["key"] = value
print(wv["key"])  -- table: 0x...

value = nil
collectgarbage("collect")

-- å€¼è¢«å›æ”¶
print(wv["key"])  -- nil
```

**å…¨å¼±è¡¨ï¼š**
```lua
local wb = setmetatable({}, {__mode = "kv"})
local key = {}
local value = {}

wb[key] = value

key = nil
-- æˆ– value = nil
collectgarbage("collect")

-- é”®æˆ–å€¼ä»»ä¸€è¢«å›æ”¶ï¼Œé”®å€¼å¯¹æ¶ˆå¤±
```

---

### 6.2 å¼±å¼•ç”¨çš„ GC å¤„ç†

#### æ ‡è®°é˜¶æ®µ

```c
/* lgc.c - éå†è¡¨ */
static void traversetable (global_State *g, Table *h) {
    int weakkey = 0;
    int weakvalue = 0;
    const TValue *mode;
    
    /* æ£€æŸ¥ __mode */
    if (h->metatable)
        mode = gfasttm(g, h->metatable, TM_MODE);
    else
        mode = NULL;
    
    if (mode && ttisstring(mode)) {
        /* è§£ææ¨¡å¼å­—ç¬¦ä¸² */
        const char *modestr = svalue(mode);
        weakkey = strchr(modestr, 'k') != NULL;
        weakvalue = strchr(modestr, 'v') != NULL;
    }
    
    if (weakkey || weakvalue) {
        /* å¼±è¡¨ï¼šåŠ å…¥ weak é“¾è¡¨ï¼Œç¨åå¤„ç† */
        h->gclist = g->weak;
        g->weak = obj2gco(h);
        
        /* æ ‡è®°å…ƒè¡¨å’Œéå¼±éƒ¨åˆ† */
        if (!weakvalue) {
            /* å€¼æ˜¯å¼ºå¼•ç”¨ï¼Œæ ‡è®°æ‰€æœ‰å€¼ */
            traverseweakvalue(g, h);
        }
    } else {
        /* å¼ºè¡¨ï¼šæ­£å¸¸æ ‡è®° */
        traversestrongtable(g, h);
    }
}
```

#### æ¸…é™¤é˜¶æ®µ

```c
/* lgc.c - æ¸…é™¤å¼±è¡¨ */
static void cleartable (GCObject *l) {
    while (l) {
        Table *h = gco2h(l);
        int i;
        
        /* æ£€æŸ¥æ•°ç»„éƒ¨åˆ† */
        for (i = 0; i < h->sizearray; i++) {
            TValue *o = &h->array[i];
            if (iswhite(gcvalue(o)))
                setnilvalue(o);  /* æ¸…é™¤ç™½è‰²å¯¹è±¡ */
        }
        
        /* æ£€æŸ¥å“ˆå¸Œéƒ¨åˆ† */
        for (i = 0; i < sizenode(h); i++) {
            Node *n = gnode(h, i);
            
            /* æ£€æŸ¥é”® */
            if (!ttisnil(gval(n)) && 
                (isclean(n, weakkey) || isclean(n, weakvalue))) {
                setnilvalue(gval(n));  /* æ¸…é™¤æ¡ç›® */
            }
        }
        
        l = h->gclist;
    }
}
```

---

### 6.3 å¼±è¡¨çš„å†…å­˜ä¼˜åŒ–

#### ç¼“å­˜å®ç°

```lua
-- ç®€å•ç¼“å­˜
local cache = setmetatable({}, {__mode = "v"})

function get_expensive_object(key)
    -- å…ˆæŸ¥ç¼“å­˜
    if cache[key] then
        return cache[key]
    end
    
    -- è®¡ç®—
    local obj = compute_expensive(key)
    
    -- ç¼“å­˜ï¼ˆå¼±å¼•ç”¨ï¼‰
    cache[key] = obj
    
    return obj
end
```

**ä¼˜ç‚¹ï¼š**
- è‡ªåŠ¨é‡Šæ”¾ä¸ç”¨çš„ç¼“å­˜
- æ— éœ€æ‰‹åŠ¨ç®¡ç†
- å†…å­˜è‡ªåŠ¨å¹³è¡¡

#### å¯¹è±¡æ± 

```lua
-- å¯¹è±¡æ± ï¼ˆå¤ç”¨å¯¹è±¡ï¼‰
local object_pool = setmetatable({}, {__mode = "v"})

function get_object()
    -- ä»æ± ä¸­å–
    if #object_pool > 0 then
        return table.remove(object_pool)
    end
    
    -- åˆ›å»ºæ–°å¯¹è±¡
    return {data = {}}
end

function return_object(obj)
    -- æ¸…ç†
    for k in pairs(obj) do
        obj[k] = nil
    end
    
    -- å½’è¿˜æ± ä¸­
    table.insert(object_pool, obj)
end
```

---

### 6.4 ç¼“å­˜è®¾è®¡æœ€ä½³å®è·µ

#### ä¸¤çº§ç¼“å­˜

```lua
-- LRU ç¼“å­˜ + å¼±å¼•ç”¨ç¼“å­˜
local strong_cache = {}  -- å¼ºå¼•ç”¨ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
local weak_cache = setmetatable({}, {__mode = "v"})
local max_strong = 100

function cached_get(key)
    -- 1. æŸ¥å¼ºç¼“å­˜
    if strong_cache[key] then
        return strong_cache[key]
    end
    
    -- 2. æŸ¥å¼±ç¼“å­˜
    if weak_cache[key] then
        local obj = weak_cache[key]
        
        -- æå‡åˆ°å¼ºç¼“å­˜
        if #strong_cache >= max_strong then
            table.remove(strong_cache, 1)  -- ç§»é™¤æœ€æ—§
        end
        table.insert(strong_cache, key)
        strong_cache[key] = obj
        
        return obj
    end
    
    -- 3. è®¡ç®—
    local obj = expensive_compute(key)
    
    -- åŠ å…¥ä¸¤çº§ç¼“å­˜
    table.insert(strong_cache, key)
    strong_cache[key] = obj
    weak_cache[key] = obj
    
    return obj
end
```

#### ç¼“å­˜ç»Ÿè®¡

```lua
local cache_stats = {
    hits = 0,
    misses = 0,
    evictions = 0
}

function get_with_stats(key)
    if cache[key] then
        cache_stats.hits = cache_stats.hits + 1
        return cache[key]
    else
        cache_stats.misses = cache_stats.misses + 1
        local obj = compute(key)
        cache[key] = obj
        return obj
    end
end

function print_cache_stats()
    local total = cache_stats.hits + cache_stats.misses
    local hit_rate = 100.0 * cache_stats.hits / total
    
    print(string.format("Cache hit rate: %.1f%%", hit_rate))
    print(string.format("Hits: %d, Misses: %d", 
          cache_stats.hits, cache_stats.misses))
end
```

---

## å­—ç¬¦ä¸²å†…éƒ¨åŒ–ä¸ GC

### 7.1 å­—ç¬¦ä¸²è¡¨ç»“æ„

#### æ•°æ®ç»“æ„

```c
/* lstate.h - stringtable */
typedef struct stringtable {
    GCObject **hash;     /* å“ˆå¸Œè¡¨æ•°ç»„ */
    lu_int32 nuse;       /* å·²ä½¿ç”¨æ§½ä½æ•° */
    int size;            /* å“ˆå¸Œè¡¨å¤§å° */
} stringtable;

/* global_State */
typedef struct global_State {
    stringtable strt;    /* å­—ç¬¦ä¸²è¡¨ */
    /* ... */
} global_State;
```

#### å†…éƒ¨åŒ–è¿‡ç¨‹

```c
/* lstring.c - åˆ›å»ºå­—ç¬¦ä¸² */
TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
    global_State *g = G(L);
    GCObject *o;
    unsigned int h = cast(unsigned int, l);  /* ç§å­ */
    size_t step = (l >> 5) + 1;              /* æ­¥é•¿ */
    size_t l1;
    
    /* è®¡ç®—å“ˆå¸Œå€¼ï¼ˆåªå“ˆå¸Œéƒ¨åˆ†å­—ç¬¦ï¼‰*/
    for (l1 = l; l1 >= step; l1 -= step)
        h = h ^ ((h<<5) + (h>>2) + cast(unsigned char, str[l1-1]));
    
    /* æŸ¥æ‰¾ç°æœ‰å­—ç¬¦ä¸² */
    for (o = g->strt.hash[lmod(h, g->strt.size)];
         o != NULL;
         o = o->gch.next) {
        TString *ts = rawgco2ts(o);
        if (ts->tsv.len == l && 
            (memcmp(str, getstr(ts), l) == 0)) {
            /* æ‰¾åˆ°äº†ï¼è¿”å›ç°æœ‰å­—ç¬¦ä¸² */
            return ts;
        }
    }
    
    /* æœªæ‰¾åˆ°ï¼Œåˆ›å»ºæ–°å­—ç¬¦ä¸² */
    TString *ts = newlstr(L, str, l, h);
    return ts;
}
```

**ç‰¹ç‚¹ï¼š**
- ç›¸åŒå†…å®¹çš„å­—ç¬¦ä¸²åªå­˜å‚¨ä¸€ä»½
- å­—ç¬¦ä¸²æ¯”è¾ƒå˜æˆæŒ‡é’ˆæ¯”è¾ƒï¼ˆO(1)ï¼‰
- èŠ‚çœå†…å­˜

---

### 7.2 å­—ç¬¦ä¸²çš„ GC æ ‡è®°

#### æ ‡è®°è¿‡ç¨‹

```c
/* lgc.c - æ ‡è®°å­—ç¬¦ä¸² */
#define markvalue(g,o) { \
    if (iscollectable(o) && iswhite(gcvalue(o))) \
        reallymarkobject(g,gcvalue(o)); }

static void reallymarkobject (global_State *g, GCObject *o) {
    switch (o->gch.tt) {
        case LUA_TSTRING: {
            /* å­—ç¬¦ä¸²ï¼šç›´æ¥æ ‡è®°ä¸ºé»‘è‰²ï¼ˆæ— å­å¯¹è±¡ï¼‰*/
            white2gray(o);
            gray2black(o);
            break;
        }
        /* ... å…¶ä»–ç±»å‹ ... */
    }
}
```

**ç®€å•åŸå› ï¼š** å­—ç¬¦ä¸²æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ— å­å¯¹è±¡éœ€è¦éå†ã€‚

---

### 7.3 å­—ç¬¦ä¸²è¡¨æ‰«æ

#### æ¸…é™¤è¿‡ç¨‹

```c
/* lgc.c - æ¸…é™¤å­—ç¬¦ä¸²è¡¨ */
static void sweepwholelist (lua_State *L, GCObject **p) {
    GCObject *curr;
    global_State *g = G(L);
    int deadmask = otherwhite(g);  /* å½“å‰è½®çš„åƒåœ¾é¢œè‰² */
    
    while ((curr = *p) != NULL) {
        if ((curr->gch.marked ^ WHITEBITS) & deadmask) {
            /* å­˜æ´»ï¼šä¿ç•™ */
            lua_assert(!isdead(g, curr));
            makewhite(g, curr);  /* æ ‡è®°ä¸ºä¸‹ä¸€è½®çš„ç™½è‰² */
            p = &curr->gch.next;
        } else {
            /* æ­»äº¡ï¼šé‡Šæ”¾ */
            lua_assert(isdead(g, curr));
            *p = curr->gch.next;
            
            /* é‡Šæ”¾å­—ç¬¦ä¸²å†…å­˜ */
            TString *ts = rawgco2ts(curr);
            g->strt.nuse--;
            luaM_freemem(L, ts, sizestring(ts));
        }
    }
}
```

#### è¡¨æ‰©å±•

```c
/* lstring.c - å­—ç¬¦ä¸²è¡¨æ‰©å±• */
void luaS_resize (lua_State *L, int newsize) {
    global_State *g = G(L);
    stringtable *tb = &g->strt;
    
    if (newsize > tb->size) {
        /* æ‰©å±•è¡¨ */
        GCObject **newhash = luaM_newvector(L, newsize, GCObject *);
        
        /* é‡æ–°å“ˆå¸Œæ‰€æœ‰å­—ç¬¦ä¸² */
        for (int i = 0; i < tb->size; i++) {
            GCObject *p = tb->hash[i];
            while (p) {
                GCObject *next = p->gch.next;
                unsigned int h = gco2ts(p)->hash;
                int h1 = lmod(h, newsize);
                
                p->gch.next = newhash[h1];
                newhash[h1] = p;
                
                p = next;
            }
        }
        
        luaM_freearray(L, tb->hash, tb->size, GCObject *);
        tb->size = newsize;
        tb->hash = newhash;
    }
}
```

---

### 7.4 å­—ç¬¦ä¸²å†…å­˜ä¼˜åŒ–

#### çŸ­å­—ç¬¦ä¸²ä¼˜åŒ–

```lua
-- é—®é¢˜ï¼šå¤§é‡çŸ­å­—ç¬¦ä¸²
for i = 1, 1000000 do
    local s = string.format("%d", i)  -- åˆ›å»º 100 ä¸‡ä¸ªå­—ç¬¦ä¸²
end

collectgarbage("collect")
print(collectgarbage("count"), "KB")
-- çº¦ 50MB ï¼ˆå¤§é‡å†…å­˜ï¼‰
```

**ä¼˜åŒ–1ï¼šå¤ç”¨å­—ç¬¦ä¸²**
```lua
local string_pool = {}

for i = 1, 1000 do
    string_pool[i] = tostring(i)
end

-- ä½¿ç”¨æ± ä¸­çš„å­—ç¬¦ä¸²
for i = 1, 1000000 do
    local idx = (i % 1000) + 1
    local s = string_pool[idx]  -- å¤ç”¨
end

-- å†…å­˜æ˜¾è‘—å‡å°‘
```

**ä¼˜åŒ–2ï¼šä½¿ç”¨æ•°å­—**
```lua
-- ä¸è¦æ— æ„ä¹‰åœ°è½¬å­—ç¬¦ä¸²
local ids = {}
for i = 1, 1000000 do
    ids[i] = i  -- æ•°å­—ï¼Œä¸æ˜¯å­—ç¬¦ä¸²
end
```

#### é•¿å­—ç¬¦ä¸²é—®é¢˜

```lua
-- é—®é¢˜ï¼šå­—ç¬¦ä¸²æ‹¼æ¥
local s = ""
for i = 1, 10000 do
    s = s .. "line " .. i .. "\n"  -- O(nÂ²) å¤æ‚åº¦ï¼
end
```

**è§£å†³ï¼šä½¿ç”¨ table.concat**
```lua
local lines = {}
for i = 1, 10000 do
    lines[i] = "line " .. i .. "\n"
end
local s = table.concat(lines)  -- O(n) å¤æ‚åº¦
```

---

## GC å‚æ•°è°ƒä¼˜

### 8.1 GC å‚æ•°è¯¦è§£

#### ä¸‰å¤§å‚æ•°

```c
/* lstate.h - global_State */
typedef struct global_State {
    /* GC å‚æ•° */
    int gcpause;      /* GC æš‚åœæ—¶é—´ï¼ˆç™¾åˆ†æ¯”ï¼‰*/
    int gcstepmul;    /* GC æ­¥è¿›å€ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰*/
    lu_mem GCthreshold;  /* GC è§¦å‘é˜ˆå€¼ */
    /* ... */
} global_State;
```

#### å‚æ•°å«ä¹‰

**1. gcpauseï¼ˆé»˜è®¤ï¼š200ï¼‰**
```lua
-- æ§åˆ¶ä¸‹æ¬¡ GC å¯åŠ¨çš„æ—¶æœº
collectgarbage("setpause", 200)

-- å…¬å¼ï¼š
-- GCthreshold = totalbytes * (1 + gcpause/100)

-- ç¤ºä¾‹ï¼š
-- totalbytes = 1MB, gcpause = 200
-- GCthreshold = 1MB * (1 + 200/100) = 3MB
-- å½“å†…å­˜è¾¾åˆ° 3MB æ—¶ï¼Œå¯åŠ¨ä¸‹æ¬¡ GC
```

**å½±å“ï¼š**
- **å¢å¤§ gcpause**ï¼šGC é¢‘ç‡é™ä½ï¼Œååé‡æå‡ï¼Œå†…å­˜å ç”¨å¢åŠ 
- **å‡å° gcpause**ï¼šGC é¢‘ç‡å¢åŠ ï¼Œå†…å­˜å ç”¨é™ä½ï¼Œååé‡ä¸‹é™

**2. gcstepmulï¼ˆé»˜è®¤ï¼š200ï¼‰**
```lua
-- æ§åˆ¶æ¯æ¬¡å†…å­˜åˆ†é…æ—¶çš„ GC å·¥ä½œé‡
collectgarbage("setstepmul", 200)

-- å…¬å¼ï¼š
-- æ¯æ¬¡åˆ†é… n å­—èŠ‚æ—¶ï¼ŒGC å·¥ä½œé‡ = n * (gcstepmul/100)

-- ç¤ºä¾‹ï¼š
-- åˆ†é… 1KBï¼Œgcstepmul = 200
-- GC å·¥ä½œé‡ = 1KB * (200/100) = 2KB
-- GC å›æ”¶ 2KB çš„å¯¹è±¡
```

**å½±å“ï¼š**
- **å¢å¤§ gcstepmul**ï¼šGC å·¥ä½œæ›´æ¿€è¿›ï¼Œå†…å­˜æ›´å¿«å›æ”¶ï¼ŒCPU å ç”¨å¢åŠ 
- **å‡å° gcstepmul**ï¼šGC å·¥ä½œä¿å®ˆï¼ŒCPU å ç”¨é™ä½ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜å¢é•¿

**3. GCthresholdï¼ˆåŠ¨æ€è®¡ç®—ï¼‰**
```c
/* lgc.c - è®¡ç®—é˜ˆå€¼ */
static void setthreshold (global_State *g) {
    lu_mem debt = g->totalbytes - g->GCthreshold;
    
    if (debt > 0) {
        /* å†…å­˜è¶…å‡ºé˜ˆå€¼ï¼Œéœ€è¦ GC */
        g->GCdebt = debt;
    } else {
        /* æ­£å¸¸æƒ…å†µ */
        g->GCdebt = 0;
        g->GCthreshold = g->totalbytes * (1 + g->gcpause/100);
    }
}
```

---

### 8.2 ä¸åŒåœºæ™¯çš„è°ƒä¼˜ç­–ç•¥

#### åœºæ™¯ 1ï¼šå†…å­˜å—é™ç¯å¢ƒ

**ç‰¹ç‚¹ï¼š**
- RAM æœ‰é™ï¼ˆä¾‹å¦‚åµŒå…¥å¼è®¾å¤‡ 512KBï¼‰
- å“åº”æ—¶é—´ä¸æ•æ„Ÿ
- å†…å­˜ä½¿ç”¨ä¼˜å…ˆäºæ€§èƒ½

**è°ƒä¼˜ç­–ç•¥ï¼š**
```lua
-- ä½ gcpauseï¼šé¢‘ç¹ GCï¼Œå†…å­˜å ç”¨ä½
collectgarbage("setpause", 100)  -- é»˜è®¤ 200

-- é«˜ gcstepmulï¼šæ¿€è¿›å›æ”¶
collectgarbage("setstepmul", 400)  -- é»˜è®¤ 200

print("å†…å­˜ä¼˜åŒ–æ¨¡å¼å¯ç”¨")
```

**æ•ˆæœæµ‹è¯•ï¼š**
```c
/* æµ‹è¯•ä»£ç  */
void test_memory_limited() {
    lua_State *L = luaL_newstate();
    
    /* é»˜è®¤å‚æ•° */
    luaL_dostring(L,
        "for i = 1, 100000 do\n"
        "    local t = {data = string.rep('x', 100)}\n"
        "end\n"
    );
    
    size_t default_mem = lua_gc(L, LUA_GCCOUNT, 0);
    lua_close(L);
    
    /* ä¼˜åŒ–å‚æ•° */
    L = luaL_newstate();
    lua_gc(L, LUA_GCSETPAUSE, 100);
    lua_gc(L, LUA_GCSETSTEPMUL, 400);
    
    luaL_dostring(L,
        "for i = 1, 100000 do\n"
        "    local t = {data = string.rep('x', 100)}\n"
        "end\n"
    );
    
    size_t optimized_mem = lua_gc(L, LUA_GCCOUNT, 0);
    lua_close(L);
    
    printf("é»˜è®¤å†…å­˜: %zu KB\n", default_mem);
    printf("ä¼˜åŒ–å†…å­˜: %zu KB\n", optimized_mem);
    printf("èŠ‚çœ: %.1f%%\n", 
           100.0 * (default_mem - optimized_mem) / default_mem);
}

/* è¾“å‡ºç¤ºä¾‹ï¼š
é»˜è®¤å†…å­˜: 15240 KB
ä¼˜åŒ–å†…å­˜: 8120 KB
èŠ‚çœ: 46.7%
*/
```

---

#### åœºæ™¯ 2ï¼šé«˜æ€§èƒ½åº”ç”¨

**ç‰¹ç‚¹ï¼š**
- å……è¶³å†…å­˜ï¼ˆæœåŠ¡å™¨ 16GB+ï¼‰
- å“åº”æ—¶é—´æ•æ„Ÿï¼ˆæ¸¸æˆã€å®æ—¶ç³»ç»Ÿï¼‰
- æ€§èƒ½ä¼˜å…ˆäºå†…å­˜

**è°ƒä¼˜ç­–ç•¥ï¼š**
```lua
-- é«˜ gcpauseï¼šé™ä½ GC é¢‘ç‡
collectgarbage("setpause", 500)  -- 5 å€å†…å­˜å¢é•¿æ‰ GC

-- ä½ gcstepmulï¼šå‡å°‘ GC å·¥ä½œ
collectgarbage("setstepmul", 100)  -- ä¿å®ˆå›æ”¶

print("æ€§èƒ½ä¼˜åŒ–æ¨¡å¼å¯ç”¨")
```

**æ•ˆæœæµ‹è¯•ï¼š**
```c
void test_high_performance() {
    lua_State *L = luaL_newstate();
    
    /* æ€§èƒ½æµ‹è¯•å‡½æ•° */
    const char *benchmark = 
        "local start = os.clock()\n"
        "for i = 1, 1000000 do\n"
        "    local t = {x=i, y=i*2, z=i*3}\n"
        "end\n"
        "local elapsed = os.clock() - start\n"
        "return elapsed\n";
    
    /* é»˜è®¤å‚æ•° */
    lua_gc(L, LUA_GCSETPAUSE, 200);
    lua_gc(L, LUA_GCSETSTEPMUL, 200);
    luaL_dostring(L, benchmark);
    double default_time = lua_tonumber(L, -1);
    lua_pop(L, 1);
    
    /* ä¼˜åŒ–å‚æ•° */
    lua_gc(L, LUA_GCSETPAUSE, 500);
    lua_gc(L, LUA_GCSETSTEPMUL, 100);
    luaL_dostring(L, benchmark);
    double optimized_time = lua_tonumber(L, -1);
    lua_pop(L, 1);
    
    printf("é»˜è®¤æ—¶é—´: %.3f ç§’\n", default_time);
    printf("ä¼˜åŒ–æ—¶é—´: %.3f ç§’\n", optimized_time);
    printf("æé€Ÿ: %.1f%%\n", 
           100.0 * (default_time - optimized_time) / default_time);
    
    lua_close(L);
}

/* è¾“å‡ºç¤ºä¾‹ï¼š
é»˜è®¤æ—¶é—´: 0.485 ç§’
ä¼˜åŒ–æ—¶é—´: 0.312 ç§’
æé€Ÿ: 35.7%
*/
```

---

#### åœºæ™¯ 3ï¼šå®æ—¶ç³»ç»Ÿ

**ç‰¹ç‚¹ï¼š**
- ä¸¥æ ¼å“åº”æ—¶é—´è¦æ±‚ï¼ˆæ¯«ç§’çº§ï¼‰
- ä¸èƒ½æ¥å—é•¿æ—¶é—´ GC æš‚åœ
- éœ€è¦å¯é¢„æµ‹çš„å»¶è¿Ÿ

**è°ƒä¼˜ç­–ç•¥ï¼š**
```lua
-- åˆ†ä»£ GC æ¨¡å¼ï¼ˆLua 5.2+ï¼‰
-- Lua 5.1 éœ€è¦æ‰‹åŠ¨æ§åˆ¶

-- ç­–ç•¥ 1ï¼šå›ºå®šæ—¶é—´ç‰‡ GC
function realtime_gc_step()
    local start = os.clock()
    local max_time = 0.001  -- 1ms é™åˆ¶
    
    while os.clock() - start < max_time do
        if collectgarbage("step", 1) then
            break  -- GC å®Œæˆ
        end
    end
end

-- æ¯å¸§è°ƒç”¨
function game_loop()
    update_game()
    render_game()
    realtime_gc_step()  -- å—æ§ GC
end
```

**å®ç°ï¼š**
```c
/* C å±‚å®æ—¶ GC */
void realtime_gc_step(lua_State *L, double max_ms) {
    global_State *g = G(L);
    clock_t start = clock();
    double max_clocks = max_ms * CLOCKS_PER_SEC / 1000;
    
    /* ç¦ç”¨è‡ªåŠ¨ GC */
    g->GCthreshold = MAX_LUMEM;
    
    /* æ‰‹åŠ¨æ­¥è¿› */
    while (clock() - start < max_clocks) {
        if (g->gcstate == GCSpause)
            break;  /* GC å®Œæˆ */
        
        singlestep(L);
    }
    
    /* ç»Ÿè®¡ */
    double actual_ms = (clock() - start) * 1000.0 / CLOCKS_PER_SEC;
    printf("GC step: %.3f ms\n", actual_ms);
}
```

**æµ‹è¯•ï¼š**
```c
void test_realtime_gc() {
    lua_State *L = luaL_newstate();
    
    /* åˆ›å»ºå¤§é‡å¯¹è±¡ */
    luaL_dostring(L,
        "local objects = {}\n"
        "for i = 1, 10000 do\n"
        "    objects[i] = {data = string.rep('x', 1000)}\n"
        "end\n"
        "objects = nil\n"  -- å˜ä¸ºåƒåœ¾
    );
    
    /* æµ‹è¯•ä¸åŒæ—¶é—´ç‰‡ */
    double time_limits[] = {0.5, 1.0, 2.0, 5.0};  // ms
    
    for (int i = 0; i < 4; i++) {
        lua_gc(L, LUA_GCCOLLECT, 0);  // é‡ç½®
        
        printf("\næ—¶é—´ç‰‡é™åˆ¶: %.1f ms\n", time_limits[i]);
        
        int steps = 0;
        while (lua_gc(L, LUA_GCCOUNT, 0) > 100) {
            realtime_gc_step(L, time_limits[i]);
            steps++;
        }
        
        printf("æ€»æ­¥æ•°: %d\n", steps);
    }
    
    lua_close(L);
}

/* è¾“å‡ºç¤ºä¾‹ï¼š
æ—¶é—´ç‰‡é™åˆ¶: 0.5 ms
GC step: 0.483 ms
GC step: 0.491 ms
...
æ€»æ­¥æ•°: 45

æ—¶é—´ç‰‡é™åˆ¶: 1.0 ms
GC step: 0.987 ms
GC step: 0.993 ms
...
æ€»æ­¥æ•°: 23
*/
```

---

### 8.3 æ€§èƒ½æµ‹è¯•æ¡†æ¶

#### å®Œæ•´æµ‹è¯•å·¥å…·

```c
/* gc_benchmark.c */
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#include <stdio.h>
#include <time.h>

typedef struct {
    int gcpause;
    int gcstepmul;
    double time_ms;
    size_t peak_memory_kb;
    int gc_count;
} BenchmarkResult;

BenchmarkResult run_benchmark(int pause, int stepmul, const char *workload) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);
    
    /* è®¾ç½®å‚æ•° */
    lua_gc(L, LUA_GCSETPAUSE, pause);
    lua_gc(L, LUA_GCSETSTEPMUL, stepmul);
    
    BenchmarkResult result = {pause, stepmul, 0, 0, 0};
    
    /* è®¡æ—¶å¼€å§‹ */
    clock_t start = clock();
    
    /* æ‰§è¡Œå·¥ä½œè´Ÿè½½ */
    if (luaL_dostring(L, workload) != 0) {
        fprintf(stderr, "Error: %s\n", lua_tostring(L, -1));
    }
    
    /* è®¡æ—¶ç»“æŸ */
    clock_t end = clock();
    result.time_ms = (double)(end - start) * 1000 / CLOCKS_PER_SEC;
    
    /* æ”¶é›†ç»Ÿè®¡ */
    result.peak_memory_kb = lua_gc(L, LUA_GCCOUNT, 0);
    lua_getglobal(L, "collectgarbage");
    lua_pushstring(L, "count");
    lua_call(L, 1, 1);
    result.gc_count = lua_gc(L, LUA_GCCOUNT, 0);
    
    lua_close(L);
    return result;
}

void print_comparison() {
    const char *workload = 
        "local objects = {}\n"
        "for i = 1, 100000 do\n"
        "    objects[i] = {x=i, y=i*2, data=string.rep('test', 10)}\n"
        "end\n"
        "for i = 1, 100000 do\n"
        "    objects[i] = nil\n"
        "end\n";
    
    int pause_values[] = {100, 200, 300, 500};
    int stepmul_values[] = {100, 200, 400};
    
    printf("%-10s %-12s %-12s %-12s %-12s\n",
           "gcpause", "gcstepmul", "Time(ms)", "Memory(KB)", "GC Count");
    printf("-----------------------------------------------------------\n");
    
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 3; j++) {
            BenchmarkResult r = run_benchmark(
                pause_values[i], 
                stepmul_values[j], 
                workload
            );
            
            printf("%-10d %-12d %-12.2f %-12zu %-12d\n",
                   r.gcpause, r.gcstepmul, r.time_ms, 
                   r.peak_memory_kb, r.gc_count);
        }
    }
}

int main() {
    printf("=== Lua GC å‚æ•°æ€§èƒ½å¯¹æ¯” ===\n\n");
    print_comparison();
    return 0;
}
```

**ç¼–è¯‘è¿è¡Œï¼š**
```bash
gcc gc_benchmark.c -I/usr/include/lua5.1 -llua5.1 -o gc_bench
./gc_bench
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```
=== Lua GC å‚æ•°æ€§èƒ½å¯¹æ¯” ===

gcpause    gcstepmul    Time(ms)     Memory(KB)   GC Count    
-----------------------------------------------------------
100        100          523.45       8234         45          
100        200          498.23       8456         38          
100        400          512.67       8123         31          
200        100          412.34       15234        23          
200        200          387.56       15678        19          
200        400          401.23       14987        15          
300        100          365.78       22456        15          
300        200          342.12       23012        12          
300        400          358.45       22234        9           
500        100          298.67       38765        8           
500        200          276.23       39234        6           
500        400          289.34       38456        5           
```

**åˆ†æï¼š**
- gcpauseâ†‘ + gcstepmulâ†“ = æœ€å¿«ï¼ˆ500/100: 298msï¼‰ï¼Œä½†å†…å­˜é«˜ï¼ˆ38MBï¼‰
- gcpauseâ†“ + gcstepmulâ†‘ = æœ€çœå†…å­˜ï¼ˆ100/400: 8MBï¼‰ï¼Œä½†ç¨æ…¢ï¼ˆ512msï¼‰
- å¹³è¡¡ç‚¹ï¼š200/200ï¼ˆé»˜è®¤å€¼ï¼‰

---

### 8.4 è‡ªé€‚åº” GC ç®—æ³•

#### åŠ¨æ€è°ƒæ•´ç­–ç•¥

```lua
-- Lua å±‚è‡ªé€‚åº” GC
local GCAdapter = {
    target_memory_mb = 50,      -- ç›®æ ‡å†…å­˜
    target_fps = 60,             -- ç›®æ ‡å¸§ç‡
    
    current_pause = 200,
    current_stepmul = 200,
    
    frame_times = {},
    frame_index = 1,
    max_frames = 60,
}

function GCAdapter:update()
    -- æ”¶é›†å½“å‰çŠ¶æ€
    local memory_mb = collectgarbage("count") / 1024
    local current_time = os.clock()
    
    -- è®¡ç®—å¹³å‡å¸§æ—¶é—´
    self.frame_times[self.frame_index] = current_time
    self.frame_index = (self.frame_index % self.max_frames) + 1
    
    if #self.frame_times >= self.max_frames then
        local total_time = 0
        for i = 1, self.max_frames do
            total_time = total_time + (self.frame_times[i] or 0)
        end
        local avg_fps = self.max_frames / total_time
        
        -- å†³ç­–
        if memory_mb > self.target_memory_mb then
            -- å†…å­˜è¿‡é«˜ï¼šå¢åŠ  GC å¼ºåº¦
            self.current_stepmul = math.min(400, self.current_stepmul + 20)
            self.current_pause = math.max(100, self.current_pause - 10)
            
            collectgarbage("setpause", self.current_pause)
            collectgarbage("setstepmul", self.current_stepmul)
            
            print(string.format("å†…å­˜è¿‡é«˜ %.1f MBï¼Œå¢å¼º GC: pause=%d, stepmul=%d",
                  memory_mb, self.current_pause, self.current_stepmul))
                  
        elseif avg_fps < self.target_fps * 0.9 then
            -- å¸§ç‡è¿‡ä½ï¼šé™ä½ GC å¼ºåº¦
            self.current_stepmul = math.max(100, self.current_stepmul - 20)
            self.current_pause = math.min(500, self.current_pause + 10)
            
            collectgarbage("setpause", self.current_pause)
            collectgarbage("setstepmul", self.current_stepmul)
            
            print(string.format("å¸§ç‡è¿‡ä½ %.1f FPSï¼Œé™ä½ GC: pause=%d, stepmul=%d",
                  avg_fps, self.current_pause, self.current_stepmul))
        end
    end
end

-- ä½¿ç”¨
function game_loop()
    while true do
        update_game()
        render_game()
        GCAdapter:update()
        sleep(1/60)  -- 60 FPS
    end
end
```

#### C å±‚è‡ªé€‚åº”å®ç°

```c
/* adaptive_gc.c */
typedef struct {
    double target_memory_mb;
    double target_frame_ms;
    
    int current_pause;
    int current_stepmul;
    
    double frame_times[60];
    int frame_index;
    int frame_count;
} AdaptiveGC;

void adaptive_gc_init(AdaptiveGC *gc, double target_mb, double target_ms) {
    gc->target_memory_mb = target_mb;
    gc->target_frame_ms = target_ms;
    gc->current_pause = 200;
    gc->current_stepmul = 200;
    gc->frame_index = 0;
    gc->frame_count = 0;
    memset(gc->frame_times, 0, sizeof(gc->frame_times));
}

void adaptive_gc_update(AdaptiveGC *gc, lua_State *L, double frame_ms) {
    /* è®°å½•å¸§æ—¶é—´ */
    gc->frame_times[gc->frame_index] = frame_ms;
    gc->frame_index = (gc->frame_index + 1) % 60;
    if (gc->frame_count < 60) gc->frame_count++;
    
    /* æ¯ 60 å¸§è°ƒæ•´ä¸€æ¬¡ */
    if (gc->frame_count < 60) return;
    
    /* è®¡ç®—å¹³å‡å¸§æ—¶é—´ */
    double total_ms = 0;
    for (int i = 0; i < 60; i++) {
        total_ms += gc->frame_times[i];
    }
    double avg_frame_ms = total_ms / 60;
    
    /* è·å–å½“å‰å†…å­˜ */
    double memory_mb = lua_gc(L, LUA_GCCOUNT, 0) / 1024.0;
    
    /* å†³ç­– */
    if (memory_mb > gc->target_memory_mb) {
        /* å†…å­˜è¿‡é«˜ */
        gc->current_stepmul = (gc->current_stepmul < 400) ? 
                              gc->current_stepmul + 20 : 400;
        gc->current_pause = (gc->current_pause > 100) ? 
                            gc->current_pause - 10 : 100;
        
        lua_gc(L, LUA_GCSETPAUSE, gc->current_pause);
        lua_gc(L, LUA_GCSETSTEPMUL, gc->current_stepmul);
        
        printf("å†…å­˜è¿‡é«˜ %.1f MB -> pause=%d, stepmul=%d\n",
               memory_mb, gc->current_pause, gc->current_stepmul);
               
    } else if (avg_frame_ms > gc->target_frame_ms * 1.1) {
        /* å¸§ç‡è¿‡ä½ */
        gc->current_stepmul = (gc->current_stepmul > 100) ? 
                              gc->current_stepmul - 20 : 100;
        gc->current_pause = (gc->current_pause < 500) ? 
                            gc->current_pause + 10 : 500;
        
        lua_gc(L, LUA_GCSETPAUSE, gc->current_pause);
        lua_gc(L, LUA_GCSETSTEPMUL, gc->current_stepmul);
        
        printf("å¸§æ—¶è¿‡é•¿ %.2f ms -> pause=%d, stepmul=%d\n",
               avg_frame_ms, gc->current_pause, gc->current_stepmul);
    }
    
    /* é‡ç½®è®¡æ•° */
    gc->frame_count = 0;
}
```

---

## å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 9.1 é«˜é¢‘åˆ†é…ä¼˜åŒ–ï¼ˆæ¸¸æˆå¼•æ“ï¼‰

#### é—®é¢˜åœºæ™¯

```lua
-- æ¸¸æˆä¸»å¾ªç¯
function game_update(dt)
    for _, entity in ipairs(entities) do
        -- æ¯å¸§åˆ›å»ºä¸´æ—¶å‘é‡ï¼ˆ60 FPS * 1000 å®ä½“ = 60000 æ¬¡åˆ†é…/ç§’ï¼‰
        local velocity = Vector3.new(entity.vx, entity.vy, entity.vz)
        local position = Vector3.new(entity.x, entity.y, entity.z)
        
        -- ç‰©ç†è®¡ç®—
        position = position + velocity * dt
        
        entity.x = position.x
        entity.y = position.y
        entity.z = position.z
    end
end
```

**æ€§èƒ½é—®é¢˜ï¼š**
```
å†…å­˜åˆ†é…: 60000 æ¬¡/ç§’
GC å‹åŠ›: æé«˜
å¸§ç‡: 25 FPSï¼ˆç›®æ ‡ 60 FPSï¼‰
```

#### è§£å†³æ–¹æ¡ˆ 1ï¼šå¯¹è±¡æ± 

```lua
-- å‘é‡å¯¹è±¡æ± 
local Vector3Pool = {
    pool = {},
    used = 0,
}

function Vector3Pool:get(x, y, z)
    local v
    if #self.pool > 0 then
        v = table.remove(self.pool)
        v.x, v.y, v.z = x, y, z
    else
        v = {x=x, y=y, z=z}
    end
    self.used = self.used + 1
    return v
end

function Vector3Pool:release(v)
    table.insert(self.pool, v)
    self.used = self.used - 1
end

-- ä¼˜åŒ–åçš„æ›´æ–°
function game_update_optimized(dt)
    for _, entity in ipairs(entities) do
        local velocity = Vector3Pool:get(entity.vx, entity.vy, entity.vz)
        local position = Vector3Pool:get(entity.x, entity.y, entity.z)
        
        -- ç‰©ç†è®¡ç®—
        position.x = position.x + velocity.x * dt
        position.y = position.y + velocity.y * dt
        position.z = position.z + velocity.z * dt
        
        entity.x = position.x
        entity.y = position.y
        entity.z = position.z
        
        -- å½’è¿˜æ± 
        Vector3Pool:release(velocity)
        Vector3Pool:release(position)
    end
end
```

**æ•ˆæœï¼š**
```
å†…å­˜åˆ†é…: 0 æ¬¡/ç§’ï¼ˆç¨³æ€ï¼‰
GC å‹åŠ›: æä½
å¸§ç‡: 58 FPS
æ€§èƒ½æå‡: 2.3 å€
```

---

#### è§£å†³æ–¹æ¡ˆ 2ï¼šåŸåœ°ä¿®æ”¹

```lua
-- ä¸ºå®ä½“æ·»åŠ å¯å¤ç”¨çš„ä¸´æ—¶å˜é‡
for _, entity in ipairs(entities) do
    entity.temp_velocity = {x=0, y=0, z=0}
    entity.temp_position = {x=0, y=0, z=0}
end

function game_update_inplace(dt)
    for _, entity in ipairs(entities) do
        local vel = entity.temp_velocity
        local pos = entity.temp_position
        
        -- å¤ç”¨ï¼Œä¸åˆ†é…
        vel.x, vel.y, vel.z = entity.vx, entity.vy, entity.vz
        pos.x, pos.y, pos.z = entity.x, entity.y, entity.z
        
        -- ç‰©ç†è®¡ç®—
        pos.x = pos.x + vel.x * dt
        pos.y = pos.y + vel.y * dt
        pos.z = pos.z + vel.z * dt
        
        entity.x = pos.x
        entity.y = pos.y
        entity.z = pos.z
    end
end
```

**æ•ˆæœï¼š**
```
å†…å­˜åˆ†é…: 0 æ¬¡/ç§’
GC å‹åŠ›: æ— 
å¸§ç‡: 60 FPS
æ€§èƒ½æå‡: 2.4 å€
ä»£ç ç®€æ´: æ›´å¥½
```

---

### 9.2 å¤§å¯¹è±¡ç®¡ç†ï¼ˆæœåŠ¡å™¨ï¼‰

#### é—®é¢˜åœºæ™¯

```lua
-- HTTP æœåŠ¡å™¨å¤„ç†å¤§è¯·æ±‚
function handle_request(request)
    -- è¯»å– 10MB çš„ JSON æ•°æ®
    local body = request:read_body()  -- 10MB å­—ç¬¦ä¸²
    local data = json.decode(body)    -- 10MB table
    
    -- å¤„ç†
    process_data(data)
    
    -- å“åº”
    local response = json.encode(result)  -- 5MB å­—ç¬¦ä¸²
    return response
end

-- é«˜å¹¶å‘ä¸‹ï¼ˆ100 è¯·æ±‚/ç§’ï¼‰ï¼š
-- å†…å­˜åˆ†é…: 2.5 GB/ç§’
-- Emergency GC: é¢‘ç¹è§¦å‘
-- å“åº”å»¶è¿Ÿ: 50-500msï¼ˆä¸ç¨³å®šï¼‰
```

#### è§£å†³æ–¹æ¡ˆï¼šæµå¼å¤„ç†

```lua
-- æµå¼ JSON è§£æå™¨
local StreamingJSON = {}

function StreamingJSON:parse_chunk(chunk)
    -- å¢é‡è§£æï¼Œä¸ä¿å­˜å®Œæ•´å­—ç¬¦ä¸²
    local objects = {}
    
    for line in chunk:gmatch("[^\n]+") do
        local obj = json.decode_line(line)  -- å°å¯¹è±¡
        table.insert(objects, obj)
    end
    
    return objects
end

function handle_request_streaming(request)
    local results = {}
    
    -- åˆ†å—è¯»å–å’Œå¤„ç†
    while true do
        local chunk = request:read_chunk(64 * 1024)  -- 64KB å—
        if not chunk then break end
        
        local objects = StreamingJSON:parse_chunk(chunk)
        
        for _, obj in ipairs(objects) do
            local result = process_object(obj)
            table.insert(results, result)
        end
        
        -- ä¸»åŠ¨è§¦å‘ GCï¼ˆå¯é€‰ï¼‰
        if #results % 100 == 0 then
            collectgarbage("step", 100)
        end
    end
    
    -- æµå¼è¾“å‡º
    return stream_json_encode(results)
end
```

**æ•ˆæœï¼š**
```
å†…å­˜å³°å€¼: 50MBï¼ˆé™ä½ 98%ï¼‰
Emergency GC: æ— 
å“åº”å»¶è¿Ÿ: 10-15msï¼ˆç¨³å®šï¼‰
ååé‡: æå‡ 3.5 å€
```

---

### 9.3 å®æ—¶ç³»ç»Ÿ GC è°ƒä¼˜ï¼ˆéŸ³é¢‘å¤„ç†ï¼‰

#### é—®é¢˜åœºæ™¯

```lua
-- éŸ³é¢‘å›è°ƒï¼ˆæ¯ 5ms è°ƒç”¨ä¸€æ¬¡ï¼‰
function audio_callback(buffer, frames)
    for i = 1, frames do
        -- ç”ŸæˆéŸ³é¢‘æ ·æœ¬
        local sample = generate_sample()  -- åˆ†é…å†…å­˜ï¼
        buffer[i] = sample
    end
end

-- é—®é¢˜ï¼š
-- å›è°ƒé—´éš”: 5ms
-- GC æš‚åœ: 10-50msï¼ˆè¶…æ—¶ï¼ï¼‰
-- ç»“æœ: éŸ³é¢‘çˆ†éŸ³ã€å¡é¡¿
```

#### è§£å†³æ–¹æ¡ˆï¼šé¢„åˆ†é… + æ‰‹åŠ¨ GC

```lua
-- é¢„åˆ†é…æ‰€æœ‰éŸ³é¢‘ç¼“å†²åŒº
local AudioEngine = {
    sample_pool = {},
    pool_size = 10000,
}

function AudioEngine:init()
    -- é¢„åˆ†é…
    for i = 1, self.pool_size do
        self.sample_pool[i] = {value = 0, time = 0}
    end
    
    -- ç¦ç”¨è‡ªåŠ¨ GC
    collectgarbage("stop")
end

function AudioEngine:audio_callback(buffer, frames)
    -- æ— åˆ†é…å›è°ƒ
    for i = 1, frames do
        local sample = self.sample_pool[i]
        sample.value = self:generate_value()
        sample.time = self:get_time()
        
        buffer[i] = sample.value
    end
end

-- åœ¨éå®æ—¶çº¿ç¨‹ä¸­æ‰‹åŠ¨ GC
function AudioEngine:maintenance_thread()
    while true do
        sleep(0.1)  -- 100ms
        
        -- æ§åˆ¶ GC æ—¶é—´ç‰‡
        local start = os.clock()
        while os.clock() - start < 0.005 do  -- 5ms é™åˆ¶
            if collectgarbage("step", 1) then
                break
            end
        end
    end
end
```

**æ•ˆæœï¼š**
```
å›è°ƒå»¶è¿Ÿ: < 1msï¼ˆç¨³å®šï¼‰
GC æš‚åœ: 0msï¼ˆå›è°ƒçº¿ç¨‹ï¼‰
éŸ³é¢‘è´¨é‡: å®Œç¾
CPU å ç”¨: é™ä½ 40%
```

---

### 9.4 å†…å­˜æ³„æ¼è¯Šæ–­

#### æ³„æ¼æ£€æµ‹å·¥å…·

```lua
-- memory_profiler.lua
local MemoryProfiler = {
    snapshots = {},
    type_counts = {},
}

function MemoryProfiler:take_snapshot(name)
    collectgarbage("collect")  -- å…ˆ GC
    
    local snapshot = {
        name = name,
        memory_kb = collectgarbage("count"),
        objects = {},
    }
    
    -- ç»Ÿè®¡å¯¹è±¡ç±»å‹
    local counts = {}
    for k, v in pairs(_G) do
        local t = type(v)
        counts[t] = (counts[t] or 0) + 1
    end
    
    snapshot.type_counts = counts
    table.insert(self.snapshots, snapshot)
    
    return snapshot
end

function MemoryProfiler:compare(name1, name2)
    local snap1, snap2
    
    for _, s in ipairs(self.snapshots) do
        if s.name == name1 then snap1 = s end
        if s.name == name2 then snap2 = s end
    end
    
    if not snap1 or not snap2 then
        print("å¿«ç…§æœªæ‰¾åˆ°")
        return
    end
    
    print(string.format("\n=== å†…å­˜å¯¹æ¯”: %s vs %s ===", name1, name2))
    print(string.format("å†…å­˜å˜åŒ–: %.2f KB -> %.2f KB (%.2f KB)",
          snap1.memory_kb, snap2.memory_kb, 
          snap2.memory_kb - snap1.memory_kb))
    
    print("\nå¯¹è±¡æ•°é‡å˜åŒ–:")
    for t, count in pairs(snap2.type_counts) do
        local old_count = snap1.type_counts[t] or 0
        if count ~= old_count then
            print(string.format("  %s: %d -> %d (%+d)",
                  t, old_count, count, count - old_count))
        end
    end
end

-- ä½¿ç”¨ç¤ºä¾‹
MemoryProfiler:take_snapshot("start")

-- æ‰§è¡Œå¯èƒ½æ³„æ¼çš„ä»£ç 
for i = 1, 10000 do
    some_operation()
end

MemoryProfiler:take_snapshot("after_operation")
MemoryProfiler:compare("start", "after_operation")
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```
=== å†…å­˜å¯¹æ¯”: start vs after_operation ===
å†…å­˜å˜åŒ–: 1234.56 KB -> 5678.90 KB (4444.34 KB)

å¯¹è±¡æ•°é‡å˜åŒ–:
  table: 150 -> 10150 (+10000)  â† æ³„æ¼ï¼
  string: 500 -> 600 (+100)
  function: 80 -> 80 (0)
```

#### C å±‚æ³„æ¼æ£€æµ‹

```c
/* leak_detector.c */
#include <lua.h>
#include <lauxlib.h>

typedef struct {
    const void *ptr;
    size_t size;
    const char *type;
    int line;
    const char *file;
} AllocationRecord;

static AllocationRecord *records = NULL;
static size_t record_count = 0;
static size_t record_capacity = 0;

void *tracking_alloc(void *ud, void *ptr, size_t osize, size_t nsize) {
    if (nsize == 0) {
        /* é‡Šæ”¾ */
        free(ptr);
        
        /* ä»è®°å½•ä¸­ç§»é™¤ */
        for (size_t i = 0; i < record_count; i++) {
            if (records[i].ptr == ptr) {
                records[i] = records[--record_count];
                break;
            }
        }
        
        return NULL;
    } else {
        /* åˆ†é…/é‡åˆ†é… */
        void *new_ptr = realloc(ptr, nsize);
        
        /* è®°å½•åˆ†é… */
        if (record_count >= record_capacity) {
            record_capacity = record_capacity ? record_capacity * 2 : 1024;
            records = realloc(records, 
                            record_capacity * sizeof(AllocationRecord));
        }
        
        records[record_count++] = (AllocationRecord){
            .ptr = new_ptr,
            .size = nsize,
            .type = "unknown",  /* éœ€è¦æ›´å¤šä¸Šä¸‹æ–‡ */
            .line = -1,
            .file = "unknown"
        };
        
        return new_ptr;
    }
}

void print_leak_report() {
    printf("\n=== å†…å­˜æ³„æ¼æŠ¥å‘Š ===\n");
    printf("æœªé‡Šæ”¾åˆ†é…: %zu ä¸ª\n", record_count);
    printf("æ€»æ³„æ¼: %zu å­—èŠ‚\n\n", total_leaked_bytes());
    
    /* æŒ‰å¤§å°æ’åº */
    qsort(records, record_count, sizeof(AllocationRecord), compare_size);
    
    printf("%-10s %-15s %-20s %s\n", "Size", "Type", "File", "Line");
    printf("--------------------------------------------------------\n");
    
    for (size_t i = 0; i < record_count && i < 20; i++) {
        printf("%-10zu %-15s %-20s %d\n",
               records[i].size,
               records[i].type,
               records[i].file,
               records[i].line);
    }
}

/* ä½¿ç”¨ */
lua_State *L = lua_newstate(tracking_alloc, NULL);
/* ... è¿è¡Œä»£ç  ... */
lua_close(L);
print_leak_report();
```

---

## é™„å½•

### 10.1 å®Œæ•´æºç å‚è€ƒ

#### å…³é”®æ–‡ä»¶

**1. lmem.c/lmem.h - å†…å­˜ç®¡ç†**
```c
/* lmem.h - æ ¸å¿ƒå‡½æ•° */
void *luaM_realloc_ (lua_State *L, void *block, 
                     size_t oldsize, size_t newsize);

#define luaM_reallocv(L,b,on,n,e) \
    ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? \
     luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : \
     luaM_toobig(L))

#define luaM_freemem(L, b, s)  luaM_realloc_(L, (b), (s), 0)
#define luaM_free(L, b)        luaM_realloc_(L, (b), sizeof(*(b)), 0)
#define luaM_freearray(L, b, n, t) \
    luaM_reallocv(L, (b), n, 0, sizeof(t))

#define luaM_malloc(L,t)  luaM_realloc_(L, NULL, 0, (t))
#define luaM_new(L,t)     cast(t *, luaM_malloc(L, sizeof(t)))
#define luaM_newvector(L,n,t) \
    cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

#define luaM_growvector(L,v,nelems,size,t,limit,e) \
    if ((nelems)+1 > (size)) \
      ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
```

**2. lgc.c/lgc.h - åƒåœ¾å›æ”¶**
```c
/* lgc.h - GC å‡½æ•° */
void luaC_step (lua_State *L);
void luaC_fullgc (lua_State *L);
void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
void luaC_linkupval (lua_State *L, UpVal *uv);
void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);
void luaC_barrierback (lua_State *L, Table *t);

/* GC çŠ¶æ€ */
#define GCSpropagate    0
#define GCSatomic       1
#define GCSsweepstring  2
#define GCSsweep        3
#define GCSfinalize     4
#define GCSpause        5
```

**3. lstate.h - å…¨å±€çŠ¶æ€**
```c
/* lstate.h - global_State å®Œæ•´å®šä¹‰ */
typedef struct global_State {
    stringtable strt;               /* å­—ç¬¦ä¸²è¡¨ */
    lua_Alloc frealloc;             /* å†…å­˜åˆ†é…å‡½æ•° */
    void *ud;                       /* frealloc ç”¨æˆ·æ•°æ® */
    lu_byte currentwhite;           /* å½“å‰ç™½è‰² */
    lu_byte gcstate;                /* GC çŠ¶æ€ */
    int sweepstrgc;                 /* å­—ç¬¦ä¸²æ‰«æä½ç½® */
    GCObject *rootgc;               /* æ ¹å¯¹è±¡é“¾è¡¨ */
    GCObject **sweepgc;             /* å½“å‰æ‰«æä½ç½® */
    GCObject *gray;                 /* ç°è‰²å¯¹è±¡é“¾è¡¨ */
    GCObject *grayagain;            /* éœ€é‡æ–°æ‰«æçš„å¯¹è±¡ */
    GCObject *weak;                 /* å¼±è¡¨é“¾è¡¨ */
    GCObject *tmudata;              /* æœ‰ finalizer çš„å¯¹è±¡ */
    lu_mem totalbytes;              /* å·²åˆ†é…å­—èŠ‚æ•° */
    lu_mem GCthreshold;             /* GC è§¦å‘é˜ˆå€¼ */
    lu_mem estimate;                /* GC åä¼°è®¡çš„å­˜æ´»å¤§å° */
    lu_mem gcdept;                  /* GC å€ºåŠ¡ */
    int gcpause;                    /* GC æš‚åœå‚æ•° */
    int gcstepmul;                  /* GC æ­¥è¿›å€ç‡ */
    lua_CFunction panic;            /* panic å‡½æ•° */
    TValue l_registry;              /* æ³¨å†Œè¡¨ */
    struct lua_State *mainthread;   /* ä¸»çº¿ç¨‹ */
    UpVal uvhead;                   /* upvalue é“¾è¡¨å¤´ */
    struct Table *mt[NUM_TAGS];     /* å…ƒè¡¨ */
    TString *tmname[TM_N];          /* å…ƒæ–¹æ³•å */
} global_State;
```

---

### 10.2 GC çŠ¶æ€æœºå®Œæ•´å›¾

```mermaid
stateDiagram-v2
    [*] --> GCSpause: åˆå§‹çŠ¶æ€
    
    GCSpause --> GCSpropagate: è§¦å‘ GC<br/>(totalbytes > GCthreshold)
    
    GCSpropagate --> GCSpropagate: æ ‡è®°ç°è‰²å¯¹è±¡<br/>propagatemark()
    GCSpropagate --> GCSatomic: æ ‡è®°å®Œæˆ<br/>(gray == NULL)
    
    GCSatomic --> GCSsweepstring: åŸå­æ­¥éª¤å®Œæˆ<br/>æ ‡è®°å¼±è¡¨ã€finalizer
    
    GCSsweepstring --> GCSsweepstring: æ‰«æå­—ç¬¦ä¸²è¡¨<br/>sweepwholelist()
    GCSsweepstring --> GCSsweep: å­—ç¬¦ä¸²æ‰«æå®Œæˆ
    
    GCSsweep --> GCSsweep: æ‰«æå¯¹è±¡<br/>sweeplist()
    GCSsweep --> GCSfinalize: å¯¹è±¡æ‰«æå®Œæˆ
    
    GCSfinalize --> GCSfinalize: æ‰§è¡Œ finalizer<br/>GCTM()
    GCSfinalize --> GCSpause: Finalizer å®Œæˆ<br/>setthreshold()
    
    GCSpause --> [*]: GC å‘¨æœŸç»“æŸ
    
    note right of GCSpropagate
        å¢é‡æ­¥éª¤
        æ¯æ¬¡åˆ†é…è§¦å‘
        å·¥ä½œé‡ = gcstepmul
    end note
    
    note right of GCSatomic
        åŸå­æ­¥éª¤ï¼ˆä¸å¯ä¸­æ–­ï¼‰
        å¤„ç†å¼±è¡¨
        æ ‡è®° finalizer å¯¹è±¡
    end note
    
    note right of GCSfinalize
        æ‰§è¡Œ __gc å…ƒæ–¹æ³•
        å¯èƒ½å¤æ´»å¯¹è±¡
    end note
```

---

### 10.3 æ€§èƒ½åˆ†æå·¥å…·

#### GC ç›‘æ§è„šæœ¬

```lua
-- gc_monitor.lua
local GCMonitor = {
    enabled = false,
    log_file = nil,
    
    -- ç»Ÿè®¡
    stats = {
        total_collections = 0,
        total_time_ms = 0,
        max_pause_ms = 0,
        min_pause_ms = math.huge,
        
        memory_before = 0,
        memory_after = 0,
        memory_freed = 0,
    }
}

function GCMonitor:start(log_filename)
    self.enabled = true
    self.log_file = io.open(log_filename, "w")
    
    -- è®°å½•åˆå§‹çŠ¶æ€
    self.stats.memory_before = collectgarbage("count")
    
    -- è®¾ç½® debug hookï¼ˆåœ¨ GC å‰åè®°å½•ï¼‰
    debug.sethook(function(event)
        if event == "count" then
            self:on_gc_start()
        end
    end, "", 10000)  -- æ¯ 10000 æ¡æŒ‡ä»¤æ£€æŸ¥ä¸€æ¬¡
    
    print("GC ç›‘æ§å·²å¯åŠ¨ï¼š" .. log_filename)
end

function GCMonitor:on_gc_start()
    if not self.enabled then return end
    
    local before_mem = collectgarbage("count")
    local start_time = os.clock()
    
    -- æ‰§è¡Œ GC
    collectgarbage("collect")
    
    local end_time = os.clock()
    local after_mem = collectgarbage("count")
    
    -- è®¡ç®—ç»Ÿè®¡
    local pause_ms = (end_time - start_time) * 1000
    local freed_kb = before_mem - after_mem
    
    self.stats.total_collections = self.stats.total_collections + 1
    self.stats.total_time_ms = self.stats.total_time_ms + pause_ms
    self.stats.max_pause_ms = math.max(self.stats.max_pause_ms, pause_ms)
    self.stats.min_pause_ms = math.min(self.stats.min_pause_ms, pause_ms)
    self.stats.memory_freed = self.stats.memory_freed + freed_kb
    
    -- è®°å½•æ—¥å¿—
    if self.log_file then
        self.log_file:write(string.format(
            "%.3f,%d,%.2f,%.2f,%.2f\n",
            os.clock(), self.stats.total_collections,
            before_mem, after_mem, pause_ms
        ))
        self.log_file:flush()
    end
end

function GCMonitor:stop()
    self.enabled = false
    debug.sethook()
    
    if self.log_file then
        self.log_file:close()
    end
    
    -- æ‰“å°æŠ¥å‘Š
    self:print_report()
end

function GCMonitor:print_report()
    local s = self.stats
    
    print("\n========== GC ç›‘æ§æŠ¥å‘Š ==========")
    print(string.format("æ€» GC æ¬¡æ•°: %d", s.total_collections))
    print(string.format("æ€» GC æ—¶é—´: %.2f ms", s.total_time_ms))
    print(string.format("å¹³å‡æš‚åœ: %.2f ms", 
          s.total_time_ms / s.total_collections))
    print(string.format("æœ€é•¿æš‚åœ: %.2f ms", s.max_pause_ms))
    print(string.format("æœ€çŸ­æš‚åœ: %.2f ms", s.min_pause_ms))
    print(string.format("æ€»å›æ”¶å†…å­˜: %.2f KB", s.memory_freed))
    print(string.format("å¹³å‡å›æ”¶: %.2f KB/æ¬¡", 
          s.memory_freed / s.total_collections))
    print("=================================\n")
end

-- ä½¿ç”¨ç¤ºä¾‹
GCMonitor:start("gc_log.csv")

-- è¿è¡Œç¨‹åº
for i = 1, 100000 do
    local t = {data = string.rep("x", 100)}
end

GCMonitor:stop()
```

---

### 10.4 å‚è€ƒèµ„æ–™

#### è®ºæ–‡

1. **"Garbage Collection in Lua"** - Roberto Ierusalimschy
   - Lua GC çš„å®˜æ–¹è®¾è®¡æ–‡æ¡£
   - ä¸‰è‰²æ ‡è®°ç®—æ³•è¯¦è§£
   - å¢é‡ GC å®ç°

2. **"Tri-color Marking Algorithm"** - Dijkstra et al.
   - ä¸‰è‰²æ ‡è®°çš„ç†è®ºåŸºç¡€
   - å†™å±éšœæœºåˆ¶

3. **"Generational Garbage Collection"** - Ungar
   - åˆ†ä»£ GC ç†è®ºï¼ˆLua 5.2+ ä½¿ç”¨ï¼‰

#### ä¹¦ç±

1. **"Lua ç¨‹åºè®¾è®¡ï¼ˆç¬¬4ç‰ˆï¼‰"** - Roberto Ierusalimschy
   - Chapter 24: The C API
   - Chapter 27: Memory Management

2. **"åƒåœ¾å›æ”¶çš„ç®—æ³•ä¸å®ç°"** - ä¸­æ‘æˆæ´‹
   - è¯¦ç»†çš„ GC ç®—æ³•ä»‹ç»
   - æ€§èƒ½å¯¹æ¯”å’Œä¼˜åŒ–æŠ€å·§

3. **"ç¼–ç¨‹è¯­è¨€å®ç°æ¨¡å¼"** - Terence Parr
   - å†…å­˜ç®¡ç†å®ç°
   - æ€§èƒ½åˆ†æå·¥å…·

#### åœ¨çº¿èµ„æº

1. **Lua å®˜æ–¹æºç **
   - https://www.lua.org/source/5.1/
   - `lgc.c`, `lmem.c`, `lstate.h`

2. **Lua é‚®ä»¶åˆ—è¡¨**
   - http://lua-users.org/lists/lua-l/
   - æ€§èƒ½ä¼˜åŒ–è®¨è®º

3. **"The Implementation of Lua 5.0"** - è®ºæ–‡
   - http://www.lua.org/doc/jucs05.pdf
   - å®Œæ•´çš„å®ç°è§£æ

---

### 10.5 å¸¸è§é—®é¢˜ (FAQ)

#### Q1: å¦‚ä½•ç¦ç”¨ GCï¼Ÿ

```lua
collectgarbage("stop")
-- æ‰§è¡Œå…³é”®ä»£ç 
critical_operation()
collectgarbage("restart")
```

**æ³¨æ„ï¼š** é•¿æ—¶é—´ç¦ç”¨ GC ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ï¼

---

#### Q2: GC èƒ½å›æ”¶ C åˆ†é…çš„å†…å­˜å—ï¼Ÿ

**ä¸èƒ½ï¼** GC åªç®¡ç† Lua å¯¹è±¡ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
```c
/* ä½¿ç”¨ userdata + __gc */
static int create_resource(lua_State *L) {
    void **ptr = lua_newuserdata(L, sizeof(void*));
    *ptr = malloc(1024);  /* C åˆ†é… */
    
    /* è®¾ç½® finalizer */
    luaL_getmetatable(L, "MyResource");
    lua_setmetatable(L, -2);
    
    return 1;
}

static int resource_gc(lua_State *L) {
    void **ptr = lua_touserdata(L, 1);
    free(*ptr);  /* é‡Šæ”¾ C å†…å­˜ */
    return 0;
}
```

---

#### Q3: ä¸ºä»€ä¹ˆ collectgarbage("collect") åå†…å­˜æ²¡å‡å°‘ï¼Ÿ

**å¯èƒ½åŸå› ï¼š**
1. **å¯¹è±¡ä»æœ‰å¼•ç”¨**ï¼ˆæœªçœŸæ­£æˆä¸ºåƒåœ¾ï¼‰
2. **å†…å­˜ç¢ç‰‡**ï¼ˆæ“ä½œç³»ç»Ÿæœªå›æ”¶ï¼‰
3. **å­—ç¬¦ä¸²å†…éƒ¨åŒ–**ï¼ˆå­—ç¬¦ä¸²æ°¸ä¹…ä¿å­˜ï¼‰
4. **Lua å†…éƒ¨ç¼“å­˜**ï¼ˆæ ˆã€å­—ç¬¦ä¸²è¡¨ï¼‰

**è¯Šæ–­ï¼š**
```lua
print("Before:", collectgarbage("count"))
collectgarbage("collect")
print("After:", collectgarbage("count"))

-- é‡å¤ä¸¤æ¬¡
collectgarbage("collect")
print("After 2nd:", collectgarbage("count"))
```

---

#### Q4: å¦‚ä½•é€‰æ‹© gcpause å’Œ gcstepmulï¼Ÿ

**è§„åˆ™ï¼š**
```
å†…å­˜æ•æ„Ÿï¼šgcpauseâ†“ + gcstepmulâ†‘
æ€§èƒ½æ•æ„Ÿï¼šgcpauseâ†‘ + gcstepmulâ†“
å¹³è¡¡ï¼š    é»˜è®¤å€¼ 200/200
```

**æ¨èå€¼ï¼š**
```lua
-- åµŒå…¥å¼è®¾å¤‡ï¼ˆRAM < 1MBï¼‰
collectgarbage("setpause", 100)
collectgarbage("setstepmul", 400)

-- æ¸¸æˆï¼ˆRAM > 1GBï¼‰
collectgarbage("setpause", 500)
collectgarbage("setstepmul", 100)

-- æœåŠ¡å™¨ï¼ˆRAM > 8GBï¼‰
collectgarbage("setpause", 1000)
collectgarbage("setstepmul", 50)
```

---

#### Q5: å¦‚ä½•åˆ†æ GC æ€§èƒ½ç“¶é¢ˆï¼Ÿ

**å·¥å…·é“¾ï¼š**
```lua
-- 1. å†…ç½®åˆ†æ
collectgarbage("count")     -- å½“å‰å†…å­˜
collectgarbage("collect")   -- æ‰‹åŠ¨ GC

-- 2. è‡ªå®šä¹‰ç›‘æ§
local start = os.clock()
collectgarbage("collect")
local elapsed = os.clock() - start
print("GC time:", elapsed * 1000, "ms")

-- 3. C å±‚ profiling
/* ä½¿ç”¨ gprof, valgrind, perf */
```

---

#### Q6: Lua 5.1 vs 5.2+ çš„ GC åŒºåˆ«ï¼Ÿ

| ç‰¹æ€§             | Lua 5.1        | Lua 5.2+         |
|------------------|----------------|------------------|
| GC ç®—æ³•          | å¢é‡æ ‡è®°æ¸…é™¤   | åˆ†ä»£ GC          |
| ç´§æ€¥ GC          | æœ‰             | ä¼˜åŒ–             |
| å¼±è¡¨å¤„ç†         | åŸå­é˜¶æ®µ       | æ”¹è¿›             |
| Finalizer é¡ºåº   | ä¸ç¡®å®š         | æ”¹è¿›ï¼ˆæœ‰åºï¼‰     |
| æ€§èƒ½             | è‰¯å¥½           | æ›´å¥½             |

---

### 10.6 å®Œæ•´ç¼–è¯‘ç¤ºä¾‹

```bash
# ç¼–è¯‘ Lua 5.1 with è°ƒè¯•ä¿¡æ¯
git clone https://github.com/lua/lua.git
cd lua
git checkout v5.1.5

# ä¿®æ”¹ Makefile æ·»åŠ è°ƒè¯•ç¬¦å·
sed -i 's/CFLAGS= -O2/CFLAGS= -O0 -g/' src/Makefile

# ç¼–è¯‘
make linux

# è¿è¡Œæµ‹è¯•
./src/lua test_gc.lua

# ä½¿ç”¨ gdb è°ƒè¯•
gdb ./src/lua
(gdb) break luaM_realloc_
(gdb) run test_gc.lua
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢ä»‹ç»äº† Lua 5.1 ä¸­å†…å­˜ç®¡ç†ä¸ GC çš„äº¤äº’æœºåˆ¶ï¼Œæ¶µç›–ï¼š

1. **æ ¸å¿ƒæ¶æ„**ï¼štotalbytesã€GCthresholdã€å¢é‡ GC
2. **GC çŠ¶æ€æœº**ï¼š5 ä¸ªçŠ¶æ€åŠè½¬æ¢
3. **å†…å­˜å‹åŠ›**ï¼šEmergency GCã€ä¸¤é˜¶æ®µé‡è¯•
4. **Finalizer**ï¼š__gc å…ƒæ–¹æ³•ã€å¤æ´»æœºåˆ¶
5. **å¼±è¡¨**ï¼šä¸‰ç§æ¨¡å¼ã€å†…å­˜ä¼˜åŒ–
6. **å­—ç¬¦ä¸²**ï¼šå†…éƒ¨åŒ–ã€GC å¤„ç†
7. **å‚æ•°è°ƒä¼˜**ï¼šgcpauseã€gcstepmulã€åœºæ™¯ç­–ç•¥
8. **å®æˆ˜æ¡ˆä¾‹**ï¼šæ¸¸æˆã€æœåŠ¡å™¨ã€å®æ—¶ç³»ç»Ÿ
9. **å·¥å…·**ï¼šç›‘æ§è„šæœ¬ã€æ€§èƒ½åˆ†æã€æ³„æ¼æ£€æµ‹

**å…³é”®è¦ç‚¹ï¼š**
- GC ä¸å†…å­˜åˆ†é…ç´§å¯†è€¦åˆ
- å¢é‡ GC ä¿è¯å®æ—¶æ€§
- å‚æ•°è°ƒä¼˜éœ€æƒè¡¡å†…å­˜/æ€§èƒ½
- ç†è§£å†…éƒ¨æœºåˆ¶æ‰èƒ½ä¼˜åŒ–åº”ç”¨

**è¿›ä¸€æ­¥å­¦ä¹ ï¼š**
- é˜…è¯» `lgc.c` å®Œæ•´æºç 
- å®ç°è‡ªå®šä¹‰åˆ†é…å™¨
- åˆ†æå®é™…é¡¹ç›®çš„ GC è¡Œä¸º

---

**æ–‡æ¡£å®Œæˆï¼** å…¨æ–‡çº¦ 3000+ è¡Œï¼Œæ¶µç›– Lua 5.1 å†…å­˜ç®¡ç†ä¸ GC äº¤äº’çš„æ–¹æ–¹é¢é¢ã€‚

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä½œè€… | è¯´æ˜                 |
|------|------------|------|----------------------|
| 1.0  | 2025-01-15 | AI   | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæ•´æ–‡æ¡£   |

---

**License:** MIT  
**Lua Version:** 5.1.5  
**Last Updated:** 2025-01-15