# ğŸ“š Lua æ ˆç®¡ç†æœºåˆ¶è¯¦è§£

> **DeepWiki æ·±åº¦æŠ€æœ¯æ–‡æ¡£**  
> éš¾åº¦ç­‰çº§ï¼šâ­â­â­â­â­ (ä¸“å®¶çº§)  
> é¢„è®¡é˜…è¯»æ—¶é—´ï¼š30-35 åˆ†é’Ÿ  
> å…ˆä¿®çŸ¥è¯†ï¼šC è¯­è¨€ã€åŠ¨æ€æ•°ç»„ã€æŒ‡é’ˆæ“ä½œ

<div align="center">

**åŠ¨æ€å¢é•¿ Â· æŒ‡é’ˆè°ƒæ•´ Â· å†…å­˜å®‰å…¨ Â· æ€§èƒ½ä¼˜åŒ–**

[ğŸ“– æ ¸å¿ƒæ¦‚å¿µ](#-æ ¸å¿ƒæ¦‚å¿µ) Â· [ğŸ”§ å®ç°æœºåˆ¶](#-å®ç°æœºåˆ¶) Â· [âš¡ æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ) Â· [ğŸ’¡ è®¾è®¡æƒè¡¡](#-è®¾è®¡æƒè¡¡)

</div>

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

### å­¦ä¹ ç›®æ ‡

å­¦å®Œæœ¬æ–‡æ¡£åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… **ç†è§£ Lua æ ˆçš„ç‰©ç†ç»“æ„**å’Œå†…å­˜å¸ƒå±€
- âœ… **æŒæ¡åŒå€å¢é•¿ç­–ç•¥**çš„åŸç†å’Œä¼˜åŠ¿
- âœ… **ç†è§£æŒ‡é’ˆè°ƒæ•´ç®—æ³•**çš„å¿…è¦æ€§å’Œå®ç°
- âœ… **åˆ†ææ ˆç®¡ç†çš„æ€§èƒ½ç‰¹å¾**å’Œä¼˜åŒ–æŠ€å·§
- âœ… **åœ¨ C API ä¸­æ­£ç¡®ç®¡ç†æ ˆç©ºé—´**

### æ ¸å¿ƒé—®é¢˜

æœ¬æ–‡æ¡£å°†å›ç­”ä»¥ä¸‹å…³é”®é—®é¢˜ï¼š

1. **ä¸ºä»€ä¹ˆéœ€è¦åŠ¨æ€æ ˆï¼Ÿ** Lua å¦‚ä½•å¹³è¡¡çµæ´»æ€§å’Œæ€§èƒ½ï¼Ÿ
2. **åŒå€å¢é•¿ç­–ç•¥å¦‚ä½•å·¥ä½œï¼Ÿ** ä¸ºä»€ä¹ˆä¸æ˜¯å›ºå®šå¢é•¿æˆ– 1.5 å€ï¼Ÿ
3. **æŒ‡é’ˆè°ƒæ•´ä¸ºä»€ä¹ˆå¤æ‚ï¼Ÿ** å“ªäº›æŒ‡é’ˆéœ€è¦è°ƒæ•´ï¼Ÿå¦‚ä½•é¿å…é—æ¼ï¼Ÿ
4. **å¦‚ä½•ä¿è¯å†…å­˜å®‰å…¨ï¼Ÿ** æ ˆæº¢å‡ºæ£€æŸ¥çš„æ—¶æœºå’Œç­–ç•¥æ˜¯ä»€ä¹ˆï¼Ÿ
5. **æ€§èƒ½ç“¶é¢ˆåœ¨å“ªé‡Œï¼Ÿ** å¦‚ä½•ä¼˜åŒ–æ ˆæ“ä½œï¼Ÿ

### æ–‡æ¡£ç»“æ„

```mermaid
graph TB
    A[æ ˆç®¡ç†æ¦‚è¿°] --> B[æ ¸å¿ƒæ¦‚å¿µ]
    B --> C[æ•°æ®ç»“æ„]
    B --> D[å¢é•¿ç­–ç•¥]
    B --> E[æŒ‡é’ˆè°ƒæ•´]
    
    C --> F[å®ç°æœºåˆ¶]
    D --> F
    E --> F
    
    F --> G[æ€§èƒ½åˆ†æ]
    G --> H[è®¾è®¡æƒè¡¡]
    H --> I[æœ€ä½³å®è·µ]
    
    style A fill:#4ecdc4
    style B fill:#f9ca24
    style F fill:#6c5ce7
    style G fill:#ff6b6b
```

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. Lua æ ˆçš„æœ¬è´¨

#### ä»€ä¹ˆæ˜¯ Lua æ ˆï¼Ÿ

Lua æ ˆæ˜¯ä¸€ä¸ª**åŠ¨æ€å¢é•¿çš„æ•°ç»„**ï¼Œç”¨äºå­˜å‚¨ï¼š
- å‡½æ•°å‚æ•°å’Œè¿”å›å€¼
- å±€éƒ¨å˜é‡
- ä¸´æ—¶è®¡ç®—ç»“æœ
- å‡½æ•°è°ƒç”¨å¸§

```
Lua æ ˆçš„ç‰©ç†è§†å›¾ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¿ç»­çš„ TValue æ•°ç»„ (åŠ¨æ€å¤§å°)      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ V1 â”‚ V2 â”‚ V3 â”‚ V4 â”‚... â”‚ Vn â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜    â”‚
â”‚  ^                         ^         â”‚
â”‚  stack                     stack+sizeâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¯ä¸ªæ§½ä½ (TValue) å¤§å°ï¼š16 å­—èŠ‚
- 8 å­—èŠ‚ Value (è”åˆä½“)
- 4 å­—èŠ‚ ç±»å‹æ ‡è®°
- 4 å­—èŠ‚ å¯¹é½/ä¿ç•™
```

#### æ ˆ vs å †

| ç‰¹æ€§ | Lua æ ˆ | Lua å † |
|------|--------|--------|
| **ç”¨é€”** | ä¸´æ—¶å€¼ã€å±€éƒ¨å˜é‡ | æŒä¹…å¯¹è±¡ |
| **ç®¡ç†** | è‡ªåŠ¨ï¼ˆæ ˆæŒ‡é’ˆï¼‰ | GC ç®¡ç† |
| **å¤§å°** | åŠ¨æ€å¯å˜ | åŠ¨æ€å¯å˜ |
| **åˆ†é…** | O(1) æŒ‡é’ˆç§»åŠ¨ | O(1) å†…å­˜æ±  |
| **è®¿é—®** | ç›´æ¥ç´¢å¼• | é€šè¿‡å¼•ç”¨ |
| **ç”Ÿå‘½å‘¨æœŸ** | å‡½æ•°ä½œç”¨åŸŸ | å¯¹è±¡å¼•ç”¨è®¡æ•° |

#### æ ˆçš„é€»è¾‘ç»“æ„

```mermaid
graph TB
    subgraph "Lua æ ˆçš„é€»è¾‘åˆ†å±‚"
        A[æ ˆåº• stack] 
        A --> B[ä¸»å‡½æ•°æ ˆå¸§]
        B --> C[å‡½æ•°Aæ ˆå¸§]
        C --> D[å‡½æ•°Bæ ˆå¸§]
        D --> E[å½“å‰æ ˆé¡¶ top]
        E --> F[å¯ç”¨ç©ºé—´]
        F --> G[æ ˆæœ«å°¾ stack_last]
        G --> H[ä¿æŠ¤åŒº EXTRA_STACK]
    end
    
    style A fill:#4ecdc4
    style E fill:#f9ca24
    style G fill:#ff6b6b
    style H fill:#6c5ce7
```

---

### 2. æ ¸å¿ƒæ•°æ®ç»“æ„

#### lua_State ä¸­çš„æ ˆç›¸å…³å­—æ®µ

```c
// lstate.h: lua_State æ ˆç®¡ç†å­—æ®µ
struct lua_State {
    CommonHeader;
    
    // ===== æ ˆæŒ‡é’ˆ (æœ€å¸¸ç”¨) =====
    StkId top;              // å½“å‰æ ˆé¡¶ï¼ˆä¸‹ä¸€ä¸ªå¯ç”¨ä½ç½®ï¼‰
    StkId base;             // å½“å‰å‡½æ•°æ ˆå¸§åŸºå€
    
    // ===== æ ˆè¾¹ç•Œ =====
    StkId stack;            // æ ˆåº•ï¼ˆå›ºå®šï¼‰
    StkId stack_last;       // å¯ç”¨ç©ºé—´æœ«å°¾ï¼ˆä¸å«EXTRA_STACKï¼‰
    
    // ===== æ ˆå¤§å° =====
    int stacksize;          // å½“å‰æ ˆæ€»å¤§å°ï¼ˆæ§½ä½æ•°ï¼‰
    
    // ===== å…¶ä»–å­—æ®µ =====
    global_State *l_G;      // å…¨å±€çŠ¶æ€
    CallInfo *ci;           // å½“å‰è°ƒç”¨ä¿¡æ¯
    // ... æ›´å¤šå­—æ®µ
};

// ç±»å‹å®šä¹‰
typedef TValue *StkId;      // æ ˆç´¢å¼•ï¼ˆæŒ‡å‘ TValue çš„æŒ‡é’ˆï¼‰

// TValue: Lua å€¼çš„ç»Ÿä¸€è¡¨ç¤º
typedef struct lua_TValue {
    Value value;            // 8 å­—èŠ‚ï¼šå®é™…å€¼ï¼ˆè”åˆä½“ï¼‰
    int tt;                 // 4 å­—èŠ‚ï¼šç±»å‹æ ‡è®°
} TValue;
```

#### æ ˆæŒ‡é’ˆå…³ç³»å›¾

```
å†…å­˜å¸ƒå±€ï¼ˆä»ä½åœ°å€åˆ°é«˜åœ°å€ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®Œæ•´æ ˆç©ºé—´                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚          å¯ç”¨ç©ºé—´                    â”‚           â”‚
â”‚  â”‚  (stacksize ä¸ª TValue)              â”‚           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚           â”‚
â”‚  â”‚  â”‚   å·²ä½¿ç”¨ç©ºé—´           â”‚          â”‚           â”‚
â”‚  â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚          â”‚           â”‚
â”‚  â”‚  â”‚   â”‚ å½“å‰å¸§  â”‚         â”‚          â”‚           â”‚
â”‚  â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚          â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚  ^           ^        ^                ^           ^â”‚
â”‚  stack       base     top        stack_last      endâ”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â””â”€â”€â”€â”€â”€â”€â”˜
                                              EXTRA_STACK
                                              (ä¿æŠ¤åŒº)

å…³é”®ä¸å˜å¼ï¼š
1. stack <= base <= top <= stack_last
2. stack_last = stack + stacksize - EXTRA_STACK
3. EXTRA_STACK = 5 (å›ºå®šå®‰å…¨è¾¹è·)
```

#### æ ˆå¤§å°å¸¸é‡

```c
// llimits.h: æ ˆå¤§å°é™åˆ¶
#define LUAI_MAXCSTACK  8000      // C è°ƒç”¨æ ˆæœ€å¤§æ·±åº¦
#define LUAI_MAXSTACK   1000000   // Lua æ ˆæœ€å¤§å¤§å°

// lstate.h: æ ˆå¸¸é‡
#define BASIC_STACK_SIZE    (2*LUA_MINSTACK)  // åˆå§‹æ ˆå¤§å° = 40
#define EXTRA_STACK         5                  // é¢å¤–ä¿æŠ¤ç©ºé—´
#define LUA_MINSTACK        20                 // æœ€å°æ ˆç©ºé—´

// åˆå§‹åˆ†é…å¤§å°
#define INITIAL_STACK_SIZE  BASIC_STACK_SIZE  // 40 æ§½ä½
```

---

### 3. åŒå€å¢é•¿ç­–ç•¥

#### ä¸ºä»€ä¹ˆéœ€è¦åŠ¨æ€å¢é•¿ï¼Ÿ

```lua
-- é—®é¢˜åœºæ™¯ï¼šæ ˆç©ºé—´éœ€æ±‚å·®å¼‚å·¨å¤§
function shallow()
    return 1 + 2  -- åªéœ€è¦ 3-4 ä¸ªæ§½ä½
end

function deep_recursion(n)
    if n == 0 then return 0 end
    local a, b, c = n, n*2, n*3  -- æ¯å±‚éœ€è¦å¤šä¸ªå±€éƒ¨å˜é‡
    return a + b + c + deep_recursion(n-1)
end

deep_recursion(1000)  -- éœ€è¦ 1000+ å±‚ï¼Œæ¯å±‚å¤šä¸ªæ§½ä½
```

**å¦‚æœå›ºå®šæ ˆå¤§å°**ï¼š
- å¤ªå°ï¼šé¢‘ç¹æ ˆæº¢å‡º
- å¤ªå¤§ï¼šæµªè´¹å†…å­˜ï¼ˆå¤§å¤šæ•°å‡½æ•°ä¸éœ€è¦ï¼‰

**è§£å†³æ–¹æ¡ˆ**ï¼šåŠ¨æ€å¢é•¿

#### åŒå€å¢é•¿ç®—æ³•

```c
// ldo.c: æ ˆå¢é•¿å…¥å£
void luaD_growstack (lua_State *L, int n) {
    // n: é¢å¤–éœ€è¦çš„æ§½ä½æ•°
    
    if (n <= L->stacksize)  // éœ€æ±‚ä¸å¤§
        luaD_reallocstack(L, 2*L->stacksize);  // åŒå€æ‰©å±•
    else  // éœ€æ±‚å¾ˆå¤§
        luaD_reallocstack(L, L->stacksize + n + EXTRA_STACK);
}
```

#### å¢é•¿è¿‡ç¨‹å¯è§†åŒ–

```mermaid
graph LR
    A[åˆå§‹: 40] --> B[éœ€æ±‚: 35]
    B --> C{35 <= 40?}
    C -->|æ˜¯| D[æ‰©å±•åˆ°: 80]
    
    D --> E[éœ€æ±‚: 70]
    E --> F{70 <= 80?}
    F -->|æ˜¯| G[æ‰©å±•åˆ°: 160]
    
    G --> H[éœ€æ±‚: 200]
    H --> I{200 <= 160?}
    I -->|å¦| J[æ‰©å±•åˆ°: 160 + 200 + 5 = 365]
    
    style A fill:#4ecdc4
    style D fill:#f9ca24
    style G fill:#6c5ce7
    style J fill:#ff6b6b
```

#### å¢é•¿æ¬¡æ•°åˆ†æ

```
åŒå€å¢é•¿çš„é‡åˆ†é…æ¬¡æ•°ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æœ€ç»ˆå¤§å°    é‡åˆ†é…æ¬¡æ•° (logâ‚‚ n)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    40           0                â”‚
â”‚    80           1                â”‚
â”‚   160           2                â”‚
â”‚   320           3                â”‚
â”‚   640           4                â”‚
â”‚  1280           5                â”‚
â”‚  2560           6                â”‚
â”‚  5120           7                â”‚
â”‚ 10240           8                â”‚
â”‚ 1000000        ~15               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¯¹æ¯”å›ºå®šå¢é•¿ (+40)ï¼š
éœ€è¦ 1000000 / 40 = 25000 æ¬¡é‡åˆ†é…ï¼
```

#### åŒå€å¢é•¿çš„ä¼˜åŠ¿

| ç‰¹æ€§ | åŒå€å¢é•¿ | å›ºå®šå¢é•¿ (+N) | 1.5 å€å¢é•¿ |
|------|---------|--------------|-----------|
| **æ—¶é—´å¤æ‚åº¦** | O(n) æ‘Šé”€ | O(nÂ²) | O(n) æ‘Šé”€ |
| **é‡åˆ†é…æ¬¡æ•°** | logâ‚‚ n | n/N | logâ‚.â‚… n |
| **ç©ºé—´æµªè´¹** | æœ€å¤š 50% | ä½ | æœ€å¤š 33% |
| **å®ç°å¤æ‚åº¦** | ç®€å• | ç®€å• | ç®€å• |
| **ç¼“å­˜å‹å¥½åº¦** | é«˜ | ä½ | ä¸­ |

**Lua é€‰æ‹©åŒå€çš„åŸå› **ï¼š
1. âœ… é‡åˆ†é…æ¬¡æ•°æœ€å°‘ï¼ˆå¯¹äºè„šæœ¬è¯­è¨€ï¼ŒCPU > å†…å­˜ï¼‰
2. âœ… å®ç°æœ€ç®€å•ï¼ˆä½è¿ç®—ï¼š`size << 1`ï¼‰
3. âœ… æ€§èƒ½å¯é¢„æµ‹ï¼ˆæ‘Šé”€ O(1) æ’å…¥ï¼‰
4. âš ï¸ å†…å­˜æµªè´¹å¯æ¥å—ï¼ˆè„šæœ¬è¯­è¨€ï¼Œä¸æ˜¯åµŒå…¥å¼ï¼‰

---

### 4. æ ˆæ£€æŸ¥æœºåˆ¶

#### ä½•æ—¶æ£€æŸ¥æ ˆç©ºé—´ï¼Ÿ

```c
// æ£€æŸ¥ç­–ç•¥ï¼šé¢„é˜²æ€§æ£€æŸ¥
void some_function(lua_State *L) {
    // âŒ é”™è¯¯ï¼šå…ˆä½¿ç”¨å†æ£€æŸ¥
    lua_pushnumber(L, 42);
    luaD_checkstack(L, 1);  // å¤ªæ™šäº†ï¼
    
    // âœ… æ­£ç¡®ï¼šå…ˆæ£€æŸ¥å†ä½¿ç”¨
    luaD_checkstack(L, 10);  // ç¡®ä¿æœ‰ 10 ä¸ªæ§½ä½
    for (int i = 0; i < 10; i++) {
        lua_pushnumber(L, i);  // å®‰å…¨
    }
}
```

#### æ ˆæ£€æŸ¥å®å®šä¹‰

```c
// ldo.h: æ ˆæ£€æŸ¥å®
#define luaD_checkstack(L,n) \
    if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) \
        luaD_growstack(L, n); \
    else condhardstacktests(luaD_reallocstack(L, L->stacksize));
```

#### æ£€æŸ¥è¿‡ç¨‹åˆ†è§£

```mermaid
sequenceDiagram
    participant Code as è°ƒç”¨ä»£ç 
    participant Macro as luaD_checkstack
    participant Grow as luaD_growstack
    participant Realloc as luaD_reallocstack
    
    Code->>Macro: checkstack(L, n)
    Macro->>Macro: è®¡ç®—å‰©ä½™ç©ºé—´
    
    alt ç©ºé—´è¶³å¤Ÿ
        Macro->>Code: ç›´æ¥è¿”å›
    else ç©ºé—´ä¸è¶³
        Macro->>Grow: growstack(L, n)
        Grow->>Realloc: reallocstack(L, newsize)
        Realloc->>Realloc: é‡æ–°åˆ†é…å†…å­˜
        Realloc->>Realloc: è°ƒæ•´æ‰€æœ‰æŒ‡é’ˆ
        Realloc->>Grow: å®Œæˆ
        Grow->>Macro: å®Œæˆ
        Macro->>Code: è¿”å›
    end
```

#### æ ˆç©ºé—´è®¡ç®—

```c
// å‰©ä½™ç©ºé—´è®¡ç®—ï¼ˆå­—èŠ‚ï¼‰
ptrdiff_t available_bytes = (char *)L->stack_last - (char *)L->top;

// å‰©ä½™æ§½ä½æ•°
int available_slots = available_bytes / sizeof(TValue);

// éœ€è¦çš„å­—èŠ‚æ•°
int needed_bytes = n * sizeof(TValue);

// æ˜¯å¦éœ€è¦æ‰©å±•ï¼Ÿ
if (available_bytes <= needed_bytes) {
    luaD_growstack(L, n);
}
```

---

### 5. æ ˆç©ºé—´å¸ƒå±€

#### å•å¸§æ ˆå¸ƒå±€

```
å•ä¸ªå‡½æ•°è°ƒç”¨çš„æ ˆå¸§ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â† ci->top (æ ˆé¡¶é™åˆ¶)
â”‚                             â”‚
â”‚  ä¸´æ—¶è®¡ç®—ç©ºé—´                â”‚
â”‚  (è¡¨è¾¾å¼æ±‚å€¼ã€ä¸­é—´ç»“æœ)      â”‚
â”‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† L->top (å½“å‰æ ˆé¡¶)
â”‚  å±€éƒ¨å˜é‡ n                  â”‚
â”‚  å±€éƒ¨å˜é‡ n-1                â”‚
â”‚  ...                        â”‚
â”‚  å±€éƒ¨å˜é‡ 2                  â”‚
â”‚  å±€éƒ¨å˜é‡ 1                  â”‚ â† L->base / ci->base
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‚æ•° n                     â”‚
â”‚  å‚æ•° n-1                   â”‚
â”‚  ...                        â”‚
â”‚  å‚æ•° 2                     â”‚
â”‚  å‚æ•° 1                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‡½æ•°å¯¹è±¡                    â”‚ â† ci->func
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‰ä¸€å¸§çš„æ•°æ®                â”‚
â”‚  ...                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…³é”®æŒ‡é’ˆï¼š
- ci->func: å‡½æ•°å¯¹è±¡ä½ç½®
- ci->base: ç¬¬ä¸€ä¸ªå±€éƒ¨å˜é‡ (å‚æ•°å)
- L->top: å½“å‰ä½¿ç”¨çš„æ ˆé¡¶
- ci->top: å…è®¸çš„æœ€å¤§æ ˆé¡¶
```

#### å¤šå¸§åµŒå¥—å¸ƒå±€

```
å¤šå±‚å‡½æ•°è°ƒç”¨çš„æ ˆï¼š
é«˜åœ°å€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â† stack_last
â”‚  EXTRA_STACK (5 slots)      â”‚   ä¿æŠ¤åŒº
â”œâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”¤ â† stack + stacksize
â”‚                             â”‚
â”‚  ã€å½“å‰å‡½æ•° Cã€‘              â”‚ â† ci (L->ci)
â”‚    top â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    locals              â”‚   â”‚
â”‚    base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    args                â”‚   â”‚
â”‚    func â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã€è°ƒç”¨è€…å‡½æ•° Bã€‘            â”‚ â† ci - 1
â”‚    (å·²ä¿å­˜çŠ¶æ€)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã€è°ƒç”¨è€…å‡½æ•° Aã€‘            â”‚ â† ci - 2
â”‚    (å·²ä¿å­˜çŠ¶æ€)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã€ä¸»å‡½æ•°ã€‘                  â”‚ â† base_ci
â”‚                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â† stack
ä½åœ°å€

æ ˆæ·±åº¦ = (ci - base_ci) + 1
å½“å‰å¸§å¤§å° = top - ci->func
```

#### æ ˆç©ºé—´åˆ†é…ç­–ç•¥

```c
// ldo.c: å‡½æ•°è°ƒç”¨æ—¶çš„æ ˆç©ºé—´è®¡ç®—
int luaD_precall (lua_State *L, StkId func, int nresults) {
    // ...
    Proto *p = cl->p;
    
    // éœ€è¦çš„ç©ºé—´ = å‚æ•° + å±€éƒ¨å˜é‡ + ä¸´æ—¶ç©ºé—´
    int needed = p->maxstacksize;  // ç¼–è¯‘æ—¶è®¡ç®—çš„æœ€å¤§éœ€æ±‚
    
    // æ£€æŸ¥æ ˆç©ºé—´ï¼ˆé¢„å…ˆåˆ†é…ï¼‰
    luaD_checkstack(L, needed);
    
    // è®¾ç½®æ ˆé¡¶é™åˆ¶
    ci->top = L->base + needed;
    // ...
}
```

---

### 6. æ ˆåˆå§‹åŒ–

#### æ–°çº¿ç¨‹æ ˆåˆå§‹åŒ–

```c
// lstate.c: åˆ›å»ºæ–°çº¿ç¨‹æ—¶åˆå§‹åŒ–æ ˆ
static void stack_init (lua_State *L1, lua_State *L) {
    // åˆ†é…æ ˆç©ºé—´
    L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
    L1->stacksize = BASIC_STACK_SIZE;
    L1->top = L1->stack;
    L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
    
    // åˆå§‹åŒ– CallInfo
    L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
    L1->ci = L1->base_ci;
    L1->size_ci = BASIC_CI_SIZE;
    L1->end_ci = L1->base_ci + L1->size_ci - 1;
    
    // è®¾ç½®ç¬¬ä¸€ä¸ª CallInfo
    L1->ci->func = L1->top;
    setnilvalue(L1->top++);  // ä¼ªå‡½æ•°
    L1->base = L1->ci->base = L1->top;
    L1->ci->top = L1->top + LUA_MINSTACK;
}
```

#### åˆå§‹åŒ–åçš„æ ˆçŠ¶æ€

```
æ–°åˆ›å»ºçš„ lua_State æ ˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EXTRA_STACK (5)            â”‚ â† stack + 40
â”œâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”¤ â† stack_last
â”‚                             â”‚
â”‚  å¯ç”¨ç©ºé—´ (19 slots)        â”‚
â”‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† ci->top = stack + 20
â”‚  LUA_MINSTACK (20 slots)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† top = base
â”‚  nil (ä¼ªå‡½æ•°)               â”‚ â† ci->func
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â† stack

stacksize = 40
å®é™…å¯ç”¨ = 40 - 5 = 35
ç¬¬ä¸€å¸§é™åˆ¶ = 20
```

---

### 7. æ ˆå¢é•¿è§¦å‘æ¡ä»¶

#### å¸¸è§è§¦å‘åœºæ™¯

```mermaid
graph TB
    A[æ ˆå¢é•¿è§¦å‘] --> B[å‡½æ•°è°ƒç”¨]
    A --> C[å¤§é‡å±€éƒ¨å˜é‡]
    A --> D[å¯å˜å‚æ•°]
    A --> E[è¡¨æ„é€ ]
    A --> F[C API æ“ä½œ]
    
    B --> G[luaD_precall<br/>æ£€æŸ¥ maxstacksize]
    C --> G
    D --> H[adjust_varargs<br/>å¤åˆ¶å‚æ•°]
    E --> I[OP_SETLIST<br/>æ‰¹é‡èµ‹å€¼]
    F --> J[luaL_checkstack<br/>ç¡®ä¿ç©ºé—´]
    
    style A fill:#ff6b6b
    style G fill:#4ecdc4
    style H fill:#f9ca24
    style I fill:#6c5ce7
    style J fill:#00b894
```

#### è§¦å‘ä»£ç ç¤ºä¾‹

```c
// åœºæ™¯1: å‡½æ•°è°ƒç”¨å‰æ£€æŸ¥
int luaD_precall (lua_State *L, StkId func, int nresults) {
    Proto *p = cl->p;
    luaD_checkstack(L, p->maxstacksize);  // ç¡®ä¿è¶³å¤Ÿç©ºé—´
    // ...
}

// åœºæ™¯2: å¯å˜å‚æ•°å¤„ç†
static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
    int nfixargs = p->numparams;
    luaD_checkstack(L, p->maxstacksize);  // å¯èƒ½éœ€è¦å¤åˆ¶å‚æ•°
    // ...
}

// åœºæ™¯3: C API æ˜¾å¼æ£€æŸ¥
LUA_API int lua_checkstack (lua_State *L, int size) {
    int res = 1;
    lua_lock(L);
    if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)
        res = 0;  // è¶…è¿‡æœ€å¤§é™åˆ¶
    else if (size > 0) {
        luaD_checkstack(L, size);
        if (L->ci->top < L->top + size)
            L->ci->top = L->top + size;  // è°ƒæ•´é™åˆ¶
    }
    lua_unlock(L);
    return res;
}

// åœºæ™¯4: è¡¨æ„é€ 
case OP_SETLIST: {
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    // å¦‚æœæ‰¹é‡èµ‹å€¼æ•°é‡å¤§ï¼Œå¯èƒ½è§¦å‘æ ˆå¢é•¿
    // ï¼ˆè™½ç„¶ç¼–è¯‘å™¨å·²ç»è®¡ç®—äº† maxstacksizeï¼‰
}
```

---

## ğŸ”§ å®ç°æœºåˆ¶

### 1. æ ˆé‡åˆ†é…æ ¸å¿ƒå‡½æ•°

#### luaD_reallocstack å®Œæ•´å®ç°

```c
// ldo.c: æ ˆé‡åˆ†é…ï¼ˆæ ¸å¿ƒå‡½æ•°ï¼‰
static void luaD_reallocstack (lua_State *L, int newsize) {
    TValue *oldstack = L->stack;  // ä¿å­˜æ—§æ ˆåœ°å€ï¼ˆé‡è¦ï¼ï¼‰
    int realsize = newsize + 1 + EXTRA_STACK;
    
    // å®‰å…¨æ£€æŸ¥
    lua_assert(newsize <= LUAI_MAXCSTACK || newsize == ERRORSTACKSIZE);
    lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);
    
    // é‡æ–°åˆ†é…å†…å­˜ï¼ˆå¯èƒ½æ”¹å˜åœ°å€ï¼ï¼‰
    luaM_reallocvector(L, L->stack, L->stacksize, realsize, TValue);
    
    // æ›´æ–°æ ˆå¤§å°
    L->stacksize = newsize;
    L->stack_last = L->stack + newsize;
    
    // âš ï¸ å…³é”®æ­¥éª¤ï¼šè°ƒæ•´æ‰€æœ‰æŒ‡å‘æ ˆçš„æŒ‡é’ˆ
    correctstack(L, oldstack);
}
```

#### å†…å­˜é‡åˆ†é…è¿‡ç¨‹

```mermaid
sequenceDiagram
    participant Caller as è°ƒç”¨è€…
    participant Realloc as luaD_reallocstack
    participant MemMgr as å†…å­˜ç®¡ç†å™¨
    participant Correct as correctstack
    
    Caller->>Realloc: reallocstack(L, newsize)
    Realloc->>Realloc: ä¿å­˜ oldstack åœ°å€
    Realloc->>MemMgr: luaM_reallocvector()
    
    alt åŸåœ°æ‰©å±•æˆåŠŸ
        MemMgr->>MemMgr: æ‰©å±•å†…å­˜å—
        MemMgr->>Realloc: è¿”å›åŸåœ°å€
    else éœ€è¦ç§»åŠ¨
        MemMgr->>MemMgr: åˆ†é…æ–°å—
        MemMgr->>MemMgr: å¤åˆ¶æ—§æ•°æ®
        MemMgr->>MemMgr: é‡Šæ”¾æ—§å—
        MemMgr->>Realloc: è¿”å›æ–°åœ°å€
    end
    
    Realloc->>Realloc: æ›´æ–° stacksize, stack_last
    Realloc->>Correct: correctstack(L, oldstack)
    Correct->>Correct: è°ƒæ•´æ‰€æœ‰æ ˆæŒ‡é’ˆ
    Correct->>Realloc: å®Œæˆ
    Realloc->>Caller: è¿”å›
    
    Note over Correct: å…³é”®ï¼å³ä½¿åŸåœ°æ‰©å±•<br/>ä¹Ÿå¯èƒ½éœ€è¦è°ƒæ•´
```

---

### 2. æŒ‡é’ˆè°ƒæ•´ç®—æ³• (correctstack)

#### ä¸ºä»€ä¹ˆéœ€è¦è°ƒæ•´æŒ‡é’ˆï¼Ÿ

```
é—®é¢˜ï¼šæ ˆåœ°å€å¯èƒ½æ”¹å˜
æ—§åœ°å€:  0x1000 â”€â”€â”€â”
                   â”‚ realloc
æ–°åœ°å€:  0x2000 â”€â”€â”€â”˜

æ‰€æœ‰æŒ‡å‘æ ˆçš„æŒ‡é’ˆéƒ½å¤±æ•ˆäº†ï¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ L->top    æŒ‡å‘ 0x1050      â”‚ âŒ é”™è¯¯ï¼
â”‚ L->base   æŒ‡å‘ 0x1020      â”‚ âŒ é”™è¯¯ï¼
â”‚ ci->func  æŒ‡å‘ 0x1010      â”‚ âŒ é”™è¯¯ï¼
â”‚ ci->base  æŒ‡å‘ 0x1020      â”‚ âŒ é”™è¯¯ï¼
â”‚ ci->top   æŒ‡å‘ 0x1080      â”‚ âŒ é”™è¯¯ï¼
â”‚ upvalue->v æŒ‡å‘ 0x1030     â”‚ âŒ é”™è¯¯ï¼
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

éœ€è¦å…¨éƒ¨è°ƒæ•´ä¸ºæ–°åœ°å€ï¼
```

#### correctstack å®Œæ•´å®ç°

```c
// ldo.c: è°ƒæ•´æ‰€æœ‰æŒ‡å‘æ ˆçš„æŒ‡é’ˆ
static void correctstack (lua_State *L, TValue *oldstack) {
    CallInfo *ci;
    GCObject *up;
    
    // ===== 1. è°ƒæ•´ lua_State ä¸­çš„æ ˆæŒ‡é’ˆ =====
    L->top = (L->top - oldstack) + L->stack;
    
    // ===== 2. è°ƒæ•´æ‰€æœ‰ CallInfo ä¸­çš„æŒ‡é’ˆ =====
    for (ci = L->base_ci; ci <= L->ci; ci++) {
        ci->top = (ci->top - oldstack) + L->stack;
        ci->base = (ci->base - oldstack) + L->stack;
        ci->func = (ci->func - oldstack) + L->stack;
    }
    
    // ===== 3. è°ƒæ•´å½“å‰æ ˆå¸§åŸºå€ =====
    L->base = (L->base - oldstack) + L->stack;
    
    // ===== 4. è°ƒæ•´æ‰€æœ‰æ‰“å¼€çš„ upvalue =====
    for (up = L->openupval; up != NULL; up = up->gch.next) {
        gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
    }
}
```

#### æŒ‡é’ˆè°ƒæ•´å…¬å¼

```c
// é€šç”¨æŒ‡é’ˆè°ƒæ•´å…¬å¼
NewPtr = (OldPtr - oldstack) + L->stack
       = OldPtr + (L->stack - oldstack)
       = OldPtr + offset

// å…¶ä¸­ offset = L->stack - oldstackï¼ˆæ ˆåœ°å€çš„å˜åŒ–é‡ï¼‰

// åˆ†è§£æ­¥éª¤ï¼š
// 1. (OldPtr - oldstack)  â†’  è®¡ç®—æ—§æ ˆä¸­çš„åç§»é‡ï¼ˆç›¸å¯¹ä½ç½®ï¼‰
// 2. + L->stack           â†’  åœ¨æ–°æ ˆä¸­æ¢å¤ç›¸åŒçš„ç›¸å¯¹ä½ç½®
```

#### æŒ‡é’ˆè°ƒæ•´å¯è§†åŒ–

```
æ—§æ ˆ (oldstack = 0x1000):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  offset 0:   TValue[0]      â”‚ â† oldstack
â”‚  offset 1:   TValue[1]      â”‚
â”‚  offset 2:   TValue[2]      â”‚ â† top (0x1000 + 2*16 = 0x1020)
â”‚  ...                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ–°æ ˆ (L->stack = 0x2000):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  offset 0:   TValue[0]      â”‚ â† L->stack
â”‚  offset 1:   TValue[1]      â”‚
â”‚  offset 2:   TValue[2]      â”‚ â† æ–° top åº”è¯¥åœ¨è¿™é‡Œ
â”‚  ...                        â”‚
â”‚  æ›´å¤šç©ºé—´...                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è®¡ç®—æ–° top:
ç›¸å¯¹åç§» = (0x1020 - 0x1000) / 16 = 2
æ–° top = 0x2000 + 2 * 16 = 0x2020 âœ…
```

---

### 3. éœ€è¦è°ƒæ•´çš„æŒ‡é’ˆæ¸…å•

#### å®Œæ•´æŒ‡é’ˆåˆ†ç±»

```mermaid
graph TB
    A[éœ€è°ƒæ•´çš„æŒ‡é’ˆ] --> B[lua_State å­—æ®µ]
    A --> C[CallInfo å­—æ®µ]
    A --> D[UpVal å­—æ®µ]
    A --> E[å…¶ä»–å¼•ç”¨]
    
    B --> B1[L->top]
    B --> B2[L->base]
    
    C --> C1[ci->func]
    C --> C2[ci->base]
    C --> C3[ci->top]
    C --> C4[å¤šä¸ª CallInfo]
    
    D --> D1[upval->v]
    D --> D2[æ‰“å¼€çš„ upvalue é“¾è¡¨]
    
    E --> E1[ä¿å­˜çš„æ ˆå¼•ç”¨]
    E --> E2[C ä»£ç ä¸­çš„ StkId]
    
    style A fill:#ff6b6b
    style B fill:#4ecdc4
    style C fill:#f9ca24
    style D fill:#6c5ce7
    style E fill:#00b894
```

#### è¯¦ç»†æŒ‡é’ˆè¡¨

| ä½ç½® | æŒ‡é’ˆ | æ•°é‡ | è°ƒæ•´æ–¹å¼ |
|------|------|------|---------|
| **lua_State** | `L->top` | 1 | ç›´æ¥è°ƒæ•´ |
| **lua_State** | `L->base` | 1 | ç›´æ¥è°ƒæ•´ |
| **CallInfo[]** | `ci->func` | N ä¸ª | å¾ªç¯è°ƒæ•´ |
| **CallInfo[]** | `ci->base` | N ä¸ª | å¾ªç¯è°ƒæ•´ |
| **CallInfo[]** | `ci->top` | N ä¸ª | å¾ªç¯è°ƒæ•´ |
| **UpValé“¾è¡¨** | `upval->v` | M ä¸ª | éå†é“¾è¡¨è°ƒæ•´ |

å…¶ä¸­ï¼š
- N = CallInfo æ•°é‡ï¼ˆè°ƒç”¨æ·±åº¦ï¼‰
- M = æ‰“å¼€çš„ upvalue æ•°é‡

#### æ½œåœ¨é—æ¼é£é™©

```c
// âŒ å±é™©ï¼šC ä»£ç ä¸­ä¿å­˜çš„æ ˆå¼•ç”¨
void bad_c_function(lua_State *L) {
    StkId saved = L->top;  // ä¿å­˜æ ˆæŒ‡é’ˆ
    
    // ... ä¸€äº›æ“ä½œå¯èƒ½è§¦å‘æ ˆå¢é•¿
    lua_pushstring(L, very_long_string);  // å¯èƒ½è§¦å‘ luaD_growstack
    
    // âŒ é”™è¯¯ï¼šsaved å¯èƒ½å·²ç»å¤±æ•ˆï¼
    setobjs2s(L, saved, L->top);  // å´©æºƒæˆ–æ•°æ®æŸå
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ ˆç´¢å¼•è€ŒéæŒ‡é’ˆ
void good_c_function(lua_State *L) {
    int saved_index = lua_gettop(L);  // ä¿å­˜ç´¢å¼•
    
    lua_pushstring(L, very_long_string);  // å®‰å…¨
    
    // âœ… æ­£ç¡®ï¼šé€šè¿‡ç´¢å¼•è®¿é—®ï¼ˆè‡ªåŠ¨å¤„ç†åœ°å€å˜åŒ–ï¼‰
    lua_pushvalue(L, saved_index);
}
```

---

### 4. upvalue æŒ‡é’ˆè°ƒæ•´

#### ä»€ä¹ˆæ˜¯æ‰“å¼€çš„ upvalueï¼Ÿ

```lua
-- ç¤ºä¾‹ï¼šé—­åŒ…æ•è·å±€éƒ¨å˜é‡
function make_counter()
    local count = 0  -- æ ˆä¸Šçš„å±€éƒ¨å˜é‡
    return function()
        count = count + 1  -- count è¢«æ•è·ä¸º upvalue
        return count
    end
end

local counter = make_counter()
print(counter())  -- 1
print(counter())  -- 2
```

#### upvalue çš„ä¸¤ç§çŠ¶æ€

```
æ‰“å¼€çŠ¶æ€ (Open)ï¼šupvalue æŒ‡å‘æ ˆä¸Šçš„å˜é‡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Lua æ ˆ                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ count=0 â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚                         â”‚   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”˜
                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                    â”‚ UpVal    â”‚
                    â”‚ v â”€â”€â”€â”€â”€â” â”‚
                    â”‚ next   â”‚ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                               â”‚
                    æŒ‡å‘æ ˆä¸Šå˜é‡

å…³é—­çŠ¶æ€ (Closed)ï¼šupvalue æ‹¥æœ‰å€¼çš„å‰¯æœ¬
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ UpVal    â”‚
                    â”‚ v â”€â”€â”€â”€â”€â” â”‚ æŒ‡å‘è‡ªèº«çš„ value
                    â”‚ value  â”‚ â”‚
                    â”‚ [42]   â”‚â—„â”˜
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### upvalue æŒ‡é’ˆè°ƒæ•´ä»£ç 

```c
// ldo.c: correctstack ä¸­çš„ upvalue å¤„ç†
for (up = L->openupval; up != NULL; up = up->gch.next) {
    // gco2uv: å°† GCObject è½¬æ¢ä¸º UpVal
    UpVal *uv = gco2uv(up);
    
    // è°ƒæ•´ upvalue çš„å€¼æŒ‡é’ˆ
    uv->v = (uv->v - oldstack) + L->stack;
}
```

#### upvalue é“¾è¡¨ç»“æ„

```
L->openupval é“¾è¡¨ï¼ˆæŒ‰æ ˆåœ°å€é™åºï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ UpVal 1  â”‚    â”‚ UpVal 2  â”‚    â”‚ UpVal 3  â”‚
â”‚ v: 0x108 â”‚â”€â”€â”€â–¶â”‚ v: 0x104 â”‚â”€â”€â”€â–¶â”‚ v: 0x100 â”‚â”€â”€â”€â–¶ NULL
â”‚ next     â”‚    â”‚ next     â”‚    â”‚ next     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â–¶ éƒ½æŒ‡å‘æ ˆ
                                                éœ€è¦è°ƒæ•´ï¼
```

---

### 5. æ ˆå¢é•¿çš„å®Œæ•´æµç¨‹

#### ç«¯åˆ°ç«¯æµç¨‹å›¾

```mermaid
graph TB
    A[æ£€æµ‹æ ˆç©ºé—´ä¸è¶³] --> B[luaD_checkstack]
    B --> C[luaD_growstack]
    C --> D{è®¡ç®—æ–°å¤§å°}
    
    D -->|n <= stacksize| E[newsize = 2 * stacksize]
    D -->|n > stacksize| F[newsize = stacksize + n + EXTRA]
    
    E --> G[luaD_reallocstack]
    F --> G
    
    G --> H[ä¿å­˜ oldstack]
    H --> I[luaM_reallocvector<br/>é‡æ–°åˆ†é…å†…å­˜]
    I --> J[æ›´æ–° stacksize<br/>stack_last]
    J --> K[correctstack<br/>è°ƒæ•´æŒ‡é’ˆ]
    
    K --> L[è°ƒæ•´ L->top, L->base]
    K --> M[è°ƒæ•´æ‰€æœ‰ CallInfo]
    K --> N[è°ƒæ•´æ‰€æœ‰ upvalue]
    
    L --> O[å®Œæˆ]
    M --> O
    N --> O
    
    style A fill:#ff6b6b
    style C fill:#4ecdc4
    style G fill:#f9ca24
    style K fill:#6c5ce7
```

#### å…³é”®æ­¥éª¤æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant App as åº”ç”¨ä»£ç 
    participant Check as luaD_checkstack
    participant Grow as luaD_growstack
    participant Realloc as luaD_reallocstack
    participant Mem as å†…å­˜ç®¡ç†å™¨
    participant Correct as correctstack
    
    App->>Check: éœ€è¦ n ä¸ªæ§½ä½
    Check->>Check: æ£€æŸ¥å‰©ä½™ç©ºé—´
    
    alt ç©ºé—´è¶³å¤Ÿ
        Check->>App: ç›´æ¥è¿”å›
    else ç©ºé—´ä¸è¶³
        Check->>Grow: growstack(L, n)
        Grow->>Grow: è®¡ç®—æ–°å¤§å°
        Grow->>Realloc: reallocstack(L, newsize)
        Realloc->>Realloc: ä¿å­˜ oldstack
        Realloc->>Mem: reallocvector()
        Mem->>Mem: åˆ†é…/å¤åˆ¶/é‡Šæ”¾
        Mem->>Realloc: è¿”å›æ–°åœ°å€
        Realloc->>Realloc: æ›´æ–° stacksize
        Realloc->>Correct: correctstack(L, oldstack)
        Correct->>Correct: è°ƒæ•´ L->top, L->base
        Correct->>Correct: å¾ªç¯è°ƒæ•´ CallInfo
        Correct->>Correct: éå†è°ƒæ•´ upvalue
        Correct->>Realloc: å®Œæˆ
        Realloc->>Grow: å®Œæˆ
        Grow->>Check: å®Œæˆ
        Check->>App: å®Œæˆ
    end
```

---

### 6. è¾¹ç•Œæ¡ä»¶å¤„ç†

#### æœ€å¤§æ ˆé™åˆ¶

```c
// llimits.h: æ ˆå¤§å°é™åˆ¶
#define LUAI_MAXSTACK   1000000   // æœ€å¤§æ ˆå¤§å°ï¼ˆæ§½ä½æ•°ï¼‰
#define LUAI_MAXCSTACK  8000      // C è°ƒç”¨æ ˆæœ€å¤§æ·±åº¦

// ldo.c: æ ˆæº¢å‡ºæ£€æŸ¥
void luaD_growstack (lua_State *L, int n) {
    if (L->stacksize > LUAI_MAXSTACK)  // å·²ç»å¤ªå¤§
        luaD_throw(L, LUA_ERRERR);  // æ— æ³•æ¢å¤çš„é”™è¯¯
    else {
        int newsize = 2 * L->stacksize;
        if (newsize > LUAI_MAXSTACK)
            newsize = LUAI_MAXSTACK;  // é™åˆ¶æœ€å¤§å€¼
        
        if (newsize < n)  // å³ä½¿æœ€å¤§å€¼ä¹Ÿä¸å¤Ÿ
            newsize = n;
        
        if (newsize > LUAI_MAXSTACK) {  // è¶…è¿‡é™åˆ¶
            // å°è¯•ä¸€æ¬¡é”™è¯¯æ¢å¤å¤§å°
            luaD_reallocstack(L, ERRORSTACKSIZE);
            luaG_runerror(L, "stack overflow");
        }
        
        luaD_reallocstack(L, newsize);
    }
}
```

#### é”™è¯¯æ¢å¤æ ˆ

```c
// lstate.h: é”™è¯¯æ¢å¤æ—¶çš„æ ˆå¤§å°
#define ERRORSTACKSIZE  (LUAI_MAXSTACK + 200)

// ç”¨é€”ï¼šåœ¨æ ˆæº¢å‡ºé”™è¯¯å‘ç”Ÿæ—¶ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´å¤„ç†é”™è¯¯
// - è°ƒç”¨é”™è¯¯å¤„ç†å™¨
// - æ„é€ é”™è¯¯æ¶ˆæ¯
// - æ‰§è¡Œæ ˆå±•å¼€
```

#### C è°ƒç”¨æ·±åº¦æ£€æŸ¥

```c
// ldo.c: é˜²æ­¢ C æ ˆæº¢å‡º
void luaD_call (lua_State *L, StkId func, int nResults) {
    // æ£€æŸ¥ C è°ƒç”¨æ·±åº¦
    if (++L->nCcalls >= LUAI_MAXCCALLS) {
        if (L->nCcalls == LUAI_MAXCCALLS)
            luaG_runerror(L, "C stack overflow");
        else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
            luaD_throw(L, LUA_ERRERR);  // æ— æ³•æ¢å¤
    }
    
    // ... è°ƒç”¨é€»è¾‘
    
    L->nCcalls--;  // è¿”å›æ—¶é€’å‡
}
```

---

### 7. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### ä¼˜åŒ–1ï¼šé¿å…é¢‘ç¹æ£€æŸ¥

```c
// âŒ ä½æ•ˆï¼šæ¯æ¬¡æ“ä½œéƒ½æ£€æŸ¥
for (int i = 0; i < 100; i++) {
    luaD_checkstack(L, 1);  // 100 æ¬¡æ£€æŸ¥ï¼
    lua_pushnumber(L, i);
}

// âœ… é«˜æ•ˆï¼šä¸€æ¬¡æ£€æŸ¥è¶³å¤Ÿ
luaD_checkstack(L, 100);  // ä¸€æ¬¡æ£€æŸ¥
for (int i = 0; i < 100; i++) {
    lua_pushnumber(L, i);  // å®‰å…¨
}
```

#### ä¼˜åŒ–2ï¼šé¢„å…ˆåˆ†é…

```c
// ldo.c: å‡½æ•°è°ƒç”¨æ—¶é¢„åˆ†é…
int luaD_precall (lua_State *L, StkId func, int nresults) {
    Proto *p = cl->p;
    
    // ç¼–è¯‘å™¨å·²ç»è®¡ç®—äº†æœ€å¤§æ ˆéœ€æ±‚
    int needed = p->maxstacksize;
    
    // ä¸€æ¬¡æ€§åˆ†é…è¶³å¤Ÿç©ºé—´
    luaD_checkstack(L, needed);
    
    // æ•´ä¸ªå‡½æ•°æ‰§è¡ŒæœŸé—´æ— éœ€å†æ£€æŸ¥
    // ...
}
```

#### ä¼˜åŒ–3ï¼šé¿å…ä¸å¿…è¦çš„è°ƒæ•´

```c
// correctstack åªåœ¨åœ°å€çœŸçš„å˜åŒ–æ—¶è°ƒç”¨
static void luaD_reallocstack (lua_State *L, int newsize) {
    TValue *oldstack = L->stack;
    
    // é‡æ–°åˆ†é…
    luaM_reallocvector(L, L->stack, L->stacksize, realsize, TValue);
    
    // âš ï¸ å³ä½¿åœ°å€æœªå˜ï¼ŒæŒ‡é’ˆä¹Ÿå¯èƒ½éœ€è¦è°ƒæ•´
    // ï¼ˆä¾‹å¦‚ï¼šæ ˆæ‰©å±•åï¼Œstack_last å˜äº†ï¼‰
    correctstack(L, oldstack);
}
```

---

## âš¡ æ€§èƒ½åˆ†æ

### 1. æ—¶é—´å¤æ‚åº¦åˆ†æ

#### å•æ¬¡æ“ä½œå¤æ‚åº¦

| æ“ä½œ | æœ€åæƒ…å†µ | æ‘Šé”€å¤æ‚åº¦ | è¯´æ˜ |
|------|---------|-----------|------|
| **push** | O(n) | O(1) | å¯èƒ½è§¦å‘æ‰©å±• |
| **pop** | O(1) | O(1) | æ— éœ€æ‰©å±• |
| **checkstack** | O(n) | O(1) | å¶å°”æ‰©å±• |
| **æ‰©å±•æ ˆ** | O(n) | - | å¤åˆ¶ n ä¸ªå…ƒç´  |
| **è°ƒæ•´æŒ‡é’ˆ** | O(d+u) | - | d=è°ƒç”¨æ·±åº¦, u=upvalueæ•° |

#### æ‘Šé”€åˆ†æ

```
åŒå€å¢é•¿çš„æ‘Šé”€æˆæœ¬ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ n æ¬¡ push æ“ä½œçš„æ€»æˆæœ¬ï¼š         â”‚
â”‚                                  â”‚
â”‚ å¤åˆ¶æ¬¡æ•°åºåˆ—ï¼š                   â”‚
â”‚   40 + 80 + 160 + ... + n        â”‚
â”‚ = n * (1 + 1/2 + 1/4 + ... + 1/n) â”‚
â”‚ â‰ˆ 2n                             â”‚
â”‚                                  â”‚
â”‚ å¹³å‡æ¯æ¬¡ push: 2n / n = 2        â”‚
â”‚ æ‘Šé”€å¤æ‚åº¦: O(1)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ä¸å›ºå®šå¢é•¿å¯¹æ¯”

```lua
-- æ€§èƒ½å¯¹æ¯”æµ‹è¯•
function benchmark_growth()
    local start = os.clock()
    
    -- åŒå€å¢é•¿ï¼ˆLua å®é™…è¡Œä¸ºï¼‰
    local t = {}
    for i = 1, 1000000 do
        t[i] = i  -- è§¦å‘è¡¨å’Œæ ˆå¢é•¿
    end
    
    local elapsed = os.clock() - start
    print("Double growth:", elapsed, "seconds")
    
    -- å›ºå®šå¢é•¿æ¨¡æ‹Ÿï¼ˆå‡è®¾ï¼‰
    -- éœ€è¦ 1000000 / 40 = 25000 æ¬¡é‡åˆ†é…
    -- vs åŒå€å¢é•¿çš„ ~15 æ¬¡é‡åˆ†é…
    -- æ€§èƒ½å·®è·å·¨å¤§ï¼
end
```

---

### 2. ç©ºé—´å¤æ‚åº¦åˆ†æ

#### ç©ºé—´æµªè´¹ç‡

```
åŒå€å¢é•¿çš„ç©ºé—´æµªè´¹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æœ€åæƒ…å†µï¼ˆåˆšæ‰©å±•åï¼‰ï¼š            â”‚
â”‚   å·²ç”¨: n/2 + 1                  â”‚
â”‚   æ€»é‡: n                        â”‚
â”‚   æµªè´¹: n - (n/2 + 1) â‰ˆ n/2      â”‚
â”‚   æµªè´¹ç‡: 50%                    â”‚
â”‚                                  â”‚
â”‚ å¹³å‡æƒ…å†µï¼š                       â”‚
â”‚   å·²ç”¨: 3n/4                     â”‚
â”‚   æµªè´¹ç‡: 25%                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®é™…å†…å­˜å ç”¨

```c
// å•ä¸ª lua_State çš„æ ˆå†…å­˜
size_t stack_memory = stacksize * sizeof(TValue);
                    = stacksize * 16 bytes

// å…¸å‹å¤§å°ç¤ºä¾‹
åˆå§‹:    40 * 16 = 640 bytes
å°å‡½æ•°:  80 * 16 = 1.25 KB
ä¸­å‡½æ•°: 160 * 16 = 2.5 KB
å¤§å‡½æ•°: 320 * 16 = 5 KB
æ·±é€’å½’: 1280 * 16 = 20 KB
```

#### å†…å­˜å¸ƒå±€

```
å®Œæ•´ lua_State çš„å†…å­˜å ç”¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ lua_State ç»“æ„ä½“: ~200 bytes â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ ˆç©ºé—´: stacksize * 16       â”‚
â”‚   (åŠ¨æ€åˆ†é…)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CallInfo æ•°ç»„: size_ci * 32  â”‚
â”‚   (åŠ¨æ€åˆ†é…)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å…¶ä»–å­—æ®µ: ~100 bytes        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…¸å‹åç¨‹å†…å­˜: ~3 KB
æ·±é€’å½’åç¨‹: ~50 KB
```

---

### 3. ç¼“å­˜æ€§èƒ½

#### ç¼“å­˜å‹å¥½æ€§

```
è¿ç»­æ•°ç»„ vs é“¾è¡¨è®¿é—®ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ ˆï¼ˆè¿ç»­æ•°ç»„ï¼‰ï¼š                     â”‚
â”‚   è®¿é—® stack[i]: 1-2 cycles         â”‚
â”‚   é¢„å–æ•ˆç‡: é«˜ï¼ˆç¡¬ä»¶é¢„å–å™¨è¯†åˆ«ï¼‰      â”‚
â”‚   ç¼“å­˜è¡Œåˆ©ç”¨: 4-8 ä¸ª TValue/è¡Œ       â”‚
â”‚                                     â”‚
â”‚ é“¾è¡¨ï¼ˆå‡è®¾ï¼‰ï¼š                       â”‚
â”‚   è®¿é—®èŠ‚ç‚¹: 10-20 cycles            â”‚
â”‚   é¢„å–æ•ˆç‡: ä½ï¼ˆéšæœºè·³è½¬ï¼‰           â”‚
â”‚   ç¼“å­˜è¡Œåˆ©ç”¨: ä½ï¼ˆèŠ‚ç‚¹åˆ†æ•£ï¼‰         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ç¼“å­˜è¡Œå¯¹é½

```c
// TValue å¤§å°: 16 å­—èŠ‚
// å…¸å‹ç¼“å­˜è¡Œ: 64 å­—èŠ‚
// æ¯è¡Œå¯æ”¾: 64 / 16 = 4 ä¸ª TValue

// è¿ç»­è®¿é—®çš„æ€§èƒ½ä¼˜åŠ¿
void process_stack(lua_State *L) {
    // é¡ºåºè®¿é—®ï¼ˆç¼“å­˜å‹å¥½ï¼‰
    for (StkId o = L->base; o < L->top; o++) {
        // æ¯ 4 ä¸ªè®¿é—®åªæœ‰ 1 æ¬¡ç¼“å­˜ç¼ºå¤±
        process_value(o);
    }
}
```

---

### 4. æ€§èƒ½åŸºå‡†æµ‹è¯•

#### æ ˆæ“ä½œæ€§èƒ½

```lua
-- åŸºå‡†æµ‹è¯•ï¼šæ ˆpush/popæ€§èƒ½
function benchmark_stack()
    local iterations = 10000000
    local start = os.clock()
    
    for i = 1, iterations do
        local a = 1  -- push
        local b = 2  -- push
        local c = 3  -- push
        local d = a + b + c  -- compute
        -- å‡½æ•°è¿”å›æ—¶ pop
    end
    
    local elapsed = os.clock() - start
    print(string.format("Stack ops: %.2f M/sec", 
          iterations * 3 / elapsed / 1e6))
end

-- å…¸å‹ç»“æœï¼š50-100 M ops/secï¼ˆç°ä»£CPUï¼‰
```

#### æ ˆæ‰©å±•æ€§èƒ½

```lua
-- åŸºå‡†æµ‹è¯•ï¼šæ ˆæ‰©å±•å¼€é”€
function benchmark_growth()
    local function deep(n)
        if n == 0 then return 0 end
        local a, b, c, d, e = n, n, n, n, n  -- å ç”¨æ ˆç©ºé—´
        return a + deep(n - 1)
    end
    
    local start = os.clock()
    deep(1000)  -- è§¦å‘å¤šæ¬¡æ ˆæ‰©å±•
    local elapsed = os.clock() - start
    
    print(string.format("Deep recursion: %.3f ms", elapsed * 1000))
end

-- å…¸å‹ç»“æœï¼š< 1 msï¼ˆæ‰©å±•å¼€é”€å¾ˆå°ï¼‰
```

---

## ğŸ’¡ è®¾è®¡æƒè¡¡

### 1. åŒå€å¢é•¿ vs å…¶ä»–ç­–ç•¥

#### ç­–ç•¥å¯¹æ¯”è¡¨

| ç­–ç•¥ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´æµªè´¹ | é‡åˆ†é…æ¬¡æ•° | å®ç°å¤æ‚åº¦ | Luaé€‰æ‹© |
|------|-----------|---------|-----------|-----------|---------|
| **å›ºå®šå¢é•¿ (+N)** | O(nÂ²) | ä½ (~10%) | O(n/N) | ç®€å• | âŒ |
| **1.5å€å¢é•¿** | O(n) | ä¸­ (~33%) | O(logâ‚.â‚… n) | ç®€å• | âŒ |
| **åŒå€å¢é•¿** | O(n) | é«˜ (~50%) | O(logâ‚‚ n) | ç®€å• | âœ… |
| **æ–æ³¢é‚£å¥‘** | O(n) | ä¸­ (~38%) | O(log_Ï† n) | å¤æ‚ | âŒ |

#### è¯¦ç»†åˆ†æ

```mermaid
graph TB
    A[å¢é•¿ç­–ç•¥é€‰æ‹©] --> B{ä¼˜å…ˆçº§}
    
    B -->|æ€§èƒ½ä¼˜å…ˆ| C[åŒå€å¢é•¿]
    B -->|å†…å­˜ä¼˜å…ˆ| D[1.5å€å¢é•¿]
    B -->|å¹³è¡¡| E[é»„é‡‘æ¯”ä¾‹]
    
    C --> F[é‡åˆ†é…æœ€å°‘<br/>ç¼“å­˜æœ€å‹å¥½]
    D --> G[ç©ºé—´æµªè´¹å°‘<br/>æ€§èƒ½å¯æ¥å—]
    E --> H[æŠ˜ä¸­æ–¹æ¡ˆ<br/>å¤æ‚åº¦é«˜]
    
    F --> I[Luaé€‰æ‹©]
    
    style C fill:#00b894
    style I fill:#4ecdc4
```

#### å®é™…æµ‹è¯•æ•°æ®

```
å¢é•¿åˆ° 100 ä¸‡å…ƒç´ çš„é‡åˆ†é…æ¬¡æ•°ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç­–ç•¥          é‡åˆ†é…æ¬¡æ•°         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å›ºå®š +40      25,000 æ¬¡         â”‚
â”‚ å›ºå®š +1000    1,000 æ¬¡          â”‚
â”‚ 1.5å€         ~35 æ¬¡            â”‚
â”‚ åŒå€          ~15 æ¬¡  âœ… æœ€å°‘   â”‚
â”‚ é»„é‡‘æ¯” 1.618  ~27 æ¬¡            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2. è¿ç»­æ•°ç»„ vs é“¾è¡¨

#### è®¾è®¡é€‰æ‹©

```mermaid
graph LR
    A[æ ˆå­˜å‚¨æ–¹å¼] --> B{è¿ç»­æ•°ç»„}
    A --> C{é“¾è¡¨}
    
    B --> D["âœ… ç¼“å­˜å‹å¥½<br/>âœ… è®¿é—®O(1)<br/>âœ… ç¡¬ä»¶é¢„å–<br/>âš ï¸ é‡åˆ†é…å¼€é”€<br/>âš ï¸ æŒ‡é’ˆè°ƒæ•´"]
    
    C --> E["âœ… æ— éœ€é‡åˆ†é…<br/>âœ… æ— éœ€è°ƒæ•´æŒ‡é’ˆ<br/>âŒ ç¼“å­˜ä¸å‹å¥½<br/>âŒ æŒ‡é’ˆå¼€é”€<br/>âŒ å†…å­˜ç¢ç‰‡"]
    
    B --> F[Luaé€‰æ‹©]
    
    style B fill:#00b894
    style F fill:#4ecdc4
```

#### æ€§èƒ½å·®å¼‚

```c
// åŸºå‡†æµ‹è¯•ï¼šæ•°ç»„ vs é“¾è¡¨è®¿é—®
#include <time.h>

// æ•°ç»„è®¿é—®
void test_array() {
    int arr[1000000];
    clock_t start = clock();
    
    long sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += arr[i];  // è¿ç»­è®¿é—®
    }
    
    double elapsed = (double)(clock() - start) / CLOCKS_PER_SEC;
    printf("Array: %.3f ms\n", elapsed * 1000);
    // å…¸å‹ç»“æœ: ~1-2 ms
}

// é“¾è¡¨è®¿é—®
struct Node { int value; struct Node *next; };
void test_list() {
    // ... æ„é€ é“¾è¡¨ ...
    clock_t start = clock();
    
    long sum = 0;
    struct Node *p = head;
    while (p) {
        sum += p->value;  // è·³è½¬è®¿é—®
        p = p->next;
    }
    
    double elapsed = (double)(clock() - start) / CLOCKS_PER_SEC;
    printf("List: %.3f ms\n", elapsed * 1000);
    // å…¸å‹ç»“æœ: ~10-20 msï¼ˆæ…¢ 10-20 å€ï¼ï¼‰
}
```

---

### 3. æ ˆæ£€æŸ¥æ—¶æœº

#### æ£€æŸ¥ç­–ç•¥

```c
// ç­–ç•¥1: æ¯æ¬¡pushå‰æ£€æŸ¥ï¼ˆâŒ ä½æ•ˆï¼‰
void push_value(lua_State *L, TValue *v) {
    luaD_checkstack(L, 1);  // æ¯æ¬¡éƒ½æ£€æŸ¥
    setobj2s(L, L->top, v);
    L->top++;
}

// ç­–ç•¥2: æ‰¹é‡é¢„æ£€æŸ¥ï¼ˆâœ… Luaçš„é€‰æ‹©ï¼‰
int luaD_precall (lua_State *L, StkId func, int nresults) {
    Proto *p = cl->p;
    
    // ä¸€æ¬¡æ€§æ£€æŸ¥æ•´ä¸ªå‡½æ•°éœ€è¦çš„ç©ºé—´
    luaD_checkstack(L, p->maxstacksize);
    
    // æ•´ä¸ªå‡½æ•°æ‰§è¡ŒæœŸé—´æ— éœ€å†æ£€æŸ¥
    // ...
}

// ç­–ç•¥3: ä»ä¸æ£€æŸ¥ï¼ˆâŒ ä¸å®‰å…¨ï¼‰
// ä¾èµ–é™æ€åˆ†æï¼ˆC++æ¨¡æ¿å…ƒç¼–ç¨‹é£æ ¼ï¼‰
// Lua æ— æ³•ä½¿ç”¨ï¼ˆåŠ¨æ€è¯­è¨€ï¼‰
```

#### æƒè¡¡åˆ†æ

```mermaid
graph TB
    A[æ ˆæ£€æŸ¥æ—¶æœº] --> B[æ¯æ¬¡æ“ä½œ]
    A --> C[æ‰¹é‡é¢„æ£€æŸ¥]
    A --> D[ä»ä¸æ£€æŸ¥]
    
    B --> E[âœ… æœ€å®‰å…¨<br/>âŒ æ€§èƒ½æœ€å·®<br/>âŒ å¼€é”€å·¨å¤§]
    
    C --> F[âœ… å®‰å…¨<br/>âœ… æ€§èƒ½å¥½<br/>âœ… å¼€é”€ä½<br/>âš ï¸ éœ€ç¼–è¯‘å™¨æ”¯æŒ]
    
    D --> G[âœ… æ€§èƒ½æœ€å¥½<br/>âŒ ä¸å®‰å…¨<br/>âŒ æ˜“å´©æºƒ]
    
    C --> H[Luaé€‰æ‹©]
    
    style C fill:#00b894
    style H fill:#4ecdc4
```

---

### 4. EXTRA_STACK è®¾è®¡

#### ä¸ºä»€ä¹ˆéœ€è¦ EXTRA_STACKï¼Ÿ

```c
// lstate.h
#define EXTRA_STACK  5  // é¢å¤–çš„å®‰å…¨è¾¹è·

// ç”¨é€”ï¼š
// 1. é”™è¯¯å¤„ç†æ—¶çš„ç©ºé—´
// 2. å…ƒæ–¹æ³•è°ƒç”¨çš„ç¼“å†²
// 3. C API æ„å¤–è¶…å‡ºçš„å®¹é”™
// 4. è°ƒè¯•ä¿¡æ¯æ„é€ çš„ç©ºé—´
```

#### ç©ºé—´å¸ƒå±€

```
æ ˆç©ºé—´åˆ†é…ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EXTRA_STACK (5 slots)          â”‚ â† stack + stacksize
â”‚  - ä¸è®¡å…¥å¯ç”¨ç©ºé—´               â”‚
â”‚  - ç´§æ€¥æƒ…å†µä½¿ç”¨                 â”‚
â”œâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”¤ â† stack_last
â”‚                                 â”‚
â”‚  æ­£å¸¸å¯ç”¨ç©ºé—´                   â”‚
â”‚  (stacksize - EXTRA_STACK)      â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â† stack

ä¸å˜å¼ï¼š
stack_last = stack + stacksize - EXTRA_STACK
```

#### ä¸ºä»€ä¹ˆæ˜¯ 5ï¼Ÿ

```c
// ç»éªŒå€¼ï¼šè¶³å¤Ÿå¤„ç†å¸¸è§æƒ…å†µ
// 1. é”™è¯¯å¯¹è±¡ + é”™è¯¯å¤„ç†å™¨ + è°ƒç”¨å‚æ•°: ~3
// 2. å…ƒæ–¹æ³•è°ƒç”¨: ~2
// 3. æ€»è®¡: 5 (ä¿å®ˆä¼°è®¡)

// å¦‚æœä¸å¤Ÿï¼Ÿ
// â†’ luaD_growstack ä¼šæ‰©å±•åˆ° ERRORSTACKSIZE
// â†’ è¶³å¤Ÿå¤„ç†æœ€å¤æ‚çš„é”™è¯¯æ¢å¤
```

---

### 5. æœ€å¤§æ ˆé™åˆ¶

#### é™åˆ¶å¸¸é‡

```c
// llimits.h
#define LUAI_MAXSTACK    1000000  // Lua æ ˆæœ€å¤§æ§½ä½æ•°
#define LUAI_MAXCSTACK   8000     // C è°ƒç”¨æ ˆæœ€å¤§æ·±åº¦
#define ERRORSTACKSIZE   (LUAI_MAXSTACK + 200)  // é”™è¯¯æ¢å¤æ ˆ
```

#### é™åˆ¶ç†ç”±

```mermaid
graph TB
    A[ä¸ºä»€ä¹ˆé™åˆ¶æ ˆå¤§å°ï¼Ÿ] --> B[é˜²æ­¢æ— é™é€’å½’]
    A --> C[ä¿æŠ¤Cæ ˆ]
    A --> D[å†…å­˜å¯æ§]
    
    B --> E[é¿å…æ ˆæº¢å‡ºå´©æºƒ<br/>æä¾›é”™è¯¯ä¿¡æ¯]
    C --> F[Cå‡½æ•°è°ƒç”¨ä¹Ÿä½¿ç”¨æ ˆ<br/>å¿…é¡»ç•™å‡ºç©ºé—´]
    D --> G[1M * 16B = 16MB<br/>å¯æ¥å—çš„ä¸Šé™]
    
    style A fill:#ff6b6b
    style E fill:#4ecdc4
    style F fill:#f9ca24
    style G fill:#6c5ce7
```

#### å†…å­˜å ç”¨åˆ†æ

```
æœ€å¤§æ ˆå†…å­˜å ç”¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é…ç½®           å†…å­˜å ç”¨          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åˆå§‹ (40)      640 B            â”‚
â”‚ å°å‡½æ•° (80)    1.25 KB          â”‚
â”‚ ä¸­å‡½æ•° (320)   5 KB             â”‚
â”‚ å¤§å‡½æ•° (1280)  20 KB            â”‚
â”‚ æ·±é€’å½’ (10K)   160 KB           â”‚
â”‚ æœ€å¤§ (1M)      16 MB   âš ï¸       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å®é™…æƒ…å†µï¼š
- 99% çš„ç¨‹åº: < 10 KB
- æ·±é€’å½’: < 1 MB
- è¾¾åˆ° 16 MB: æå°‘ï¼ˆé€šå¸¸æ˜¯ bugï¼‰
```

---

## ğŸ› è°ƒè¯•æŠ€å·§

### 1. æ ˆçŠ¶æ€å¯è§†åŒ–

#### æ‰“å°æ ˆå†…å®¹

```c
// è°ƒè¯•å·¥å…·ï¼šæ‰“å°æ ˆçŠ¶æ€
void debug_print_stack(lua_State *L) {
    printf("=== Stack State ===\n");
    printf("stack:      %p\n", L->stack);
    printf("base:       %p (offset %ld)\n", L->base, L->base - L->stack);
    printf("top:        %p (offset %ld)\n", L->top, L->top - L->stack);
    printf("stack_last: %p (offset %ld)\n", L->stack_last, L->stack_last - L->stack);
    printf("stacksize:  %d\n", L->stacksize);
    printf("available:  %ld slots\n", L->stack_last - L->top);
    
    printf("\nStack contents:\n");
    for (StkId o = L->stack; o < L->top; o++) {
        printf("  [%3ld] %s: ", o - L->stack, luaT_typenames[ttype(o)]);
        
        switch (ttype(o)) {
            case LUA_TNUMBER:
                printf("%.2f\n", nvalue(o));
                break;
            case LUA_TSTRING:
                printf("\"%s\"\n", svalue(o));
                break;
            case LUA_TBOOLEAN:
                printf("%s\n", bvalue(o) ? "true" : "false");
                break;
            case LUA_TNIL:
                printf("nil\n");
                break;
            default:
                printf("%p\n", gcvalue(o));
        }
    }
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```c
// C API è°ƒè¯•
int my_c_function(lua_State *L) {
    debug_print_stack(L);  // æŸ¥çœ‹åˆå§‹çŠ¶æ€
    
    lua_pushstring(L, "test");
    lua_pushnumber(L, 42);
    
    debug_print_stack(L);  // æŸ¥çœ‹ä¿®æ”¹åçŠ¶æ€
    
    return 2;
}
```

---

### 2. æ ˆæº¢å‡ºè¯Šæ–­

#### æ£€æµ‹æ ˆæº¢å‡º

```c
// è®¾ç½®é’©å­æ£€æµ‹æ·±åº¦é€’å½’
void check_stack_depth(lua_State *L, lua_Debug *ar) {
    int depth = 0;
    lua_Debug frame;
    
    // ç»Ÿè®¡è°ƒç”¨æ·±åº¦
    while (lua_getstack(L, depth, &frame)) {
        depth++;
    }
    
    if (depth > 500) {  // é˜ˆå€¼
        printf("WARNING: Stack depth = %d\n", depth);
    }
}

// å®‰è£…é’©å­
lua_sethook(L, check_stack_depth, LUA_MASKCALL, 0);
```

#### Lua ä¾§è¯Šæ–­

```lua
-- é€’å½’æ·±åº¦æ£€æµ‹
local function get_stack_depth()
    local depth = 0
    while debug.getinfo(depth + 1) do
        depth = depth + 1
    end
    return depth
end

-- ç›‘æ§å‡½æ•°
function monitored_recursive(n)
    local depth = get_stack_depth()
    if depth > 500 then
        error(string.format("Too deep! depth=%d", depth))
    end
    
    if n == 0 then return 0 end
    return n + monitored_recursive(n - 1)
end
```

---

### 3. æŒ‡é’ˆå¤±æ•ˆæ£€æµ‹

#### æ£€æµ‹æŒ‡é’ˆæ˜¯å¦æœ‰æ•ˆ

```c
// è°ƒè¯•å®ï¼šæ£€æŸ¥ StkId æ˜¯å¦æœ‰æ•ˆ
#ifdef LUA_DEBUG
#define check_stack_pointer(L, p, name) \
    do { \
        if ((p) < (L)->stack || (p) > (L)->stack + (L)->stacksize) { \
            fprintf(stderr, "ERROR: Invalid stack pointer %s = %p " \
                            "(stack=%p, size=%d)\n", \
                    name, (p), (L)->stack, (L)->stacksize); \
            abort(); \
        } \
    } while(0)
#else
#define check_stack_pointer(L, p, name) ((void)0)
#endif

// ä½¿ç”¨
void some_function(lua_State *L) {
    StkId p = L->top - 1;
    check_stack_pointer(L, p, "p");  // éªŒè¯ p æœ‰æ•ˆ
    
    // ... å¯èƒ½è§¦å‘æ ˆå¢é•¿çš„æ“ä½œ
    lua_pushstring(L, long_string);
    
    check_stack_pointer(L, p, "p");  // âŒ p å¯èƒ½å·²å¤±æ•ˆï¼
}
```

#### å®‰å…¨çš„æŒ‡é’ˆä¿å­˜

```c
// âŒ é”™è¯¯ï¼šä¿å­˜æŒ‡é’ˆ
void bad_function(lua_State *L) {
    StkId saved = L->top;  // ä¿å­˜æŒ‡é’ˆ
    
    // ... æ“ä½œ
    lua_checkstack(L, 100);  // å¯èƒ½æ”¹å˜æ ˆåœ°å€
    
    // âŒ saved å¯èƒ½å¤±æ•ˆ
    setobj2s(L, saved, L->top);
}

// âœ… æ­£ç¡®ï¼šä¿å­˜ç´¢å¼•
void good_function(lua_State *L) {
    int saved_index = lua_gettop(L);  // ä¿å­˜ç´¢å¼•
    
    // ... æ“ä½œ
    lua_checkstack(L, 100);  // å®‰å…¨
    
    // âœ… é€šè¿‡ç´¢å¼•è®¿é—®ï¼ˆè‡ªåŠ¨å¤„ç†åœ°å€å˜åŒ–ï¼‰
    lua_pushvalue(L, saved_index);
}

// âœ… æ­£ç¡®ï¼šä¿å­˜ç›¸å¯¹åç§»
void better_function(lua_State *L) {
    ptrdiff_t saved_offset = savestack(L, L->top);  // ä¿å­˜åç§»
    
    // ... æ“ä½œ
    lua_checkstack(L, 100);  // å®‰å…¨
    
    // âœ… æ¢å¤æŒ‡é’ˆ
    StkId saved = restorestack(L, saved_offset);
}
```

---

### 4. å†…å­˜æ³„æ¼æ£€æµ‹

#### æ£€æµ‹æ ˆæœªæ­£ç¡®æ¸…ç†

```c
// è°ƒè¯•åŒ…è£…å™¨ï¼šç¡®ä¿æ ˆå¹³è¡¡
int debug_pcall(lua_State *L, int nargs, int nresults, int errfunc) {
    int top_before = lua_gettop(L);
    
    int status = lua_pcall(L, nargs, nresults, errfunc);
    
    int top_after = lua_gettop(L);
    int expected = top_before - nargs + (status == 0 ? nresults : 1);
    
    if (top_after != expected) {
        fprintf(stderr, "WARNING: Stack imbalance! "
                        "before=%d, after=%d, expected=%d\n",
                top_before, top_after, expected);
    }
    
    return status;
}
```

#### Lua ä¾§æ£€æµ‹

```lua
-- æ ˆå¹³è¡¡æ£€æµ‹è£…é¥°å™¨
function with_stack_check(func)
    return function(...)
        local top_before = debug.getinfo(1, "t").nparams
        local results = {func(...)}
        local top_after = #results
        
        -- ç®€å•æ£€æµ‹ï¼ˆä¸å®Œå…¨å‡†ç¡®ï¼‰
        if top_after > top_before + 10 then
            print("WARNING: Possible stack leak in", debug.getinfo(func, "n").name)
        end
        
        return table.unpack(results)
    end
end
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. C API æ ˆç®¡ç†

#### è§„åˆ™1ï¼šå…ˆæ£€æŸ¥å†ä½¿ç”¨

```c
// âœ… æ­£ç¡®æ¨¡å¼
int my_function(lua_State *L) {
    // 1. è®¡ç®—éœ€è¦çš„ç©ºé—´
    int needed = 10;
    
    // 2. æ£€æŸ¥å¹¶ç¡®ä¿ç©ºé—´
    luaL_checkstack(L, needed, "not enough space");
    
    // 3. å®‰å…¨ä½¿ç”¨
    for (int i = 0; i < 10; i++) {
        lua_pushnumber(L, i);
    }
    
    return 10;
}

// âŒ é”™è¯¯æ¨¡å¼
int bad_function(lua_State *L) {
    // ç›´æ¥ä½¿ç”¨ï¼Œå¯èƒ½æº¢å‡º
    for (int i = 0; i < 10000; i++) {
        lua_pushnumber(L, i);  // å±é™©ï¼
    }
    return 10000;
}
```

#### è§„åˆ™2ï¼šä½¿ç”¨ç´¢å¼•è€ŒéæŒ‡é’ˆ

```c
// âœ… æ¨èï¼šä½¿ç”¨ç´¢å¼•
void process_table(lua_State *L, int table_index) {
    lua_pushnil(L);  // ç¬¬ä¸€ä¸ªkey
    
    while (lua_next(L, table_index) != 0) {
        // key at -2, value at -1
        
        // ä½¿ç”¨è´Ÿç´¢å¼•ï¼ˆç›¸å¯¹æ ˆé¡¶ï¼‰
        const char *key = lua_tostring(L, -2);
        int value = lua_tointeger(L, -1);
        
        printf("%s = %d\n", key, value);
        
        lua_pop(L, 1);  // ç§»é™¤ valueï¼Œä¿ç•™ key
    }
}

// âŒ é¿å…ï¼šä¿å­˜æŒ‡é’ˆ
void bad_process_table(lua_State *L) {
    StkId table = L->top - 1;  // å±é™©ï¼
    
    // ... å¦‚æœè§¦å‘ GC æˆ–æ ˆå¢é•¿ï¼Œtable å¤±æ•ˆ
}
```

#### è§„åˆ™3ï¼šæ­£ç¡®æ¸…ç†æ ˆ

```c
// âœ… æ˜¾å¼æ¸…ç†
int create_table(lua_State *L) {
    lua_newtable(L);
    
    // å¡«å……è¡¨
    lua_pushstring(L, "x");
    lua_pushnumber(L, 10);
    lua_settable(L, -3);
    
    lua_pushstring(L, "y");
    lua_pushnumber(L, 20);
    lua_settable(L, -3);
    
    // è¿”å› 1 ä¸ªç»“æœï¼ˆè¡¨ï¼‰
    return 1;  // æ ˆä¸Šåªå‰©è¡¨
}

// âŒ å¿˜è®°æ¸…ç†
int bad_create_table(lua_State *L) {
    lua_newtable(L);
    
    lua_pushstring(L, "x");
    lua_pushnumber(L, 10);
    lua_settable(L, -3);
    
    // å¿˜è®°æ¸…ç†ä¸­é—´å€¼
    return 1;  // æ ˆä¸Šå¯èƒ½æœ‰åƒåœ¾å€¼
}
```

---

### 2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### æŠ€å·§1ï¼šæ‰¹é‡æ“ä½œ

```c
// âœ… é«˜æ•ˆï¼šä¸€æ¬¡æ£€æŸ¥ï¼Œæ‰¹é‡æ“ä½œ
void batch_push(lua_State *L, int *values, int n) {
    luaL_checkstack(L, n, "too many values");
    
    for (int i = 0; i < n; i++) {
        lua_pushnumber(L, values[i]);
    }
}

// âŒ ä½æ•ˆï¼šæ¯æ¬¡éƒ½æ£€æŸ¥
void slow_push(lua_State *L, int *values, int n) {
    for (int i = 0; i < n; i++) {
        luaL_checkstack(L, 1, NULL);  // n æ¬¡æ£€æŸ¥ï¼
        lua_pushnumber(L, values[i]);
    }
}
```

#### æŠ€å·§2ï¼šé¿å…ä¸å¿…è¦çš„æ ˆæ“ä½œ

```lua
-- âœ… é«˜æ•ˆï¼šç›´æ¥è¿”å›
function sum(a, b, c)
    return a + b + c  -- ç›´æ¥åœ¨æ ˆä¸Šè®¡ç®—
end

-- âŒ ä½æ•ˆï¼šä¸å¿…è¦çš„ä¸´æ—¶å˜é‡
function slow_sum(a, b, c)
    local temp1 = a + b  -- é¢å¤–çš„æ ˆæ“ä½œ
    local temp2 = temp1 + c
    return temp2
end
```

#### æŠ€å·§3ï¼šé‡ç”¨æ ˆæ§½ä½

```c
// âœ… é‡ç”¨ï¼šåŸåœ°ä¿®æ”¹
void process_array(lua_State *L, int array_index) {
    int len = lua_objlen(L, array_index);
    
    for (int i = 1; i <= len; i++) {
        lua_rawgeti(L, array_index, i);  // push value
        
        // å¤„ç† valueï¼ˆåœ¨æ ˆé¡¶ï¼‰
        int value = lua_tointeger(L, -1);
        value *= 2;
        
        // å†™å›ï¼ˆé‡ç”¨æ ˆæ§½ä½ï¼‰
        lua_pushinteger(L, value);
        lua_rawseti(L, array_index, i);
        
        lua_pop(L, 1);  // æ¸…ç†
    }
}
```

---

### 3. é”™è¯¯å¤„ç†

#### å®‰å…¨çš„æ ˆæ“ä½œ

```c
// âœ… ä½¿ç”¨ pcall ä¿æŠ¤
int safe_operation(lua_State *L) {
    // å‡†å¤‡å‡½æ•°å’Œå‚æ•°
    lua_getglobal(L, "some_function");
    lua_pushnumber(L, 42);
    
    // ä¿æŠ¤è°ƒç”¨
    int status = lua_pcall(L, 1, 1, 0);
    
    if (status != 0) {
        const char *msg = lua_tostring(L, -1);
        fprintf(stderr, "Error: %s\n", msg);
        lua_pop(L, 1);  // æ¸…ç†é”™è¯¯å¯¹è±¡
        return -1;
    }
    
    // å¤„ç†ç»“æœ
    int result = lua_tointeger(L, -1);
    lua_pop(L, 1);
    
    return result;
}
```

#### æ ˆå±•å¼€æ¸…ç†

```c
// âœ… ç¡®ä¿æ¸…ç†ï¼ˆä½¿ç”¨ lua_settopï¼‰
int complex_operation(lua_State *L) {
    int top = lua_gettop(L);  // ä¿å­˜åˆå§‹æ ˆé¡¶
    
    // ... å¤æ‚æ“ä½œï¼Œå¯èƒ½å‡ºé”™
    lua_getglobal(L, "func1");
    lua_getglobal(L, "func2");
    // ...
    
    if (some_error_condition) {
        lua_settop(L, top);  // æ¢å¤æ ˆé¡¶ï¼ˆæ¸…ç†æ‰€æœ‰pushï¼‰
        return luaL_error(L, "operation failed");
    }
    
    // ... æ­£å¸¸è·¯å¾„
    
    lua_settop(L, top + results);  // ç¡®ä¿åªè¿”å›ç»“æœ
    return results;
}
```

---

## â“ å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆæ ˆæ‰©å±•åæŒ‡é’ˆä¼šå¤±æ•ˆï¼Ÿ

**A**: å› ä¸º `realloc` å¯èƒ½ç§»åŠ¨å†…å­˜å—ã€‚

```c
// realloc çš„ä¸¤ç§è¡Œä¸ºï¼š
void *realloc(void *ptr, size_t new_size) {
    // æƒ…å†µ1ï¼šåŸåœ°æ‰©å±•ï¼ˆå¦‚æœåé¢æœ‰è¶³å¤Ÿç©ºé—´ï¼‰
    if (can_expand_in_place(ptr, new_size)) {
        extend_block(ptr, new_size);
        return ptr;  // åœ°å€ä¸å˜
    }
    
    // æƒ…å†µ2ï¼šåˆ†é…æ–°å—ï¼ˆæ›´å¸¸è§ï¼‰
    void *new_ptr = malloc(new_size);
    memcpy(new_ptr, ptr, old_size);
    free(ptr);
    return new_ptr;  // åœ°å€æ”¹å˜ï¼
}

// Lua å¿…é¡»å‡è®¾åœ°å€æ€»æ˜¯æ”¹å˜
// â†’ æ‰€æœ‰æŒ‡é’ˆéƒ½éœ€è¦è°ƒæ•´
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ä½¿ç”¨æ ˆç´¢å¼•ï¼ˆ`int`ï¼‰è€ŒéæŒ‡é’ˆï¼ˆ`StkId`ï¼‰
- æˆ–ä½¿ç”¨ `savestack/restorestack` ä¿å­˜åç§»é‡

---

### Q2: ä»€ä¹ˆæ—¶å€™ä¼šè§¦å‘æ ˆå¢é•¿ï¼Ÿ

**A**: ä¸»è¦åœ¨ä»¥ä¸‹æƒ…å†µï¼š

1. **å‡½æ•°è°ƒç”¨å‰**ï¼ˆ`luaD_precall`ï¼‰
   ```c
   luaD_checkstack(L, p->maxstacksize);
   ```

2. **å¯å˜å‚æ•°å¤„ç†**ï¼ˆ`adjust_varargs`ï¼‰
   ```c
   luaD_checkstack(L, p->maxstacksize);
   ```

3. **C API æ˜¾å¼æ£€æŸ¥**
   ```c
   lua_checkstack(L, n);
   luaL_checkstack(L, n, msg);
   ```

4. **è¡¨æ„é€ **ï¼ˆå¤§é‡å…ƒç´ ï¼‰
5. **å­—ç¬¦ä¸²è¿æ¥**ï¼ˆå¤šä¸ªæ“ä½œæ•°ï¼‰

---

### Q3: å¦‚ä½•é¿å… "C stack overflow" é”™è¯¯ï¼Ÿ

**A**: ä¸‰ç§æ–¹æ³•ï¼š

```lua
-- æ–¹æ³•1ï¼šä½¿ç”¨å°¾è°ƒç”¨ä¼˜åŒ–
function tail_recursive(n, acc)
    if n == 0 then return acc end
    return tail_recursive(n - 1, acc + n)  -- å°¾è°ƒç”¨
end

-- æ–¹æ³•2ï¼šæ”¹ç”¨å¾ªç¯
function iterative(n)
    local acc = 0
    for i = 1, n do
        acc = acc + i
    end
    return acc
end

-- æ–¹æ³•3ï¼šä½¿ç”¨åç¨‹åˆ†æ®µå¤„ç†
function coroutine_process(data)
    return coroutine.create(function()
        for i, v in ipairs(data) do
            process(v)
            if i % 100 == 0 then
                coroutine.yield()  -- å®šæœŸè®©å‡ºæ§åˆ¶
            end
        end
    end)
end
```

---

### Q4: æ ˆå¢é•¿ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ

**A**: å½±å“å¾ˆå°ï¼Œå› ä¸ºï¼š

1. **æ‘Šé”€ O(1)**ï¼šåŒå€å¢é•¿ç­–ç•¥
2. **æ¬¡æ•°å°‘**ï¼šlogâ‚‚ n æ¬¡é‡åˆ†é…
3. **é¢„åˆ†é…**ï¼šå‡½æ•°è°ƒç”¨æ—¶ä¸€æ¬¡æ€§åˆ†é…è¶³å¤Ÿç©ºé—´

**å®æµ‹æ•°æ®**ï¼š
```
å¢é•¿åˆ° 100 ä¸‡æ§½ä½ï¼š
- é‡åˆ†é…æ¬¡æ•°ï¼š~15 æ¬¡
- æ€»æ—¶é—´ï¼š< 10 ms
- å¹³å‡æ¯æ¬¡ï¼š< 1 ms
```

**å¯¹æ¯”**ï¼š
- Lua å‡½æ•°è°ƒç”¨å¼€é”€ï¼š~50 ns
- æ ˆæ‰©å±•æ‘Šé”€å¼€é”€ï¼š~10 ns/æ“ä½œ

---

### Q5: å¦‚ä½•è°ƒè¯•æ ˆç›¸å…³çš„å´©æºƒï¼Ÿ

**A**: è°ƒè¯•æ­¥éª¤ï¼š

```c
// æ­¥éª¤1ï¼šå¯ç”¨æ ˆæ£€æŸ¥
#define LUA_DEBUG 1  // ç¼–è¯‘æ—¶å®šä¹‰

// æ­¥éª¤2ï¼šæ·»åŠ è¯Šæ–­ä»£ç 
void debug_check_stack(lua_State *L, const char *location) {
    printf("[%s] Stack state:\n", location);
    printf("  stack:      %p\n", L->stack);
    printf("  top:        %p (offset %ld)\n", L->top, L->top - L->stack);
    printf("  base:       %p (offset %ld)\n", L->base, L->base - L->stack);
    printf("  stack_last: %p (offset %ld)\n", 
           L->stack_last, L->stack_last - L->stack);
    
    // æ£€æŸ¥æŒ‡é’ˆæœ‰æ•ˆæ€§
    assert(L->stack <= L->base);
    assert(L->base <= L->top);
    assert(L->top <= L->stack_last);
    assert(L->stack_last <= L->stack + L->stacksize);
}

// æ­¥éª¤3ï¼šåœ¨å…³é”®ç‚¹æ’å…¥æ£€æŸ¥
int my_function(lua_State *L) {
    debug_check_stack(L, "my_function start");
    
    // ... æ“ä½œ
    
    debug_check_stack(L, "my_function end");
    return 0;
}

// æ­¥éª¤4ï¼šä½¿ç”¨å†…å­˜è°ƒè¯•å·¥å…·
// valgrind --leak-check=full ./lua script.lua
// AddressSanitizer (clang -fsanitize=address)
```

---

### Q6: ä¸ºä»€ä¹ˆä¸ä½¿ç”¨æ®µå¼æ ˆï¼ˆsegmented stackï¼‰ï¼Ÿ

**A**: æƒè¡¡è€ƒè™‘ï¼š

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | Luaé€‰æ‹© |
|------|------|------|---------|
| **è¿ç»­æ ˆ** | ç®€å•ã€å¿«é€Ÿ | éœ€è¦é‡åˆ†é… | âœ… |
| **æ®µå¼æ ˆ** | æ— éœ€é‡åˆ†é… | å¤æ‚ã€æ…¢ã€ç¢ç‰‡ | âŒ |

**æ®µå¼æ ˆçš„é—®é¢˜**ï¼š
```c
// æ®µå¼æ ˆéœ€è¦é—´æ¥è®¿é—®
#define stack_get(L, i) \
    ((i) < SEGMENT_SIZE ? \
        (L)->stack1[i] : \
        (L)->stack2[(i) - SEGMENT_SIZE])  // åˆ†æ”¯ï¼

// vs è¿ç»­æ ˆçš„ç›´æ¥è®¿é—®
#define stack_get(L, i) ((L)->stack[i])  // æ— åˆ†æ”¯
```

**æ€§èƒ½å½±å“**ï¼š
- è¿ç»­æ ˆï¼š~2 cycles/è®¿é—®
- æ®µå¼æ ˆï¼š~5-10 cycles/è®¿é—®ï¼ˆåŒ…å«åˆ†æ”¯é¢„æµ‹å¤±è´¥ï¼‰

---

## ğŸ“š å‚è€ƒèµ„æº

### æ ¸å¿ƒè®ºæ–‡

1. **"The Implementation of Lua 5.0"** (2005)
   - è¯¦ç»†ä»‹ç»äº†å¯„å­˜å™¨è™šæ‹Ÿæœºå’Œæ ˆç®¡ç†
   - [ä¸‹è½½åœ°å€](https://www.lua.org/doc/jucs05.pdf)

2. **"Dynamic Storage Allocation: A Survey and Critical Review"** (1995)
   - åŠ¨æ€å†…å­˜åˆ†é…ç­–ç•¥çš„ç»å…¸ç»¼è¿°
   - åŒ…æ‹¬åŒå€å¢é•¿ç­–ç•¥çš„åˆ†æ

### ç›¸å…³æ–‡æ¡£

- [Lua 5.1 æºç æ³¨é‡Š](https://github.com/lichuang/Lua-Source-Internal)
- [C API æ ˆç®¡ç†æŒ‡å—](http://www.lua.org/pil/24.2.html)
- [å‡½æ•°è°ƒç”¨æœºåˆ¶è¯¦è§£](function_call.md)

### åœ¨çº¿èµ„æº

- [Lua Users Wiki - Stack Overflow](http://lua-users.org/wiki/StackOverFlow)
- [Stack Overflow: Lua Stack Management](https://stackoverflow.com/questions/tagged/lua+stack)

---

## âœ… å­¦ä¹ æ£€æŸ¥æ¸…å•

### åŸºç¡€ç†è§£ (å¿…é¡»æŒæ¡)

- [ ] ç†è§£ Lua æ ˆçš„ç‰©ç†ç»“æ„å’Œé€»è¾‘åˆ†å±‚
- [ ] æŒæ¡ `stack`ã€`base`ã€`top`ã€`stack_last` çš„å«ä¹‰
- [ ] ç†è§£åŒå€å¢é•¿ç­–ç•¥çš„åŸç†å’Œä¼˜åŠ¿
- [ ] äº†è§£ `luaD_checkstack` çš„ä½¿ç”¨æ—¶æœº

### è¿›é˜¶æŒæ¡ (æ¨èæŒæ¡)

- [ ] ç†è§£æŒ‡é’ˆè°ƒæ•´ç®—æ³•çš„å¿…è¦æ€§
- [ ] æŒæ¡ `correctstack` çš„å®Œæ•´å®ç°
- [ ] ç†è§£ upvalue æŒ‡é’ˆè°ƒæ•´æœºåˆ¶
- [ ] æŒæ¡æ ˆæ‰©å±•çš„å®Œæ•´æµç¨‹
- [ ] äº†è§£ EXTRA_STACK çš„ä½œç”¨

### é«˜çº§åº”ç”¨ (ä¸“å®¶çº§)

- [ ] èƒ½åœ¨ C API ä¸­æ­£ç¡®ç®¡ç†æ ˆç©ºé—´
- [ ] èƒ½è¯Šæ–­å’Œä¿®å¤æ ˆç›¸å…³çš„å´©æºƒ
- [ ] ç†è§£æ ˆç®¡ç†çš„æ€§èƒ½ç‰¹å¾
- [ ] èƒ½åˆ†æå’Œä¼˜åŒ–æ ˆæ“ä½œæ€§èƒ½
- [ ] ç†è§£è®¾è®¡æƒè¡¡å’Œæ›¿ä»£æ–¹æ¡ˆ

### å®è·µæŠ€èƒ½

- [ ] èƒ½æ­£ç¡®ä½¿ç”¨ `lua_checkstack`
- [ ] èƒ½ä½¿ç”¨æ ˆç´¢å¼•è€ŒéæŒ‡é’ˆ
- [ ] èƒ½å®ç°æ ˆå¹³è¡¡çš„ C å‡½æ•°
- [ ] èƒ½ä½¿ç”¨è°ƒè¯•å·¥å…·è¯Šæ–­æ ˆé—®é¢˜
- [ ] èƒ½ä¼˜åŒ–æ‰¹é‡æ ˆæ“ä½œçš„æ€§èƒ½

---

## ğŸ”„ ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´ |
|------|------|------|
| v1.0 | 2025-01-26 | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæ•´çš„ DeepWiki æ–‡æ¡£ |

---

<div align="center">

**ğŸ“– ç»§ç»­å­¦ä¹ **

[â† è¿”å›è¿è¡Œæ—¶æ¨¡å—](wiki_runtime.md) Â· [ä¸‹ä¸€ä¸»é¢˜ï¼šè°ƒè¯•é’©å­ â†’](debug_hooks.md)

**ç›¸å…³æ·±å…¥ä¸»é¢˜**

[å‡½æ•°è°ƒç”¨æœºåˆ¶](function_call.md) Â· [CallInfoç®¡ç†](callinfo_management.md) Â· [åç¨‹å®ç°](coroutine.md)

---

*ğŸ“… æœ€åæ›´æ–°ï¼š2025-01-26*  
*ğŸ“ æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*ğŸ”– é€‚ç”¨Luaç‰ˆæœ¬ï¼š5.1.5*

**æ ˆç®¡ç†æ˜¯ Lua è¿è¡Œæ—¶çš„å†…å­˜åŸºç¡€**  
*ç†è§£å®ƒï¼Œå°±ç†è§£äº† Lua å¦‚ä½•é«˜æ•ˆè€Œå®‰å…¨åœ°ç®¡ç†æ‰§è¡ŒçŠ¶æ€*

</div>

