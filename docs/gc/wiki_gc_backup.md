# ♻️ 垃圾回收模块总览

> **模块定位**：Lua 自动内存管理的核心

## 📋 模块概述

垃圾回收（GC）模块采用**三色标记增量回收算法**，自动识别和回收不再使用的对象。增量回收将 GC 工作分散到多个小步骤中，避免长时间停顿。

### 核心文件

- `lgc.c/h` - 垃圾回收器实现

## 🎯 核心技术

### 1. 三色标记算法

**对象颜色状态**：

- **白色（White）**：未被标记的对象，潜在的垃圾对象
- **灰色（Gray）**：已被标记但未完成扫描的对象
- **黑色（Black）**：已完成扫描的活跃对象

**状态转换**：
```
White → Gray → Black → White (新GC周期)
```

### 2. 增量回收机制

**GC 阶段**：

1. **Pause（暂停）**：GC 开始前的准备阶段
2. **Propagate（传播）**：标记灰色对象，将其变为黑色
3. **Atomic（原子）**：完成剩余的标记工作
4. **Sweep String（清扫字符串）**：回收未标记的字符串
5. **Sweep（清扫）**：回收未标记的其他对象

**增量执行**：
- 每次执行少量 GC 工作
- 与程序执行交替进行
- 通过 `gcstepmul` 参数调节工作量

### 3. 写屏障技术

**问题**：增量回收过程中，程序可能修改对象引用关系，导致活跃对象被误回收。

**解决**：写屏障在对象引用被修改时，确保新引用的对象被正确标记。

**实现**：
```c
#define luaC_barrier(L,p,v) { \
    if (iscollectable(v) && isblack(obj2gco(p)) && iswhite(gcvalue(v))) \
        luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
```

### 4. 终结器（Finalizer）

**功能**：对象被回收前执行清理操作（`__gc` 元方法）

**实现**：
- 带终结器的对象单独管理
- 回收前调用终结器
- 终结器可能复活对象

### 5. 弱引用表

**三种弱引用模式**：
- **弱键表**：键被回收时，整个键值对被删除
- **弱值表**：值被回收时，整个键值对被删除
- **全弱表**：键或值被回收时，键值对都被删除

**应用**：缓存、对象注册表等

### 6. GC 调优参数

**gcpause（默认 200）**：
- 控制 GC 触发频率
- 值越小，GC 越频繁，内存使用越少
- 值越大，GC 越少，但内存使用更多

**gcstepmul（默认 200）**：
- 控制每次 GC 步进的工作量
- 值越小，每次工作越少，停顿时间短
- 值越大，每次工作越多，总开销小

## 📚 详细技术文档

- [三色标记算法](tri_color_marking.md) - 标记算法的详细实现
- [增量回收机制](incremental_gc.md) - 增量回收的工作流程
- [写屏障实现](write_barrier.md) - 写屏障的工作原理
- [终结器机制](finalizer_mechanism.md) - 终结器的实现细节
- [弱引用表](weak_tables.md) - 弱引用表的实现
- [GC 性能调优](gc_tuning.md) - GC 参数调优指南

## 🔗 相关模块

- [内存管理模块](../memory/wiki_memory.md) - 提供内存分配接口
- [对象系统模块](../object/wiki_object.md) - GC 管理的对象类型
- [运行时模块](../runtime/wiki_runtime.md) - GC 与程序执行的协作

---

*继续阅读：[三色标记算法](tri_color_marking.md)*
