# Lua è¯­å¥è§£æç³»ç»Ÿï¼šé€’å½’ä¸‹é™å®ç°æ·±åº¦å‰–æ

> **å‰ç½®é˜…è¯»**ï¼š  
> 1. [recursive_descent_parser_guide.md](recursive_descent_parser_guide.md) - é€’å½’ä¸‹é™è§£æç†è®ºåŸºç¡€  
> 2. [lua_recursive_descent_implementation.md](lua_recursive_descent_implementation.md) - Lua è§£æå™¨å®Œæ•´å®ç°  
> 3. [expression_precedence_climbing.md](expression_precedence_climbing.md) - è¡¨è¾¾å¼è§£æç³»ç»Ÿè¯¦è§£

---

## ğŸ“‹ æ–‡æ¡£å¯¼èˆª

- [å¼•è¨€](#å¼•è¨€)
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šè¯­å¥è§£ææ¶æ„æ¦‚è§ˆ](#ç¬¬ä¸€éƒ¨åˆ†è¯­å¥è§£ææ¶æ„æ¦‚è§ˆ)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šæ¡ä»¶æ§åˆ¶è¯­å¥](#ç¬¬äºŒéƒ¨åˆ†æ¡ä»¶æ§åˆ¶è¯­å¥)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¾ªç¯æ§åˆ¶è¯­å¥](#ç¬¬ä¸‰éƒ¨åˆ†å¾ªç¯æ§åˆ¶è¯­å¥)
- [ç¬¬å››éƒ¨åˆ†ï¼šèµ‹å€¼ä¸å‡½æ•°è°ƒç”¨](#ç¬¬å››éƒ¨åˆ†èµ‹å€¼ä¸å‡½æ•°è°ƒç”¨)
- [ç¬¬äº”éƒ¨åˆ†ï¼šä½œç”¨åŸŸç®¡ç†](#ç¬¬äº”éƒ¨åˆ†ä½œç”¨åŸŸç®¡ç†)
- [ç¬¬å…­éƒ¨åˆ†ï¼šè·³è½¬è¯­å¥å¤„ç†](#ç¬¬å…­éƒ¨åˆ†è·³è½¬è¯­å¥å¤„ç†)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šé”™è¯¯æ¢å¤æœºåˆ¶](#ç¬¬ä¸ƒéƒ¨åˆ†é”™è¯¯æ¢å¤æœºåˆ¶)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå®è·µä¸è°ƒè¯•](#ç¬¬å…«éƒ¨åˆ†å®è·µä¸è°ƒè¯•)
- [é™„å½•](#é™„å½•)

---

## ğŸ¯ å¼•è¨€

### æ–‡æ¡£å®šä½

æœ¬æ–‡æ¡£æ˜¯å¯¹ Lua 5.1.5 é€’å½’ä¸‹é™è§£æå™¨ä¸­**è¯­å¥è§£æç³»ç»Ÿ**çš„æ·±åº¦ä¸“é¢˜åˆ†æã€‚è¯­å¥è§£ææ˜¯ç¼–è¯‘å™¨å‰ç«¯çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œè´Ÿè´£å°†ç¨‹åºçš„æ§åˆ¶æµç»“æ„è½¬æ¢ä¸ºå¯æ‰§è¡Œçš„å­—èŠ‚ç æŒ‡ä»¤ã€‚æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ Lua å¦‚ä½•å¤„ç†å„ç§è¯­å¥ç±»å‹ï¼Œä»¥åŠå®ƒä»¬å¦‚ä½•ä¸ä»£ç ç”Ÿæˆå™¨ååŒå·¥ä½œã€‚

### ä¸ºä»€ä¹ˆéœ€è¦è¿™ä»½æ–‡æ¡£ï¼Ÿ

åœ¨å­¦ä¹  Lua è§£æå™¨çš„è¯­å¥å¤„ç†æ—¶ï¼Œå¼€å‘è€…ç»å¸¸é‡åˆ°ä»¥ä¸‹å›°æƒ‘ï¼š

â“ **é—®é¢˜1**ï¼šå¦‚ä½•åŒºåˆ†èµ‹å€¼è¯­å¥å’Œå‡½æ•°è°ƒç”¨ï¼Ÿ  
â“ **é—®é¢˜2**ï¼šif-elseif-else é“¾çš„è·³è½¬æ˜¯å¦‚ä½•ç®¡ç†å’Œå›å¡«çš„ï¼Ÿ  
â“ **é—®é¢˜3**ï¼šå¾ªç¯è¯­å¥çš„ break å¦‚ä½•è·³è½¬åˆ°æ­£ç¡®çš„ä½ç½®ï¼Ÿ  
â“ **é—®é¢˜4**ï¼šå—ä½œç”¨åŸŸå¦‚ä½•å½±å“å˜é‡çš„ç”Ÿå‘½å‘¨æœŸï¼Ÿ  
â“ **é—®é¢˜5**ï¼šrepeat-until ä¸ºä»€ä¹ˆèƒ½åœ¨æ¡ä»¶ä¸­è®¿é—®å¾ªç¯ä½“çš„å˜é‡ï¼Ÿ  

æœ¬æ–‡æ¡£å°†**ç³»ç»Ÿè§£ç­”**è¿™äº›é—®é¢˜ï¼Œå¹¶æä¾›ï¼š

âœ… è¯¦ç»†çš„è¯­å¥è§£ææµç¨‹åˆ†æ  
âœ… å®Œæ•´çš„æºç é€è¡Œæ³¨é‡Š  
âœ… å¯è§†åŒ–çš„æ§åˆ¶æµæ„å»ºè¿‡ç¨‹  
âœ… è·³è½¬é“¾è¡¨ç®¡ç†çš„æ·±å…¥è®²è§£  
âœ… å®é™…çš„è°ƒè¯•æŠ€å·§å’Œæ‰©å±•æ–¹æ³•  

### é˜…è¯»å»ºè®®

**é€‚åˆè¯»è€…**ï¼š
- å·²ç†è§£è¡¨è¾¾å¼è§£ææœºåˆ¶ï¼Œå¸Œæœ›æŒæ¡è¯­å¥è§£æ
- æ­£åœ¨å®ç°æ”¯æŒå¤æ‚æ§åˆ¶æµçš„è§£æå™¨
- éœ€è¦è°ƒè¯•è¯­å¥è§£æç›¸å…³é—®é¢˜
- æƒ³è¦ç†è§£ Lua æ§åˆ¶æµçš„å­—èŠ‚ç ç”Ÿæˆ

**é˜…è¯»è·¯çº¿**ï¼š
1. **å¿«é€Ÿç†è§£å‹**ï¼šé˜…è¯»ç¬¬ä¸€ã€äºŒéƒ¨åˆ†ï¼ŒæŒæ¡æ ¸å¿ƒæ¶æ„
2. **æ·±å…¥å­¦ä¹ å‹**ï¼šå®Œæ•´é˜…è¯»ï¼Œé…åˆæºç å®è·µ
3. **é—®é¢˜é©±åŠ¨å‹**ï¼šç›´æ¥è·³è½¬åˆ°ç›¸å…³è¯­å¥ç±»å‹çš„ç« èŠ‚

### æ–‡æ¡£ç»“æ„è¯´æ˜

æœ¬æ–‡æ¡£æŒ‰ç…§è¯­å¥ç±»å‹åˆ†ç« èŠ‚ï¼Œæ¯ä¸ªç« èŠ‚åŒ…å«ï¼š

- **è¯­æ³•è§„åˆ™**ï¼šBNF å½¢å¼çš„æ–‡æ³•å®šä¹‰
- **å®ç°åˆ†æ**ï¼šæºç è¯¦ç»†æ³¨é‡Šå’Œè§£è¯»
- **æ‰§è¡Œè·Ÿè¸ª**ï¼šé€æ­¥çš„è§£æè¿‡ç¨‹æ¼”ç¤º
- **å­—èŠ‚ç ç”Ÿæˆ**ï¼šå®é™…ç”Ÿæˆçš„æŒ‡ä»¤åºåˆ—
- **æ§åˆ¶æµå›¾**ï¼šå¯è§†åŒ–çš„è·³è½¬å…³ç³»

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè¯­å¥è§£ææ¶æ„æ¦‚è§ˆ

### 1.1 è¯­å¥åˆ†ç±»ä½“ç³»

Lua çš„è¯­å¥ç³»ç»Ÿå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ å¤§ç±»ï¼š

#### è¯­å¥åˆ†ç±»è¡¨

| ç±»åˆ« | è¯­å¥ | å…³é”®ç‰¹æ€§ | å¤æ‚åº¦ |
|------|------|----------|--------|
| **æ§åˆ¶æµ** | `if`, `while`, `repeat`, `for` | æ¡ä»¶è·³è½¬ã€å¾ªç¯ | é«˜ |
| **èµ‹å€¼** | å˜é‡èµ‹å€¼ã€å¤šé‡èµ‹å€¼ | å·¦å€¼è¯†åˆ«ã€ç±»å‹æ¨æ–­ | ä¸­ |
| **å‡½æ•°ç›¸å…³** | å‡½æ•°è°ƒç”¨ã€è¿”å›è¯­å¥ | å‚æ•°å¤„ç†ã€è¿”å›å€¼ | ä¸­ |
| **ä½œç”¨åŸŸ** | `do-end`, `local` | å˜é‡ç”Ÿå‘½å‘¨æœŸ | ä¸­ |
| **è·³è½¬** | `break`, `return` | è·³è½¬é“¾è¡¨ç®¡ç† | ä½ |
| **å…¶ä»–** | ç©ºè¯­å¥ `;` | å ä½ç¬¦ | ä½ |

#### å®Œæ•´çš„ BNF æ–‡æ³•

```bnf
chunk ::= {stat [';']}

stat ::= 
    | ';'                                          -- ç©ºè¯­å¥
    | varlist '=' explist                          -- èµ‹å€¼
    | functioncall                                 -- å‡½æ•°è°ƒç”¨
    | 'do' block 'end'                             -- doå—
    | 'while' exp 'do' block 'end'                 -- whileå¾ªç¯
    | 'repeat' block 'until' exp                   -- repeatå¾ªç¯
    | 'if' exp 'then' block 
      {'elseif' exp 'then' block} ['else' block] 'end'  -- ifè¯­å¥
    | 'for' NAME '=' exp ',' exp [',' exp] 'do' block 'end'  -- æ•°å€¼for
    | 'for' namelist 'in' explist 'do' block 'end' -- é€šç”¨for
    | 'function' funcname funcbody                 -- å‡½æ•°å®šä¹‰
    | 'local' 'function' NAME funcbody             -- å±€éƒ¨å‡½æ•°
    | 'local' namelist ['=' explist]               -- å±€éƒ¨å˜é‡
    | 'return' [explist]                           -- è¿”å›è¯­å¥
    | 'break'                                      -- è·³å‡ºå¾ªç¯

block ::= chunk

varlist ::= var {',' var}
var ::= NAME | prefixexp '[' exp ']' | prefixexp '.' NAME

namelist ::= NAME {',' NAME}
explist ::= {exp ',' } exp
```

### 1.2 è¯­å¥åˆ†å‘æœºåˆ¶

#### æ ¸å¿ƒå‡½æ•°ï¼šstatement()

Lua ä½¿ç”¨å•ä¸€çš„åˆ†å‘å‡½æ•°å¤„ç†æ‰€æœ‰è¯­å¥ç±»å‹ï¼š

```c
// lparser.c
static void statement(LexState *ls) {
    int line = ls->linenumber;  // ä¿å­˜è¡Œå·ï¼ˆç”¨äºé”™è¯¯æŠ¥å‘Šï¼‰
    
    enterlevel(ls);  // é˜²æ­¢æ ˆæº¢å‡º
    
    switch (ls->t.token) {
        case ';': {  // ç©ºè¯­å¥
            luaX_next(ls);  // ç›´æ¥è·³è¿‡
            break;
        }
        
        case TK_IF: {  // if è¯­å¥
            ifstat(ls, line);
            break;
        }
        
        case TK_WHILE: {  // while å¾ªç¯
            whilestat(ls, line);
            break;
        }
        
        case TK_DO: {  // do å—
            luaX_next(ls);  // è·³è¿‡ 'do'
            block(ls);
            check_match(ls, TK_END, TK_DO, line);
            break;
        }
        
        case TK_FOR: {  // for å¾ªç¯ï¼ˆæ•°å€¼æˆ–é€šç”¨ï¼‰
            forstat(ls, line);
            break;
        }
        
        case TK_REPEAT: {  // repeat å¾ªç¯
            repeatstat(ls, line);
            break;
        }
        
        case TK_FUNCTION: {  // å‡½æ•°å®šä¹‰
            funcstat(ls, line);
            break;
        }
        
        case TK_LOCAL: {  // å±€éƒ¨å£°æ˜
            luaX_next(ls);  // è·³è¿‡ 'local'
            if (testnext(ls, TK_FUNCTION))  // local function
                localfunc(ls);
            else
                localstat(ls);
            break;
        }
        
        case TK_RETURN: {  // è¿”å›è¯­å¥
            retstat(ls);
            break;
        }
        
        case TK_BREAK: {  // break è¯­å¥
            luaX_next(ls);  // è·³è¿‡ 'break'
            breakstat(ls);
            break;
        }
        
        default: {  // èµ‹å€¼æˆ–å‡½æ•°è°ƒç”¨
            // æœ€å¤æ‚çš„æƒ…å†µï¼šéœ€è¦å‰çœ‹æ‰èƒ½ç¡®å®š
            exprstat(ls);
            break;
        }
    }
    
    // ç¡®ä¿å•ä¸ªè¯­å¥ä¸ä¼šäº§ç”Ÿè¿‡å¤šçš„æŒ‚èµ·å€¼
    lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
               ls->fs->freereg >= ls->fs->nactvar);
    ls->fs->freereg = ls->fs->nactvar;  // é‡Šæ”¾ä¸´æ—¶å¯„å­˜å™¨
    
    leavelevel(ls);
}
```

#### å…³é”®è®¾è®¡ç‰¹ç‚¹

**1. LL(1) ç‰¹æ€§**

é€šè¿‡ç¬¬ä¸€ä¸ª token å°±èƒ½ç¡®å®šè¯­å¥ç±»å‹ï¼š

```c
// æŸ¥çœ‹ç¬¬ä¸€ä¸ª token å³å¯åˆ†å‘
switch (ls->t.token) {
    case TK_IF:     â†’ if è¯­å¥
    case TK_WHILE:  â†’ while å¾ªç¯
    case TK_FOR:    â†’ for å¾ªç¯
    // ...
    default:        â†’ èµ‹å€¼æˆ–å‡½æ•°è°ƒç”¨ï¼ˆéœ€è¿›ä¸€æ­¥åˆ¤æ–­ï¼‰
}
```

**2. é”™è¯¯ä¿¡æ¯ä¿å­˜**

```c
int line = ls->linenumber;  // ä¿å­˜è¯­å¥å¼€å§‹çš„è¡Œå·
// åç»­å¯ä»¥æŠ¥å‘Š: "expected 'end' (to close 'if' at line X)"
```

**3. æ ˆæº¢å‡ºä¿æŠ¤**

```c
enterlevel(ls);  // è¿›å…¥
// ... å¤„ç†è¯­å¥
leavelevel(ls);  // ç¦»å¼€
```

é˜²æ­¢æ¶æ„æˆ–é”™è¯¯çš„ä»£ç å¯¼è‡´é€’å½’è¿‡æ·±ã€‚

**4. å¯„å­˜å™¨ç®¡ç†**

```c
// è¯­å¥ç»“æŸåé‡Šæ”¾æ‰€æœ‰ä¸´æ—¶å¯„å­˜å™¨
ls->fs->freereg = ls->fs->nactvar;
```

ç¡®ä¿æ¯æ¡è¯­å¥éƒ½ä»"å¹²å‡€"çš„å¯„å­˜å™¨çŠ¶æ€å¼€å§‹ã€‚

### 1.3 å—çš„æ¦‚å¿µä¸ç®¡ç†

#### ä»€ä¹ˆæ˜¯å—ï¼ˆBlockï¼‰ï¼Ÿ

åœ¨ Lua ä¸­ï¼Œ**å—**æ˜¯è¯­å¥çš„é›†åˆï¼Œä¹Ÿæ˜¯**ä½œç”¨åŸŸçš„åŸºæœ¬å•ä½**ï¼š

```lua
-- å‡½æ•°ä½“æ˜¯ä¸€ä¸ªå—
function f()
    local x = 1  -- x çš„ä½œç”¨åŸŸï¼šæ•´ä¸ªå‡½æ•°å—
end

-- do-end åˆ›å»ºæ˜¾å¼å—
do
    local y = 2  -- y çš„ä½œç”¨åŸŸï¼šdo-end å—
end
-- y åœ¨è¿™é‡Œä¸å¯è§

-- æ§åˆ¶ç»“æ„è‡ªå¸¦å—
if condition then
    local z = 3  -- z çš„ä½œç”¨åŸŸï¼šthen å—
end
-- z åœ¨è¿™é‡Œä¸å¯è§
```

#### BlockCnt ç»“æ„å›é¡¾

```c
typedef struct BlockCnt {
    struct BlockCnt *previous;  // å¤–å±‚å—ï¼ˆå½¢æˆæ ˆï¼‰
    int breaklist;              // break è·³è½¬é“¾è¡¨å¤´
    lu_byte nactvar;            // å—å¼€å§‹æ—¶çš„æ´»è·ƒå˜é‡æ•°
    lu_byte upval;              // æ˜¯å¦æœ‰å˜é‡è¢«æ•è·ï¼ˆæˆä¸º upvalueï¼‰
    lu_byte isbreakable;        // æ˜¯å¦å…è®¸ break
} BlockCnt;
```

#### å—æ“ä½œè¯¦è§£

**è¿›å…¥å—**ï¼š

```c
static void enterblock(FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
    bl->breaklist = NO_JUMP;         // åˆå§‹åŒ–è·³è½¬é“¾è¡¨
    bl->isbreakable = isbreakable;   // è®¾ç½®æ˜¯å¦å¯ break
    bl->nactvar = fs->nactvar;       // è®°å½•å½“å‰æ´»è·ƒå˜é‡æ•°
    bl->upval = 0;                   // åˆå§‹åŒ– upvalue æ ‡è®°
    bl->previous = fs->bl;           // é“¾æ¥åˆ°å¤–å±‚å—
    fs->bl = bl;                     // è®¾ä¸ºå½“å‰å—
}
```

**ç¦»å¼€å—**ï¼š

```c
static void leaveblock(FuncState *fs) {
    BlockCnt *bl = fs->bl;
    fs->bl = bl->previous;  // æ¢å¤å¤–å±‚å—
    
    // ç§»é™¤å—å†…å®šä¹‰çš„å±€éƒ¨å˜é‡
    removevars(fs->ls, bl->nactvar);
    
    // å¦‚æœæœ‰ upvalueï¼Œç”Ÿæˆ CLOSE æŒ‡ä»¤
    if (bl->upval)
        luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
    
    // å¦‚æœæ˜¯å¯ break çš„å—ï¼Œå›å¡« break è·³è½¬
    lua_assert(!bl->isbreakable || bl->previous);
    lua_assert(bl->nactvar == fs->nactvar);
    
    // æ¢å¤ç©ºé—²å¯„å­˜å™¨æŒ‡é’ˆ
    fs->freereg = fs->nactvar;
    
    // å›å¡«æ‰€æœ‰ break è·³è½¬åˆ°å½“å‰ä½ç½®
    luaK_patchtohere(fs, bl->breaklist);
}
```

#### å—çš„åµŒå¥—ç¤ºä¾‹

```lua
function outer()           -- å—1ï¼šå‡½æ•°å—
    local a = 1
    
    if condition then      -- å—2ï¼šif å—
        local b = 2
        
        while true do      -- å—3ï¼šwhile å—ï¼ˆå¯ breakï¼‰
            local c = 3
            
            do             -- å—4ï¼šæ˜¾å¼å—
                local d = 4
            end  -- d ç¦»å¼€ä½œç”¨åŸŸ
            
            if x then break end
        end  -- c ç¦»å¼€ä½œç”¨åŸŸ
        
    end  -- b ç¦»å¼€ä½œç”¨åŸŸ
    
end  -- a ç¦»å¼€ä½œç”¨åŸŸ
```

**å—æ ˆæ¼”å˜**ï¼š

```
è¿›å…¥ outer:    å—1 â†’ NULL
è¿›å…¥ if:       å—2 â†’ å—1 â†’ NULL
è¿›å…¥ while:    å—3 â†’ å—2 â†’ å—1 â†’ NULL
è¿›å…¥ do:       å—4 â†’ å—3 â†’ å—2 â†’ å—1 â†’ NULL
ç¦»å¼€ do:       å—3 â†’ å—2 â†’ å—1 â†’ NULL
ç¦»å¼€ while:    å—2 â†’ å—1 â†’ NULL
ç¦»å¼€ if:       å—1 â†’ NULL
ç¦»å¼€ outer:    NULL
```

### 1.4 è·³è½¬é“¾è¡¨ç®¡ç†æ¦‚è¿°

#### ä¸ºä»€ä¹ˆéœ€è¦è·³è½¬é“¾è¡¨ï¼Ÿ

åœ¨è§£ææ—¶ï¼Œè®¸å¤šè·³è½¬çš„ç›®æ ‡ä½ç½®åœ¨ç”Ÿæˆè·³è½¬æŒ‡ä»¤æ—¶**å°šæœªç¡®å®š**ï¼š

```lua
if condition then
    -- ç”Ÿæˆæ¡ä»¶è·³è½¬ï¼šJMP [?]ï¼ˆç›®æ ‡æœªçŸ¥ï¼‰
    block1
else
    -- ç°åœ¨æ‰çŸ¥é“ä¸Šé¢çš„è·³è½¬åº”è¯¥åˆ°è¿™é‡Œ
    block2
end
-- è¿™é‡Œæ˜¯æ‰€æœ‰åˆ†æ”¯çš„æ±‡åˆç‚¹
```

#### è·³è½¬é“¾è¡¨çš„æ•°æ®ç»“æ„

Lua ä½¿ç”¨å·§å¦™çš„è®¾è®¡ï¼š**å°†è·³è½¬é“¾è¡¨ç¼–ç åœ¨æŒ‡ä»¤æœ¬èº«**ï¼š

```c
// JMP æŒ‡ä»¤æ ¼å¼ï¼šsBx å­—æ®µè¡¨ç¤ºè·³è½¬åç§»

// æœªå›å¡«æ—¶ï¼šsBx å­˜å‚¨ä¸‹ä¸€ä¸ªè·³è½¬æŒ‡ä»¤çš„ç›¸å¯¹ä½ç½®
// ä¾‹å¦‚ï¼š
æŒ‡ä»¤[5]:  JMP sBx=7   // è¡¨ç¤ºä¸‹ä¸€ä¸ªè·³è½¬åœ¨ 5+7=12
æŒ‡ä»¤[12]: JMP sBx=6   // è¡¨ç¤ºä¸‹ä¸€ä¸ªè·³è½¬åœ¨ 12+6=18
æŒ‡ä»¤[18]: JMP sBx=-1  // NO_JUMPï¼Œé“¾è¡¨ç»“æŸ

// å›å¡«åï¼šsBx å­˜å‚¨å®é™…çš„è·³è½¬ç›®æ ‡
æŒ‡ä»¤[5]:  JMP sBx=15  // è·³è½¬åˆ°ä½ç½® 5+15=20
æŒ‡ä»¤[12]: JMP sBx=8   // è·³è½¬åˆ°ä½ç½® 12+8=20
æŒ‡ä»¤[18]: JMP sBx=2   // è·³è½¬åˆ°ä½ç½® 18+2=20
```

#### å…³é”®æ“ä½œ

**1. ç”Ÿæˆè·³è½¬å¹¶åŠ å…¥é“¾è¡¨**

```c
int luaK_jump(FuncState *fs) {
    int jpc = fs->jpc;  // ä¿å­˜æ—§é“¾è¡¨å¤´
    int j;
    
    fs->jpc = NO_JUMP;  // æ¸…ç©ºï¼ˆå°†åœ¨ä¸‹æ¬¡ä½¿ç”¨ï¼‰
    
    // ç”Ÿæˆ JMP æŒ‡ä»¤ï¼Œç›®æ ‡æš‚æ—¶æœªçŸ¥
    j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
    
    // è¿æ¥åˆ°é“¾è¡¨
    luaK_concat(fs, &j, jpc);
    
    return j;  // è¿”å›é“¾è¡¨å¤´
}
```

**2. å›å¡«é“¾è¡¨åˆ°æŒ‡å®šä½ç½®**

```c
void luaK_patchlist(FuncState *fs, int list, int target) {
    if (target == fs->pc)
        luaK_patchtohere(fs, list);
    else {
        // éå†é“¾è¡¨ï¼Œé€ä¸ªå›å¡«
        while (list != NO_JUMP) {
            int next = getjump(fs, list);    // è·å–ä¸‹ä¸€ä¸ª
            fixjump(fs, list, target);       // ä¿®æ­£å½“å‰è·³è½¬
            list = next;                     // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª
        }
    }
}
```

**3. åˆå¹¶ä¸¤ä¸ªè·³è½¬é“¾è¡¨**

```c
void luaK_concat(FuncState *fs, int *l1, int l2) {
    if (l2 == NO_JUMP) return;  // l2 ä¸ºç©ºï¼Œæ— éœ€æ“ä½œ
    
    if (*l1 == NO_JUMP)
        *l1 = l2;  // l1 ä¸ºç©ºï¼Œç›´æ¥èµ‹å€¼
    else {
        int list = *l1;
        int next;
        
        // æ‰¾åˆ° l1 çš„æœ«å°¾
        while ((next = getjump(fs, list)) != NO_JUMP)
            list = next;
        
        // è¿æ¥ l2
        fixjump(fs, list, l2);
    }
}
```

è¿™äº›æœºåˆ¶å°†åœ¨åç»­ç« èŠ‚çš„å…·ä½“è¯­å¥è§£æä¸­è¯¦ç»†å±•å¼€ã€‚

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šæ¡ä»¶æ§åˆ¶è¯­å¥

### 2.1 if è¯­å¥å®Œæ•´è§£æ

#### è¯­æ³•ç»“æ„

```bnf
ifstat ::= 'if' exp 'then' block 
           {'elseif' exp 'then' block} 
           ['else' block] 
           'end'
```

#### æ ¸å¿ƒéš¾ç‚¹

if è¯­å¥çš„è§£ææ¶‰åŠä¸‰ä¸ªå…³é”®é—®é¢˜ï¼š

1. **å¤šåˆ†æ”¯ç®¡ç†**ï¼šå¦‚ä½•å¤„ç† if-elseif-elseif-...-else é“¾ï¼Ÿ
2. **è·³è½¬å›å¡«**ï¼šæ¯ä¸ªåˆ†æ”¯ç»“æŸåå¦‚ä½•è·³è½¬åˆ°æ­£ç¡®ä½ç½®ï¼Ÿ
3. **æ¡ä»¶ä»£ç ç”Ÿæˆ**ï¼šå¦‚ä½•ç”Ÿæˆé«˜æ•ˆçš„æ¡ä»¶æµ‹è¯•å’Œè·³è½¬ï¼Ÿ

#### å®Œæ•´å®ç°ä»£ç 

```c
static void ifstat(LexState *ls, int line) {
    // IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
    
    FuncState *fs = ls->fs;
    int flist;          // å‡è·³è½¬é“¾è¡¨ï¼ˆæ¡ä»¶ä¸ºå‡æ—¶çš„è·³è½¬ï¼‰
    int escapelist = NO_JUMP;  // é€ƒé€¸è·³è½¬é“¾è¡¨ï¼ˆè·³å‡ºæ•´ä¸ªifè¯­å¥ï¼‰
    
    // ========== ç¬¬ä¸€é˜¶æ®µï¼šå¤„ç† IF åˆ†æ”¯ ==========
    flist = test_then_block(ls);  // è¿”å›å‡è·³è½¬é“¾è¡¨
    
    // ========== ç¬¬äºŒé˜¶æ®µï¼šå¤„ç† ELSEIF åˆ†æ”¯é“¾ ==========
    while (ls->t.token == TK_ELSEIF) {
        // åœ¨è¿›å…¥ä¸‹ä¸€ä¸ª elseif å‰ï¼Œç”Ÿæˆè·³è½¬æŒ‡ä»¤è·³è¿‡åç»­åˆ†æ”¯
        luaK_concat(fs, &escapelist, luaK_jump(fs));
        
        // å›å¡«ä¸Šä¸€ä¸ªåˆ†æ”¯çš„å‡è·³è½¬åˆ°å½“å‰ä½ç½®
        luaK_patchtohere(fs, flist);
        
        // å¤„ç† elseif åˆ†æ”¯
        flist = test_then_block(ls);
    }
    
    // ========== ç¬¬ä¸‰é˜¶æ®µï¼šå¤„ç† ELSE åˆ†æ”¯ï¼ˆå¯é€‰ï¼‰==========
    if (testnext(ls, TK_ELSE)) {
        // ç”Ÿæˆè·³è½¬æŒ‡ä»¤è·³è¿‡ else å—
        luaK_concat(fs, &escapelist, luaK_jump(fs));
        
        // å›å¡«å‡è·³è½¬åˆ° else å—å¼€å§‹
        luaK_patchtohere(fs, flist);
        
        // è§£æ else å—
        block(ls);
    }
    else {
        // æ²¡æœ‰ elseï¼šå‡è·³è½¬ç›´æ¥åˆ° if è¯­å¥ç»“æŸ
        luaK_concat(fs, &escapelist, flist);
    }
    
    // ========== ç¬¬å››é˜¶æ®µï¼šå›å¡«æ‰€æœ‰é€ƒé€¸è·³è½¬ ==========
    luaK_patchtohere(fs, escapelist);
    
    // æ£€æŸ¥åŒ¹é…çš„ END
    check_match(ls, TK_END, TK_IF, line);
}
```

#### test_then_block è¾…åŠ©å‡½æ•°

```c
static int test_then_block(LexState *ls) {
    // è§£æ 'exp THEN block'ï¼Œè¿”å›å‡è·³è½¬é“¾è¡¨
    
    int condexit;  // æ¡ä»¶ä¸ºå‡æ—¶çš„è·³è½¬
    
    luaX_next(ls);  // è·³è¿‡ 'if' æˆ– 'elseif'
    
    // è§£ææ¡ä»¶è¡¨è¾¾å¼
    expdesc v;
    expr(ls, &v);
    
    // æ£€æŸ¥ 'then' å…³é”®å­—
    check(ls, TK_THEN);
    
    // ç”Ÿæˆæ¡ä»¶è·³è½¬ï¼šä¸ºå‡æ—¶è·³è½¬
    condexit = luaK_goiffalse(ls->fs, &v);
    
    // è§£æ then å—
    enterblock(ls->fs, &bl, 0);  // é breakable å—
    block(ls);
    leaveblock(ls->fs);
    
    // è¿”å›å‡è·³è½¬é“¾è¡¨å¤´
    return condexit;
}
```

### 2.2 if è¯­å¥æ‰§è¡Œè¿‡ç¨‹å¯è§†åŒ–

#### ç¤ºä¾‹ä»£ç 

```lua
if a > 10 then
    print("large")
elseif a > 5 then
    print("medium")
elseif a > 0 then
    print("small")
else
    print("non-positive")
end
print("done")
```

#### è§£æè¿‡ç¨‹è¯¦ç»†è·Ÿè¸ª

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
å¼€å§‹è§£æ if è¯­å¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
åˆå§‹çŠ¶æ€:
  escapelist = NO_JUMP
  flist = NO_JUMP

ã€é˜¶æ®µ1ã€‘è§£æ IF åˆ†æ”¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
è°ƒç”¨: test_then_block(ls)

æ­¥éª¤1.1: è§£ææ¡ä»¶ 'a > 10'
  ç”Ÿæˆ: LT 0 K(10) R(a)    ; æµ‹è¯• a > 10
  
æ­¥éª¤1.2: ç”Ÿæˆå‡è·³è½¬
  ç”Ÿæˆ: JMP [?]  â† pc=1
  condexit = 1
  
æ­¥éª¤1.3: è§£æ then å—
  ç”Ÿæˆ: GETGLOBAL R(0) K("print")
  ç”Ÿæˆ: LOADK R(1) K("large")
  ç”Ÿæˆ: CALL R(0) 2 1      ; print("large")
  å½“å‰ pc = 5
  
è¿”å›: flist = 1 (å‡è·³è½¬é“¾è¡¨å¤´)

ã€é˜¶æ®µ2ã€‘å¤„ç†ç¬¬ä¸€ä¸ª ELSEIF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤2.1: ç”Ÿæˆé€ƒé€¸è·³è½¬ï¼ˆè·³è¿‡åç»­åˆ†æ”¯ï¼‰
  ç”Ÿæˆ: JMP [?]  â† pc=5
  escapelist = 5
  
æ­¥éª¤2.2: å›å¡«ä¸Šä¸€ä¸ªå‡è·³è½¬
  luaK_patchtohere(fs, flist=1)
  ä¿®æ­£: æŒ‡ä»¤[1] çš„ sBxï¼Œä½¿å…¶è·³è½¬åˆ° pc=6
  
æ­¥éª¤2.3: è°ƒç”¨ test_then_block(ls)
  è§£ææ¡ä»¶ 'a > 5'
  ç”Ÿæˆ: LT 0 K(5) R(a)     ; æµ‹è¯• a > 5  â† pc=6
  ç”Ÿæˆ: JMP [?]  â† pc=7
  è§£æ then å—
  ç”Ÿæˆ: print("medium")
  å½“å‰ pc = 11
  
è¿”å›: flist = 7

ã€é˜¶æ®µ3ã€‘å¤„ç†ç¬¬äºŒä¸ª ELSEIF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤3.1: ç”Ÿæˆé€ƒé€¸è·³è½¬
  ç”Ÿæˆ: JMP [?]  â† pc=11
  è¿æ¥: escapelist = 11 â†’ 5
  
æ­¥éª¤3.2: å›å¡«å‡è·³è½¬
  luaK_patchtohere(fs, flist=7)
  ä¿®æ­£: æŒ‡ä»¤[7] è·³è½¬åˆ° pc=12
  
æ­¥éª¤3.3: å¤„ç† 'a > 0' åˆ†æ”¯
  ç”Ÿæˆ: LT 0 K(0) R(a)     ; æµ‹è¯• a > 0  â† pc=12
  ç”Ÿæˆ: JMP [?]  â† pc=13
  ç”Ÿæˆ: print("small")
  å½“å‰ pc = 17
  
è¿”å›: flist = 13

ã€é˜¶æ®µ4ã€‘å¤„ç† ELSE åˆ†æ”¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤4.1: ç”Ÿæˆé€ƒé€¸è·³è½¬
  ç”Ÿæˆ: JMP [?]  â† pc=17
  è¿æ¥: escapelist = 17 â†’ 11 â†’ 5
  
æ­¥éª¤4.2: å›å¡«å‡è·³è½¬
  luaK_patchtohere(fs, flist=13)
  ä¿®æ­£: æŒ‡ä»¤[13] è·³è½¬åˆ° pc=18
  
æ­¥éª¤4.3: è§£æ else å—
  ç”Ÿæˆ: print("non-positive")  â† pc=18
  å½“å‰ pc = 22

ã€é˜¶æ®µ5ã€‘å›å¡«æ‰€æœ‰é€ƒé€¸è·³è½¬
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
luaK_patchtohere(fs, escapelist)
ç›®æ ‡ä½ç½®: pc=22

éå†é“¾è¡¨:
  æŒ‡ä»¤[17]: JMP â†’ ä¿®æ­£ä¸ºè·³è½¬åˆ° pc=22
  æŒ‡ä»¤[11]: JMP â†’ ä¿®æ­£ä¸ºè·³è½¬åˆ° pc=22
  æŒ‡ä»¤[5]:  JMP â†’ ä¿®æ­£ä¸ºè·³è½¬åˆ° pc=22

ã€ç»“æŸã€‘
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

#### ç”Ÿæˆçš„æœ€ç»ˆå­—èŠ‚ç 

```assembly
; if a > 10 then
0   LT        0 K(10) R(a)
1   JMP       5              ; å‡åˆ™è·³åˆ° elseif
2   GETGLOBAL R(0) K("print")
3   LOADK     R(1) K("large")
4   CALL      R(0) 2 1
5   JMP       22             ; è·³å‡º if è¯­å¥

; elseif a > 5 then
6   LT        0 K(5) R(a)
7   JMP       11             ; å‡åˆ™è·³åˆ°ä¸‹ä¸€ä¸ª elseif
8   GETGLOBAL R(0) K("print")
9   LOADK     R(1) K("medium")
10  CALL      R(0) 2 1
11  JMP       22             ; è·³å‡º if è¯­å¥

; elseif a > 0 then
12  LT        0 K(0) R(a)
13  JMP       18             ; å‡åˆ™è·³åˆ° else
14  GETGLOBAL R(0) K("print")
15  LOADK     R(1) K("small")
16  CALL      R(0) 2 1
17  JMP       22             ; è·³å‡º if è¯­å¥

; else
18  GETGLOBAL R(0) K("print")
19  LOADK     R(1) K("non-positive")
20  CALL      R(0) 2 1

; end
22  ; if è¯­å¥ç»“æŸï¼Œç»§ç»­åç»­ä»£ç 
22  GETGLOBAL R(0) K("print")
23  LOADK     R(1) K("done")
24  CALL      R(0) 2 1
```

#### æ§åˆ¶æµå›¾

```
                å¼€å§‹
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  æµ‹è¯• a > 10  â”‚
         â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
          çœŸâ”‚       â”‚å‡
             â”‚       â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”   â”‚
      â”‚print    â”‚   â”‚
      â”‚"large"  â”‚   â”‚
      â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
         â”‚          â”‚
         â”‚    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
         â”‚    â”‚æµ‹è¯• a > 5 â”‚
         â”‚    â””â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
         â”‚    çœŸâ”‚    â”‚å‡
         â”‚       â”‚    â”‚
         â”‚ â”Œâ”€â”€â”€â”€â”€â–¼â”  â”‚
         â”‚ â”‚print â”‚  â”‚
         â”‚ â”‚"med" â”‚  â”‚
         â”‚ â””â”€â”€â”¬â”€â”€â”€â”˜  â”‚
         â”‚    â”‚      â”‚
         â”‚    â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
         â”‚    â”‚  â”‚æµ‹è¯•a > 0â”‚
         â”‚    â”‚  â””â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”˜
         â”‚    â”‚ çœŸâ”‚   â”‚å‡
         â”‚    â”‚    â”‚   â”‚
         â”‚    â”‚ â”Œâ”€â”€â–¼â” â”‚
         â”‚    â”‚ â”‚prnâ”‚ â”‚
         â”‚    â”‚ â”‚"sm"â”‚ â”‚
         â”‚    â”‚ â””â”€â”¬â”€â”˜ â”‚
         â”‚    â”‚   â”‚   â”‚
         â”‚    â”‚   â”‚  â”Œâ–¼â”€â”€â”€â”€â”€â”
         â”‚    â”‚   â”‚  â”‚print â”‚
         â”‚    â”‚   â”‚  â”‚"non" â”‚
         â”‚    â”‚   â”‚  â””â”¬â”€â”€â”€â”€â”€â”˜
         â””â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                 â”‚
            print("done")
                 â”‚
                ç»“æŸ
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¾ªç¯æ§åˆ¶è¯­å¥

### 3.1 while å¾ªç¯è§£æ

#### è¯­æ³•ç»“æ„

```bnf
whilestat ::= 'while' exp 'do' block 'end'
```

#### æ ¸å¿ƒç‰¹ç‚¹

while å¾ªç¯æ˜¯æœ€åŸºç¡€çš„å¾ªç¯ç»“æ„ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å‰æµ‹è¯•å¾ªç¯**ï¼šå…ˆæµ‹è¯•æ¡ä»¶ï¼Œå†æ‰§è¡Œå¾ªç¯ä½“
2. **å¯ä¸­æ–­æ€§**ï¼šæ”¯æŒ break è¯­å¥è·³å‡ºå¾ªç¯
3. **å›è·³æœºåˆ¶**ï¼šå¾ªç¯ä½“ç»“æŸåè·³å›æ¡ä»¶æµ‹è¯•

#### å®Œæ•´å®ç°ä»£ç 

```c
static void whilestat(LexState *ls, int line) {
    // WHILE exp DO block END
    
    FuncState *fs = ls->fs;
    int whileinit;   // å¾ªç¯å¼€å§‹ä½ç½®ï¼ˆæ¡ä»¶æµ‹è¯•ä½ç½®ï¼‰
    int condexit;    // æ¡ä»¶ä¸ºå‡æ—¶çš„è·³è½¬
    BlockCnt bl;     // å¾ªç¯å—æ§åˆ¶
    
    luaX_next(ls);  // è·³è¿‡ 'while'
    
    // ========== ç¬¬ä¸€æ­¥ï¼šè®°å½•å¾ªç¯å¼€å§‹ä½ç½® ==========
    whileinit = luaK_getlabel(fs);
    
    // ========== ç¬¬äºŒæ­¥ï¼šè§£æå’Œç”Ÿæˆæ¡ä»¶æµ‹è¯• ==========
    expdesc v;
    expr(ls, &v);  // è§£ææ¡ä»¶è¡¨è¾¾å¼
    
    check(ls, TK_DO);  // æ£€æŸ¥ 'do' å…³é”®å­—
    
    // ç”Ÿæˆæ¡ä»¶è·³è½¬ï¼šå‡æ—¶è·³å‡ºå¾ªç¯
    condexit = luaK_goiffalse(fs, &v);
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šè¿›å…¥å¾ªç¯ä½“å— ==========
    enterblock(fs, &bl, 1);  // 1 è¡¨ç¤º breakableï¼ˆå¯ breakï¼‰
    
    // ========== ç¬¬å››æ­¥ï¼šè§£æå¾ªç¯ä½“ ==========
    block(ls);
    
    // ========== ç¬¬äº”æ­¥ï¼šç”Ÿæˆå›è·³æŒ‡ä»¤ ==========
    // è·³å›å¾ªç¯å¼€å§‹ä½ç½®ï¼ˆæ¡ä»¶æµ‹è¯•ï¼‰
    luaK_patchlist(fs, luaK_jump(fs), whileinit);
    
    // ========== ç¬¬å…­æ­¥ï¼šæ£€æŸ¥ç»“æŸæ ‡è®° ==========
    check_match(ls, TK_END, TK_WHILE, line);
    
    // ========== ç¬¬ä¸ƒæ­¥ï¼šç¦»å¼€å—å¹¶å›å¡«è·³è½¬ ==========
    leaveblock(fs);  // ä¼šè‡ªåŠ¨å›å¡«æ‰€æœ‰ break è·³è½¬
    
    // ========== ç¬¬å…«æ­¥ï¼šå›å¡«æ¡ä»¶å‡è·³è½¬ ==========
    luaK_patchtohere(fs, condexit);  // å‡æ—¶è·³åˆ°è¿™é‡Œï¼ˆå¾ªç¯ç»“æŸï¼‰
}
```

#### æ‰§è¡Œè¿‡ç¨‹å¯è§†åŒ–

**ç¤ºä¾‹ä»£ç **ï¼š

```lua
local i = 0
while i < 10 do
    print(i)
    if i == 5 then
        break
    end
    i = i + 1
end
print("done")
```

**è§£æè¿‡ç¨‹**ï¼š

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
è§£æ while å¾ªç¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤1: åˆå§‹åŒ–
  è·³è¿‡ 'while'
  whileinit = pc=1  ; è®°å½•å¾ªç¯å¼€å§‹ä½ç½®

æ­¥éª¤2: è§£ææ¡ä»¶ 'i < 10'
  ç”Ÿæˆ: LT 1 R(i) K(10)    ; pc=1, æµ‹è¯• i < 10
  
æ­¥éª¤3: ç”Ÿæˆæ¡ä»¶è·³è½¬
  ç”Ÿæˆ: JMP [?]             ; pc=2, å‡æ—¶è·³å‡º
  condexit = 2

æ­¥éª¤4: è¿›å…¥å¾ªç¯ä½“å—
  enterblock(fs, &bl, 1)    ; breakable = 1
  bl.breaklist = NO_JUMP

æ­¥éª¤5: è§£æå¾ªç¯ä½“
  5.1: è§£æ print(i)
    ç”Ÿæˆ: GETGLOBAL R(0) K("print")
    ç”Ÿæˆ: MOVE R(1) R(i)
    ç”Ÿæˆ: CALL R(0) 2 1
  
  5.2: è§£æ if i == 5 then break end
    ç”Ÿæˆ: EQ 1 R(i) K(5)    ; æµ‹è¯• i == 5
    ç”Ÿæˆ: JMP [skip_break]   ; ä¸ç­‰äºåˆ™è·³è¿‡break
    ç”Ÿæˆ: JMP [?]            ; pc=8, break è·³è½¬
    æ›´æ–°: bl.breaklist = 8   ; åŠ å…¥ break é“¾è¡¨
  
  5.3: è§£æ i = i + 1
    ç”Ÿæˆ: ADD R(i) R(i) K(1)

æ­¥éª¤6: ç”Ÿæˆå›è·³æŒ‡ä»¤
  ç”Ÿæˆ: JMP -8              ; pc=10, è·³å› pc=1

æ­¥éª¤7: ç¦»å¼€å—
  leaveblock(fs)
  å›å¡«: bl.breaklist (8) â†’ pc=11

æ­¥éª¤8: å›å¡«æ¡ä»¶å‡è·³è½¬
  å›å¡«: condexit (2) â†’ pc=11

æ­¥éª¤9: ç»§ç»­åç»­ä»£ç 
  ç”Ÿæˆ: print("done")
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

#### ç”Ÿæˆçš„å­—èŠ‚ç 

```assembly
0   LOADK     R(0) 0        ; i = 0

; while å¾ªç¯å¼€å§‹
1   LT        1 R(0) K(10)  ; æ¡ä»¶ï¼ši < 10
2   JMP       11            ; å‡åˆ™è·³å‡ºå¾ªç¯

; å¾ªç¯ä½“
3   GETGLOBAL R(1) K("print")
4   MOVE      R(2) R(0)     ; å‚æ•°ï¼ši
5   CALL      R(1) 2 1      ; print(i)

6   EQ        1 R(0) K(5)   ; æµ‹è¯• i == 5
7   JMP       9             ; ä¸ç­‰åˆ™è·³è¿‡ break
8   JMP       11            ; breakï¼šè·³å‡ºå¾ªç¯

9   ADD       R(0) R(0) K(1) ; i = i + 1
10  JMP       1             ; è·³å›æ¡ä»¶æµ‹è¯•

; while å¾ªç¯ç»“æŸ
11  GETGLOBAL R(1) K("print")
12  LOADK     R(2) K("done")
13  CALL      R(1) 2 1
```

#### æ§åˆ¶æµå›¾

```
         å¼€å§‹
          â”‚
     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
     â”‚ i = 0   â”‚
     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
          â”‚
     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚i < 10?  â”‚            â”‚
     â””â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”˜            â”‚
    çœŸâ”‚    â”‚å‡              â”‚
      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
      â”‚             â”‚       â”‚
 â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”        â”‚       â”‚
 â”‚print(i) â”‚        â”‚       â”‚
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚       â”‚
      â”‚             â”‚       â”‚
 â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”        â”‚       â”‚
 â”‚i == 5?  â”‚        â”‚       â”‚
 â””â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”˜        â”‚       â”‚
çœŸ â”‚    â”‚å‡         â”‚       â”‚
   â”‚    â”‚           â”‚       â”‚
break  â”Œâ–¼â”€â”€â”€â”€â”€â”€â”    â”‚       â”‚
   â”‚   â”‚i=i+1  â”‚    â”‚       â”‚
   â”‚   â””â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚       â”‚
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
   â”‚                        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                       print("done")
                            â”‚
                          ç»“æŸ
```

### 3.2 repeat-until å¾ªç¯è§£æ

#### è¯­æ³•ç»“æ„

```bnf
repeatstat ::= 'repeat' block 'until' exp
```

#### æ ¸å¿ƒç‰¹ç‚¹

repeat-until ä¸ while æœ‰é‡è¦åŒºåˆ«ï¼š

1. **åæµ‹è¯•å¾ªç¯**ï¼šå…ˆæ‰§è¡Œå¾ªç¯ä½“ï¼Œå†æµ‹è¯•æ¡ä»¶
2. **ä½œç”¨åŸŸç‰¹æ®Šæ€§**ï¼šæ¡ä»¶è¡¨è¾¾å¼å¯ä»¥è®¿é—®å¾ªç¯ä½“ä¸­å®šä¹‰çš„å±€éƒ¨å˜é‡
3. **æ¡ä»¶åè½¬**ï¼šä¸ºçœŸæ—¶è·³å‡ºï¼ˆä¸ while ç›¸åï¼‰

#### å®Œæ•´å®ç°ä»£ç 

```c
static void repeatstat(LexState *ls, int line) {
    // REPEAT block UNTIL exp
    
    int condexit;
    FuncState *fs = ls->fs;
    int repeat_init = luaK_getlabel(fs);  // å¾ªç¯ä½“å¼€å§‹ä½ç½®
    BlockCnt bl1, bl2;  // ä¸¤å±‚å—ï¼
    
    // ========== ç¬¬ä¸€æ­¥ï¼šè¿›å…¥å¤–å±‚å— ==========
    // å¤–å±‚å—ï¼šç”¨äº break ç®¡ç†
    enterblock(fs, &bl1, 1);  // breakable = 1
    
    // ========== ç¬¬äºŒæ­¥ï¼šè¿›å…¥å†…å±‚å— ==========
    // å†…å±‚å—ï¼šç”¨äºå±€éƒ¨å˜é‡ä½œç”¨åŸŸ
    enterblock(fs, &bl2, 0);  // breakable = 0
    
    luaX_next(ls);  // è·³è¿‡ 'repeat'
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šè§£æå¾ªç¯ä½“ ==========
    chunk(ls);  // æ³¨æ„ï¼šä½¿ç”¨ chunk è€Œä¸æ˜¯ block
    
    // æ£€æŸ¥ 'until' å…³é”®å­—
    check_match(ls, TK_UNTIL, TK_REPEAT, line);
    
    // ========== ç¬¬å››æ­¥ï¼šè§£ææ¡ä»¶è¡¨è¾¾å¼ ==========
    // å…³é”®ï¼šæ¡ä»¶åœ¨å†…å±‚å—çš„ä½œç”¨åŸŸå†…è§£æ
    expdesc v;
    cond(ls, &v);  // è§£ææ¡ä»¶
    
    // ========== ç¬¬äº”æ­¥ï¼šç”Ÿæˆæ¡ä»¶è·³è½¬ ==========
    // å¦‚æœæ¡ä»¶ä¸ºå‡ï¼Œè·³å›å¾ªç¯å¼€å§‹
    // ï¼ˆæ³¨æ„ï¼šrepeat æ˜¯"ä¸ºçœŸæ—¶è·³å‡º"ï¼‰
    if (bl2.upval) {
        // å¦‚æœæœ‰ upvalueï¼Œéœ€è¦å…ˆå…³é—­
        luaK_patchtohere(fs, luaK_jump(fs));
        luaK_codeABC(fs, OP_CLOSE, bl2.nactvar, 0, 0);
        condexit = luaK_goiffalse(fs, &v);  // å‡æ—¶å›è·³
    }
    else {
        condexit = luaK_goiffalse(fs, &v);  // å‡æ—¶å›è·³
    }
    
    // ========== ç¬¬å…­æ­¥ï¼šç¦»å¼€å†…å±‚å— ==========
    leaveblock(fs);  // å†…å±‚å—ç»“æŸï¼Œå±€éƒ¨å˜é‡å¤±æ•ˆ
    
    // ========== ç¬¬ä¸ƒæ­¥ï¼šå›å¡«å‡è·³è½¬ ==========
    luaK_patchlist(fs, condexit, repeat_init);  // å‡æ—¶è·³å›å¼€å§‹
    
    // ========== ç¬¬å…«æ­¥ï¼šç¦»å¼€å¤–å±‚å— ==========
    leaveblock(fs);  // å›å¡«æ‰€æœ‰ break è·³è½¬
}
```

#### åŒå±‚å—ç»“æ„è¯¦è§£

**ä¸ºä»€ä¹ˆéœ€è¦ä¸¤å±‚å—ï¼Ÿ**

```lua
repeat
    local x = 10      -- å®šä¹‰åœ¨å¾ªç¯ä½“å†…
until x > 5           -- ä½†åœ¨æ¡ä»¶ä¸­å¯ä»¥è®¿é—®ï¼
```

**å—ç»“æ„**ï¼š

```
å¤–å±‚å—ï¼ˆbreakableï¼‰
  â”œâ”€ ç®¡ç† break è·³è½¬
  â””â”€ å†…å±‚å—ï¼ˆé breakableï¼‰
      â”œâ”€ ç®¡ç†å±€éƒ¨å˜é‡ä½œç”¨åŸŸ
      â””â”€ å»¶ä¼¸åˆ° until æ¡ä»¶
```

#### æ‰§è¡Œè¿‡ç¨‹å¯è§†åŒ–

**ç¤ºä¾‹ä»£ç **ï¼š

```lua
local i = 0
repeat
    local square = i * i
    print(square)
    i = i + 1
until i > 5 or square > 20
print("done")
```

**è§£æè¿‡ç¨‹**ï¼š

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
è§£æ repeat å¾ªç¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤1: åˆå§‹åŒ–
  repeat_init = pc=1  ; è®°å½•å¾ªç¯ä½“å¼€å§‹ä½ç½®

æ­¥éª¤2: è¿›å…¥å¤–å±‚å—
  enterblock(fs, &bl1, 1)  ; breakable
  bl1.nactvar = 1  ; i å·²ç»å®šä¹‰

æ­¥éª¤3: è¿›å…¥å†…å±‚å—
  enterblock(fs, &bl2, 0)  ; é breakable
  bl2.nactvar = 1

æ­¥éª¤4: è§£æå¾ªç¯ä½“
  4.1: å®šä¹‰å±€éƒ¨å˜é‡ square
    ç”Ÿæˆ: MUL R(1) R(0) R(0)  ; square = i * i
    bl2.nactvar = 2  ; ç°åœ¨æœ‰ i å’Œ square
  
  4.2: è§£æ print(square)
    ç”Ÿæˆ: GETGLOBAL R(2) K("print")
    ç”Ÿæˆ: MOVE R(3) R(1)
    ç”Ÿæˆ: CALL R(2) 2 1
  
  4.3: è§£æ i = i + 1
    ç”Ÿæˆ: ADD R(0) R(0) K(1)  ; i = i + 1

æ­¥éª¤5: è§£ææ¡ä»¶ 'i > 5 or square > 20'
  æ³¨æ„ï¼šsquare ä»åœ¨ä½œç”¨åŸŸå†…ï¼
  
  5.1: è§£æ 'i > 5'
    ç”Ÿæˆ: LT 0 K(5) R(0)      ; æµ‹è¯• i > 5
    ç”Ÿæˆ: JMP [skip_or]        ; çœŸåˆ™è·³è¿‡ or çš„å³è¾¹
  
  5.2: è§£æ 'square > 20'
    ç”Ÿæˆ: LT 0 K(20) R(1)     ; æµ‹è¯• square > 20
  
  5.3: ç”Ÿæˆæ¡ä»¶è·³è½¬
    ç”Ÿæˆ: JMP [?]              ; condexit
    
æ­¥éª¤6: å›å¡«å‡è·³è½¬
  luaK_patchlist(condexit, repeat_init=1)
  å‡æ—¶è·³å›å¾ªç¯å¼€å§‹

æ­¥éª¤7: ç¦»å¼€å†…å±‚å—
  leaveblock(fs)
  ç§»é™¤ squareï¼ˆnactvar ä» 2 é™åˆ° 1ï¼‰

æ­¥éª¤8: ç¦»å¼€å¤–å±‚å—
  leaveblock(fs)
  å›å¡«ä»»ä½• break è·³è½¬ï¼ˆå¦‚æœæœ‰ï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

#### ç”Ÿæˆçš„å­—èŠ‚ç 

```assembly
0   LOADK     R(0) 0         ; i = 0

; repeat å¾ªç¯å¼€å§‹
1   MUL       R(1) R(0) R(0) ; square = i * i
2   GETGLOBAL R(2) K("print")
3   MOVE      R(3) R(1)      ; å‚æ•°ï¼šsquare
4   CALL      R(2) 2 1       ; print(square)
5   ADD       R(0) R(0) K(1) ; i = i + 1

; until æ¡ä»¶æµ‹è¯•
6   LT        0 K(5) R(0)    ; i > 5?
7   JMP       9              ; çœŸåˆ™è·³è¿‡åç»­æµ‹è¯•
8   LT        0 K(20) R(1)   ; square > 20?

; æ¡ä»¶ä¸ºå‡æ—¶å›è·³
9   JMP       1              ; å‡åˆ™è·³å›å¾ªç¯å¼€å§‹

; repeat å¾ªç¯ç»“æŸ
10  GETGLOBAL R(2) K("print")
11  LOADK     R(3) K("done")
12  CALL      R(2) 2 1
```

#### å…³é”®è®¾è®¡å†³ç­–

**é—®é¢˜**ï¼šä¸ºä»€ä¹ˆæ¡ä»¶å¯ä»¥è®¿é—®å¾ªç¯ä½“çš„å±€éƒ¨å˜é‡ï¼Ÿ

**ç­”æ¡ˆ**ï¼šLua çš„è®¾è®¡å“²å­¦

```lua
-- è¿™æ˜¯åˆæ³•çš„ Lua ä»£ç 
repeat
    local answer = read_input()
until answer == "yes"  -- å¯ä»¥è®¿é—® answer
```

**å®ç°æœºåˆ¶**ï¼š
1. å†…å±‚å—åŒ…å«å¾ªç¯ä½“å’Œæ¡ä»¶
2. å±€éƒ¨å˜é‡åœ¨å†…å±‚å—ä½œç”¨åŸŸå†…
3. æ¡ä»¶è§£æå®Œåæ‰ç¦»å¼€å†…å±‚å—

### 3.3 for å¾ªç¯è§£æ

#### ä¸¤ç§ for å¾ªç¯

Lua æœ‰ä¸¤ç§ for å¾ªç¯ï¼š

1. **æ•°å€¼ for**ï¼š`for i = 1, 10, 2 do ... end`
2. **é€šç”¨ for**ï¼š`for k, v in pairs(t) do ... end`

#### 3.3.1 æ•°å€¼ for å¾ªç¯

**è¯­æ³•ç»“æ„**ï¼š

```bnf
fornum ::= 'for' NAME '=' exp ',' exp [',' exp] 'do' block 'end'
```

**å®ç°ä»£ç **ï¼š

```c
static void fornum(LexState *ls, TString *varname, int line) {
    // FOR NAME = init, limit [, step] DO block END
    
    FuncState *fs = ls->fs;
    int base = fs->freereg;  // å¾ªç¯å˜é‡çš„å¯„å­˜å™¨åŸºå€
    
    // ========== ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºå†…éƒ¨å¾ªç¯å˜é‡ ==========
    // Lua ä¸ºæ•°å€¼ for åˆ›å»º 4 ä¸ªå†…éƒ¨å˜é‡ï¼š
    // (for index), (for limit), (for step), var
    
    new_localvarliteral(ls, "(for index)", 0);  // å†…éƒ¨ç´¢å¼•
    new_localvarliteral(ls, "(for limit)", 1);  // å†…éƒ¨é™åˆ¶
    new_localvarliteral(ls, "(for step)", 2);   // å†…éƒ¨æ­¥é•¿
    new_localvar(ls, varname, 3);               // ç”¨æˆ·å˜é‡
    
    // ========== ç¬¬äºŒæ­¥ï¼šè§£æåˆå§‹åŒ–è¡¨è¾¾å¼ ==========
    check(ls, '=');
    exp1(ls);  // è§£æ init
    
    check(ls, ',');
    exp1(ls);  // è§£æ limit
    
    if (testnext(ls, ','))
        exp1(ls);  // è§£æ stepï¼ˆå¯é€‰ï¼‰
    else {
        // é»˜è®¤æ­¥é•¿ä¸º 1
        luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_numberK(fs, 1));
        luaK_reserveregs(fs, 1);
    }
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šç”Ÿæˆ FORPREP æŒ‡ä»¤ ==========
    // FORPREP æ‰§è¡Œåˆå§‹åŒ–å¹¶è·³åˆ°å¾ªç¯ç»“æŸ
    int prep_jump = luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP);
    
    // ========== ç¬¬å››æ­¥ï¼šè¿›å…¥å¾ªç¯ä½“å— ==========
    check(ls, TK_DO);
    
    BlockCnt bl;
    enterblock(fs, &bl, 0);  // æ³¨æ„ï¼šfor å¾ªç¯ä¸ç›´æ¥æ”¯æŒ break
                              // break ç”±å¤–å±‚è¯­å¥å¤„ç†
    
    // æ¿€æ´»æ‰€æœ‰å˜é‡ï¼ˆåŒ…æ‹¬ç”¨æˆ·å˜é‡ï¼‰
    adjustlocalvars(ls, 4);
    
    luaK_reserveregs(fs, 1);  // ä¸ºå¾ªç¯å˜é‡é¢„ç•™ç©ºé—´
    
    // ========== ç¬¬äº”æ­¥ï¼šè§£æå¾ªç¯ä½“ ==========
    block(ls);
    
    // ========== ç¬¬å…­æ­¥ï¼šç”Ÿæˆ FORLOOP æŒ‡ä»¤ ==========
    leaveblock(fs);
    
    // FORLOOP é€’å¢ç´¢å¼•å¹¶åˆ¤æ–­æ˜¯å¦ç»§ç»­å¾ªç¯
    luaK_patchtohere(fs, prep_jump);  // å›å¡« FORPREP çš„è·³è½¬
    int loop_end = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
    luaK_fixline(fs, line);
    
    // å›å¡« FORLOOP çš„è·³è½¬ç›®æ ‡ï¼ˆå›åˆ°å¾ªç¯ä½“å¼€å§‹ï¼‰
    luaK_patchlist(fs, loop_end, prep_jump + 1);
}
```

**æ•°å€¼ for çš„æ‰§è¡Œæµç¨‹**ï¼š

```
åˆå§‹åŒ–: (index)=init-step, (limit)=limit, (step)=step

FORPREP:
  index = index + step
  if (step>0 and index>limit) or (step<0 and index<limit) then
    è·³åˆ°å¾ªç¯ç»“æŸ
  end
  var = index  ; è®¾ç½®ç”¨æˆ·å˜é‡

å¾ªç¯ä½“:
  ... ç”¨æˆ·ä»£ç  ...

FORLOOP:
  index = index + step
  if (step>0 and index<=limit) or (step<0 and index>=limit) then
    var = index
    è·³å›å¾ªç¯ä½“å¼€å§‹
  end

å¾ªç¯ç»“æŸ
```

**ç¤ºä¾‹**ï¼š

```lua
for i = 1, 10, 2 do
    print(i)
end
```

**ç”Ÿæˆçš„å­—èŠ‚ç **ï¼š

```assembly
0   LOADK     R(0) 1         ; (for index) = 1
1   LOADK     R(1) 10        ; (for limit) = 10
2   LOADK     R(2) 2         ; (for step) = 2
3   FORPREP   R(0) 7         ; åˆå§‹åŒ–ï¼Œè·³åˆ°ç»“æŸ
4   GETGLOBAL R(4) K("print")
5   MOVE      R(5) R(3)      ; R(3) = i
6   CALL      R(4) 2 1
7   FORLOOP   R(0) 4         ; é€’å¢å¹¶è·³å›
8   ; å¾ªç¯ç»“æŸ
```

#### 3.3.2 é€šç”¨ for å¾ªç¯

**è¯­æ³•ç»“æ„**ï¼š

```bnf
forlist ::= 'for' namelist 'in' explist 'do' block 'end'
```

**ç‰¹ç‚¹**ï¼š

- ä½¿ç”¨è¿­ä»£å™¨åè®®
- æ”¯æŒå¤šä¸ªå¾ªç¯å˜é‡
- å†…éƒ¨ä½¿ç”¨ 3 ä¸ªçŠ¶æ€å˜é‡

**ç¤ºä¾‹**ï¼š

```lua
for k, v in pairs(t) do
    print(k, v)
end
```

**å†…éƒ¨å˜é‡**ï¼š

```
(for generator)  -- è¿­ä»£å™¨å‡½æ•°
(for state)      -- çŠ¶æ€å˜é‡
(for control)    -- æ§åˆ¶å˜é‡
k, v             -- ç”¨æˆ·å˜é‡
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
åˆå§‹åŒ–:
  generator, state, control = explist

å¾ªç¯:
  var1, var2, ... = generator(state, control)
  control = var1
  if control == nil then break end
  ... å¾ªç¯ä½“ ...
  è·³å›å¾ªç¯å¼€å§‹
```

### 3.4 å¾ªç¯è¯­å¥å¯¹æ¯”æ€»ç»“

#### ä¸‰ç§å¾ªç¯çš„ç‰¹ç‚¹å¯¹æ¯”

| ç‰¹æ€§ | while | repeat-until | for |
|------|-------|--------------|-----|
| **æµ‹è¯•æ—¶æœº** | å‰æµ‹è¯• | åæµ‹è¯• | è‡ªåŠ¨ç®¡ç† |
| **æœ€å°‘æ‰§è¡Œ** | 0 æ¬¡ | 1 æ¬¡ | 0 æ¬¡ |
| **æ¡ä»¶ä½œç”¨åŸŸ** | å¤–éƒ¨ | å¾ªç¯ä½“å†… | è‡ªåŠ¨ |
| **break æ”¯æŒ** | âœ“ | âœ“ | âœ“ |
| **continue** | âœ— | âœ— | âœ— |
| **ä½¿ç”¨åœºæ™¯** | é€šç”¨ | è‡³å°‘æ‰§è¡Œä¸€æ¬¡ | éå†åºåˆ— |

#### æ§åˆ¶æµå¯¹æ¯”

**while**ï¼š
```
    â”Œâ”€â†’ æµ‹è¯•æ¡ä»¶ â”€â”€å‡â†’ ç»“æŸ
    â”‚      â”‚çœŸ
    â”‚      â†“
    â”‚   å¾ªç¯ä½“
    â”‚      â”‚
    â””â”€â”€â”€â”€â”€â”€â”˜
```

**repeat**ï¼š
```
    â”Œâ”€â†’ å¾ªç¯ä½“
    â”‚      â”‚
    â”‚   æµ‹è¯•æ¡ä»¶ â”€â”€çœŸâ†’ ç»“æŸ
    â”‚      â”‚å‡
    â””â”€â”€â”€â”€â”€â”€â”˜
```

**for**ï¼š
```
    åˆå§‹åŒ–
       â”‚
    â”Œâ”€â†’ FORPREP/TFORLOOP
    â”‚      â”‚
    â”‚   å¾ªç¯ä½“
    â”‚      â”‚
    â””â”€â”€ FORLOOP/TFORCALL
       â”‚
    ç»“æŸ
```

#### å­—èŠ‚ç æŒ‡ä»¤å¯¹æ¯”

| å¾ªç¯ç±»å‹ | æ¡ä»¶æµ‹è¯• | å›è·³æ–¹å¼ | ç‰¹æ®ŠæŒ‡ä»¤ |
|---------|---------|---------|---------|
| **while** | æ¡ä»¶è¡¨è¾¾å¼ + TEST | JMP | æ—  |
| **repeat** | æ¡ä»¶è¡¨è¾¾å¼ + TEST | JMP | æ—  |
| **æ•°å€¼ for** | å†…ç½® | å†…ç½® | FORPREP, FORLOOP |
| **é€šç”¨ for** | å†…ç½® | å†…ç½® | TFORLOOP, TFORCALL |

---

## ç¬¬å››éƒ¨åˆ†ï¼šèµ‹å€¼ä¸å‡½æ•°è°ƒç”¨

### 4.1 åŒºåˆ†èµ‹å€¼å’Œå‡½æ•°è°ƒç”¨çš„æŒ‘æˆ˜

#### é—®é¢˜çš„æœ¬è´¨

åœ¨ Lua ä¸­ï¼Œèµ‹å€¼è¯­å¥å’Œå‡½æ•°è°ƒç”¨åœ¨è¯­æ³•ä¸Šæœ‰é‡å ï¼š

```lua
a = 1           -- èµ‹å€¼
a()             -- å‡½æ•°è°ƒç”¨
a.b = 2         -- è¡¨å­—æ®µèµ‹å€¼
a.b()           -- æ–¹æ³•è°ƒç”¨
a[i] = 3        -- ç´¢å¼•èµ‹å€¼
a, b = 1, 2     -- å¤šé‡èµ‹å€¼
f(x)            -- å‡½æ•°è°ƒç”¨
```

**æ ¸å¿ƒé—®é¢˜**ï¼š**å¦‚ä½•é€šè¿‡å‰çœ‹ç¡®å®šæ˜¯èµ‹å€¼è¿˜æ˜¯è°ƒç”¨ï¼Ÿ**

#### LL(1) çš„å›°å¢ƒ

ç®€å•çš„ LL(1) æ— æ³•åŒºåˆ†ï¼š

```
è¯­å¥å¼€å§‹éƒ½æ˜¯ NAME:
  NAME ...
    â†’ èµ‹å€¼ï¼Ÿ
    â†’ å‡½æ•°è°ƒç”¨ï¼Ÿ
    â†’ éœ€è¦çœ‹åç»­ token
```

#### Lua çš„è§£å†³æ–¹æ¡ˆ

ä½¿ç”¨ **exprstat** å‡½æ•°ç»Ÿä¸€å¤„ç†ï¼š

```c
static void exprstat(LexState *ls) {
    // èµ‹å€¼æˆ–å‡½æ•°è°ƒç”¨
    FuncState *fs = ls->fs;
    struct LHS_assign v;
    
    // ç¬¬ä¸€æ­¥ï¼šè§£æä¸»è¡¨è¾¾å¼
    primaryexp(ls, &v.v);
    
    // ç¬¬äºŒæ­¥ï¼šæ ¹æ®åç»­ token åˆ¤æ–­
    if (v.v.k == VCALL) {  // å‡½æ•°è°ƒç”¨
        SETARG_C(getcode(fs, &v.v), 1);  // è°ƒæ•´è°ƒç”¨å‚æ•°
    }
    else {  // èµ‹å€¼
        v.prev = NULL;
        assignment(ls, &v, 1);
    }
}
```

### 4.2 èµ‹å€¼è¯­å¥å®Œæ•´è§£æ

#### è¯­æ³•ç»“æ„

```bnf
assignment ::= varlist '=' explist
varlist    ::= var {',' var}
explist    ::= exp {',' exp}
var        ::= NAME | prefixexp '[' exp ']' | prefixexp '.' NAME
```

#### æ ¸å¿ƒéš¾ç‚¹

1. **å¤šé‡èµ‹å€¼**ï¼š`a, b, c = 1, 2, 3`
2. **å·¦å€¼è¯†åˆ«**ï¼šåŒºåˆ†å˜é‡ã€è¡¨å­—æ®µã€è¡¨ç´¢å¼•
3. **å³å€¼æ•°é‡è°ƒæ•´**ï¼šå¤„ç†å³å€¼å¤šäºæˆ–å°‘äºå·¦å€¼çš„æƒ…å†µ
4. **ä»å³åˆ°å·¦èµ‹å€¼**ï¼šé¿å…è¦†ç›–é—®é¢˜

#### LHS_assign ç»“æ„

ç”¨äºæ„å»ºå·¦å€¼é“¾è¡¨ï¼š

```c
struct LHS_assign {
    struct LHS_assign *prev;  // å‰ä¸€ä¸ªå·¦å€¼ï¼ˆé“¾è¡¨ï¼‰
    expdesc v;                // å½“å‰å·¦å€¼çš„è¡¨è¾¾å¼æè¿°ç¬¦
};
```

#### å®Œæ•´å®ç°ä»£ç 

```c
static void assignment(LexState *ls, struct LHS_assign *lh, int nvars) {
    // é€’å½’è§£æèµ‹å€¼é“¾
    
    expdesc e;
    
    // ========== ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šå·¦å€¼ ==========
    check_condition(ls, VLOCAL <= lh->v.k && lh->v.k <= VINDEXED,
                    "syntax error");
    
    if (testnext(ls, ',')) {  // æœ‰æ›´å¤šå·¦å€¼
        // é€’å½’æ„å»ºå·¦å€¼é“¾è¡¨
        struct LHS_assign nv;
        nv.prev = lh;
        
        // è§£æä¸‹ä¸€ä¸ªå·¦å€¼
        primaryexp(ls, &nv.v);
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å·¦å€¼
        if (nv.v.k == VLOCAL)
            check_conflict(ls, lh, &nv.v);  // æ£€æŸ¥å†²çª
        
        // æ›´æ–°å˜é‡è®¡æ•°
        luaY_checklimit(fs, nvars, LUAI_MAXCCALLS/2,
                       "variables in assignment");
        
        // é€’å½’å¤„ç†
        assignment(ls, &nv, nvars+1);
    }
    else {  // æ²¡æœ‰æ›´å¤šå·¦å€¼
        // ========== ç¬¬äºŒæ­¥ï¼šè§£æå³å€¼è¡¨è¾¾å¼åˆ—è¡¨ ==========
        int nexps;
        
        check(ls, '=');  // æ£€æŸ¥ '=' ç¬¦å·
        
        nexps = explist1(ls, &e);  // è§£æå³å€¼åˆ—è¡¨
        
        // ========== ç¬¬ä¸‰æ­¥ï¼šè°ƒæ•´å³å€¼æ•°é‡ ==========
        if (nexps != nvars) {
            adjust_assign(ls, nvars, nexps, &e);
            if (nexps > nvars)
                ls->fs->freereg -= nexps - nvars;  // ä¸¢å¼ƒå¤šä½™çš„å€¼
        }
        else {
            // æ•°é‡åŒ¹é…ï¼šå°†æœ€åä¸€ä¸ªè¡¨è¾¾å¼ç§»åˆ°å³å€¼ä½ç½®
            luaK_setoneret(ls->fs, &e);
            luaK_storevar(ls->fs, &lh->v, &e);
            return;  // é¿å…é»˜è®¤å¤„ç†
        }
    }
    
    // ========== ç¬¬å››æ­¥ï¼šåˆå§‹åŒ–æœ€åä¸€ä¸ªå·¦å€¼ ==========
    init_exp(&e, VNONRELOC, ls->fs->freereg-1);
    
    // ========== ç¬¬äº”æ­¥ï¼šå­˜å‚¨åˆ°å½“å‰å·¦å€¼ ==========
    luaK_storevar(ls->fs, &lh->v, &e);
}
```

#### æ‰§è¡Œè¿‡ç¨‹å¯è§†åŒ–

**ç¤ºä¾‹ä»£ç **ï¼š

```lua
a, b, c = 1, 2, 3
```

**è§£æè¿‡ç¨‹**ï¼š

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
è§£æå¤šé‡èµ‹å€¼: a, b, c = 1, 2, 3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ­¥éª¤1: è§£æç¬¬ä¸€ä¸ªå·¦å€¼ 'a'
  primaryexp(ls, &lh.v)
  lh.v = {k=VLOCAL, info=0}  ; a åœ¨å¯„å­˜å™¨ 0
  lh.prev = NULL

æ­¥éª¤2: é‡åˆ° ','ï¼Œæœ‰æ›´å¤šå·¦å€¼
  åˆ›å»ºæ–°èŠ‚ç‚¹: nv
  nv.prev = lh
  
æ­¥éª¤3: è§£æç¬¬äºŒä¸ªå·¦å€¼ 'b'
  primaryexp(ls, &nv.v)
  nv.v = {k=VLOCAL, info=1}  ; b åœ¨å¯„å­˜å™¨ 1
  
æ­¥éª¤4: é‡åˆ° ','ï¼Œç»§ç»­é€’å½’
  åˆ›å»ºæ–°èŠ‚ç‚¹: nv2
  nv2.prev = nv
  
æ­¥éª¤5: è§£æç¬¬ä¸‰ä¸ªå·¦å€¼ 'c'
  primaryexp(ls, &nv2.v)
  nv2.v = {k=VLOCAL, info=2}  ; c åœ¨å¯„å­˜å™¨ 2

æ­¥éª¤6: é‡åˆ° '='ï¼Œè§£æå³å€¼
  explist1(ls, &e)
  
  6.1: è§£æ '1'
    e = {k=VKNUM, nval=1}
    nexps = 1
  
  6.2: é‡åˆ° ','ï¼Œç»§ç»­
    è§£æ '2'
    ç”Ÿæˆ: LOADK R(3) K(2)
    nexps = 2
  
  6.3: é‡åˆ° ','ï¼Œç»§ç»­
    è§£æ '3'
    ç”Ÿæˆ: LOADK R(4) K(3)
    nexps = 3

æ­¥éª¤7: è°ƒæ•´æ•°é‡
  nvars = 3, nexps = 3
  æ•°é‡åŒ¹é…ï¼Œæ— éœ€è°ƒæ•´

æ­¥éª¤8: ä»å³åˆ°å·¦èµ‹å€¼
  8.1: å­˜å‚¨åˆ° c (å¯„å­˜å™¨ 2)
    ç”Ÿæˆ: MOVE R(2) R(4)  ; c = 3
  
  8.2: å­˜å‚¨åˆ° b (å¯„å­˜å™¨ 1)
    ç”Ÿæˆ: MOVE R(1) R(3)  ; b = 2
  
  8.3: å­˜å‚¨åˆ° a (å¯„å­˜å™¨ 0)
    ç”Ÿæˆ: LOADK R(0) K(1)  ; a = 1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

#### æ•°é‡ä¸åŒ¹é…çš„å¤„ç†

**æƒ…å†µ1ï¼šå³å€¼å¤šäºå·¦å€¼**

```lua
a, b = 1, 2, 3  -- 3 è¢«ä¸¢å¼ƒ
```

**å¤„ç†**ï¼š
```c
if (nexps > nvars)
    ls->fs->freereg -= nexps - nvars;  // é‡Šæ”¾å¤šä½™çš„å¯„å­˜å™¨
```

**æƒ…å†µ2ï¼šå³å€¼å°‘äºå·¦å€¼**

```lua
a, b, c = 1, 2  -- c è¢«èµ‹å€¼ä¸º nil
```

**å¤„ç†**ï¼š
```c
// adjust_assign ç”Ÿæˆ LOADNIL æŒ‡ä»¤å¡«å……ç¼ºå¤±çš„å€¼
adjust_assign(ls, nvars, nexps, &e);
```

**æƒ…å†µ3ï¼šå‡½æ•°è¿”å›å¤šå€¼**

```lua
a, b, c = f()  -- f è¿”å›å¤šä¸ªå€¼
```

**å¤„ç†**ï¼š
```c
// æœ€åä¸€ä¸ªè¡¨è¾¾å¼å¦‚æœæ˜¯å‡½æ•°è°ƒç”¨ï¼Œè®¾ç½®ä¸ºè¿”å› nvars ä¸ªå€¼
if (hasmultret(e.k)) {
    luaK_setreturns(fs, &e, nvars - nexps + 1);
}
```

### 4.3 è¡¨å­—æ®µèµ‹å€¼

#### ç‰¹æ®Šæƒ…å†µ

```lua
t[key] = value      -- ç´¢å¼•èµ‹å€¼
t.field = value     -- å­—æ®µèµ‹å€¼ï¼ˆè¯­æ³•ç³–ï¼‰
t[f()] = g()        -- å¤æ‚è¡¨è¾¾å¼
```

#### ç”Ÿæˆçš„å­—èŠ‚ç 

```lua
t[1] = 42
```

```assembly
SETTABLE R(t) K(1) K(42)  ; t[1] = 42
```

```lua
t.x = 10
```

```assembly
SETTABLE R(t) K("x") K(10)  ; t["x"] = 10
```

### 4.4 å‡½æ•°è°ƒç”¨å¤„ç†

#### è°ƒç”¨å½¢å¼

Lua æ”¯æŒå¤šç§å‡½æ•°è°ƒç”¨è¯­æ³•ï¼š

```lua
f()              -- æ ‡å‡†å½¢å¼
f(a, b)          -- å¸¦å‚æ•°
f "string"       -- å­—ç¬¦ä¸²å‚æ•°ï¼ˆè¯­æ³•ç³–ï¼‰
f {x=1}          -- è¡¨å‚æ•°ï¼ˆè¯­æ³•ç³–ï¼‰
obj:method(a)    -- æ–¹æ³•è°ƒç”¨ï¼ˆè¯­æ³•ç³–ï¼‰
```

#### å®ç°ä»£ç 

```c
static void funcargs(LexState *ls, expdesc *f) {
    FuncState *fs = ls->fs;
    expdesc args;
    int base, nparams;
    int line = ls->linenumber;
    
    switch (ls->t.token) {
        case '(': {  // f(...)
            // æ£€æŸ¥æ¢è¡Œæ­§ä¹‰
            if (line != ls->lastline)
                luaX_syntaxerror(ls,
                    "ambiguous syntax (function call x new statement)");
            
            luaX_next(ls);
            
            if (ls->t.token == ')')  // æ— å‚æ•°
                args.k = VVOID;
            else {
                explist1(ls, &args);
                luaK_setmultret(fs, &args);
            }
            
            check_match(ls, ')', '(', line);
            break;
        }
        
        case '{': {  // f{...}
            constructor(ls, &args);
            break;
        }
        
        case TK_STRING: {  // f"..."
            codestring(ls, &args, ls->t.seminfo.ts);
            luaX_next(ls);
            break;
        }
        
        default: {
            luaX_syntaxerror(ls, "function arguments expected");
            return;
        }
    }
    
    // ç¡®ä¿å‡½æ•°åœ¨å¯„å­˜å™¨ä¸­
    lua_assert(f->k == VNONRELOC);
    base = f->u.s.info;  // å‡½æ•°æ‰€åœ¨å¯„å­˜å™¨
    
    // è®¡ç®—å‚æ•°æ•°é‡
    if (hasmultret(args.k))
        nparams = LUA_MULTRET;
    else {
        if (args.k != VVOID)
            luaK_exp2nextreg(fs, &args);
        nparams = fs->freereg - (base+1);
    }
    
    // ç”Ÿæˆ CALL æŒ‡ä»¤
    init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
    
    luaK_fixline(fs, line);
    fs->freereg = base+1;  // é‡Šæ”¾å‚æ•°å¯„å­˜å™¨
}
```

#### å¤šè¿”å›å€¼å¤„ç†

**é—®é¢˜åœºæ™¯**ï¼š

```lua
a, b = f(), g()     -- f è¿”å›å¤šå€¼
x = f()             -- åªè¦ç¬¬ä¸€ä¸ªè¿”å›å€¼
print(f())          -- ä½¿ç”¨æ‰€æœ‰è¿”å›å€¼
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

```c
// CALL æŒ‡ä»¤çš„ C å‚æ•°ï¼š
// C = 1: ä¸éœ€è¦è¿”å›å€¼
// C = 2: éœ€è¦ 1 ä¸ªè¿”å›å€¼
// C = n+1: éœ€è¦ n ä¸ªè¿”å›å€¼
// C = 0: éœ€è¦æ‰€æœ‰è¿”å›å€¼ï¼ˆLUA_MULTRETï¼‰

// ç¤ºä¾‹ï¼š
CALL R(0) 1 2    ; R(0) = f()ï¼Œ1ä¸ªè¿”å›å€¼
CALL R(0) 1 0    ; R(0..top) = f()ï¼Œæ‰€æœ‰è¿”å›å€¼
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šä½œç”¨åŸŸç®¡ç†

### 5.1 å±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ

#### å˜é‡çŠ¶æ€

å±€éƒ¨å˜é‡ç»å†ä¸‰ä¸ªçŠ¶æ€ï¼š

1. **å£°æ˜**ï¼š`local x`
2. **æ¿€æ´»**ï¼šèµ‹åˆå€¼åå¯ç”¨
3. **å¤±æ•ˆ**ï¼šç¦»å¼€ä½œç”¨åŸŸ

#### å®ç°æœºåˆ¶

```c
// æ³¨å†Œå±€éƒ¨å˜é‡ï¼ˆå£°æ˜ä½†æœªæ¿€æ´»ï¼‰
static int registerlocalvar(LexState *ls, TString *varname) {
    FuncState *fs = ls->fs;
    Proto *f = fs->f;
    int oldsize = f->sizelocvars;
    
    // æ‰©å±•å±€éƒ¨å˜é‡æ•°ç»„
    luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
                    LocVar, SHRT_MAX, "too many local variables");
    
    // è®°å½•å˜é‡ä¿¡æ¯
    while (oldsize < f->sizelocvars)
        f->locvars[oldsize++].varname = NULL;
    
    f->locvars[fs->nlocvars].varname = varname;
    
    luaC_objbarrier(ls->L, f, varname);
    
    return fs->nlocvars++;
}

// åˆ›å»ºæ–°çš„å±€éƒ¨å˜é‡
static void new_localvar(LexState *ls, TString *name, int n) {
    FuncState *fs = ls->fs;
    
    luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
    
    fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
}

// æ¿€æ´»å±€éƒ¨å˜é‡
static void adjustlocalvars(LexState *ls, int nvars) {
    FuncState *fs = ls->fs;
    
    fs->nactvar = cast_byte(fs->nactvar + nvars);
    
    // è®°å½•å˜é‡çš„èµ·å§‹ pc
    for (; nvars; nvars--) {
        getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
    }
}

// ç§»é™¤å±€éƒ¨å˜é‡
static void removevars(LexState *ls, int tolevel) {
    FuncState *fs = ls->fs;
    
    // è®°å½•å˜é‡çš„ç»“æŸ pc
    while (fs->nactvar > tolevel)
        getlocvar(fs, --fs->nactvar).endpc = fs->pc;
}
```

### 5.2 å±€éƒ¨å˜é‡å£°æ˜

#### è¯­æ³•è§„åˆ™

```bnf
localstat ::= 'local' namelist ['=' explist]
```

#### å®ç°ä»£ç 

```c
static void localstat(LexState *ls) {
    // LOCAL namelist ['=' explist]
    
    int nvars = 0;
    int nexps;
    expdesc e;
    
    // ========== ç¬¬ä¸€æ­¥ï¼šè§£æå˜é‡ååˆ—è¡¨ ==========
    do {
        new_localvar(ls, str_checkname(ls), nvars++);
    } while (testnext(ls, ','));
    
    // ========== ç¬¬äºŒæ­¥ï¼šè§£æåˆå§‹åŒ–è¡¨è¾¾å¼ ==========
    if (testnext(ls, '='))
        nexps = explist1(ls, &e);
    else {
        e.k = VVOID;
        nexps = 0;
    }
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šè°ƒæ•´æ•°é‡å¹¶èµ‹å€¼ ==========
    adjust_assign(ls, nvars, nexps, &e);
    
    // ========== ç¬¬å››æ­¥ï¼šæ¿€æ´»å˜é‡ ==========
    adjustlocalvars(ls, nvars);
}
```

#### ç¤ºä¾‹

```lua
local a, b, c = 1, 2
```

**è¿‡ç¨‹**ï¼š
1. æ³¨å†Œ a, b, cï¼ˆæœªæ¿€æ´»ï¼‰
2. è§£æå³å€¼ `1, 2`
3. è°ƒæ•´ï¼šc èµ‹å€¼ä¸º nil
4. æ¿€æ´»æ‰€æœ‰å˜é‡

### 5.3 upvalue æœºåˆ¶

#### ä»€ä¹ˆæ˜¯ upvalueï¼Ÿ

upvalue æ˜¯**è¢«å†…å±‚å‡½æ•°æ•è·çš„å¤–å±‚å±€éƒ¨å˜é‡**ï¼š

```lua
function outer()
    local x = 1
    
    local function inner()
        print(x)  -- x æ˜¯ inner çš„ upvalue
    end
    
    return inner
end
```

#### upvalue çš„çŠ¶æ€

1. **Open upvalue**ï¼šå¤–å±‚å˜é‡ä»åœ¨æ ˆä¸Š
2. **Closed upvalue**ï¼šå¤–å±‚å˜é‡å·²ç§»åˆ°å †ä¸Š

#### æŸ¥æ‰¾ upvalue

```c
static int searchupvalue(FuncState *fs, TString *name) {
    int i;
    upvaldesc *up = fs->f->upvalues;
    
    // åœ¨å½“å‰å‡½æ•°çš„ upvalue åˆ—è¡¨ä¸­æŸ¥æ‰¾
    for (i = 0; i < fs->nups; i++) {
        if (up[i].name == name)
            return i;
    }
    
    return -1;  // æœªæ‰¾åˆ°
}
```

#### åˆ›å»º upvalue

```c
static int newupvalue(FuncState *fs, TString *name, expdesc *v) {
    Proto *f = fs->f;
    int oldsize = f->sizeupvalues;
    
    luaY_checklimit(fs, fs->nups + 1, LUAI_MAXUPVALUES, "upvalues");
    
    // æ‰©å±• upvalue æ•°ç»„
    luaM_growvector(fs->L, f->upvalues, fs->nups, f->sizeupvalues,
                    upvaldesc, LUAI_MAXUPVALUES, "");
    
    while (oldsize < f->sizeupvalues)
        f->upvalues[oldsize++].name = NULL;
    
    // è®¾ç½® upvalue ä¿¡æ¯
    f->upvalues[fs->nups].instack = (v->k == VLOCAL);
    f->upvalues[fs->nups].idx = cast_byte(v->u.s.info);
    f->upvalues[fs->nups].name = name;
    
    luaC_objbarrier(fs->L, f, name);
    
    return fs->nups++;
}
```

### 5.4 ä½œç”¨åŸŸåµŒå¥—

#### å—ä½œç”¨åŸŸ

```lua
do
    local x = 1
    do
        local x = 2  -- é®è”½å¤–å±‚çš„ x
        print(x)     -- è¾“å‡º 2
    end
    print(x)         -- è¾“å‡º 1
end
```

#### å˜é‡æŸ¥æ‰¾é¡ºåº

1. å½“å‰å—çš„å±€éƒ¨å˜é‡
2. å¤–å±‚å—çš„å±€éƒ¨å˜é‡ï¼ˆæˆä¸º upvalueï¼‰
3. å…¨å±€å˜é‡

```c
static void singlevar(LexState *ls, expdesc *var) {
    TString *varname = str_checkname(ls);
    FuncState *fs = ls->fs;
    
    if (singlevaraux(fs, varname, var, 1) == VGLOBAL)
        var->u.s.info = luaK_stringK(fs, varname);
}

static int singlevaraux(FuncState *fs, TString *n, expdesc *var, int base) {
    if (fs == NULL) {  // åˆ°è¾¾æœ€å¤–å±‚
        init_exp(var, VGLOBAL, 0);
        return VGLOBAL;
    }
    else {
        int v = searchvar(fs, n);  // åœ¨å½“å‰å‡½æ•°æŸ¥æ‰¾
        if (v >= 0) {
            init_exp(var, VLOCAL, v);
            if (!base)
                markupval(fs, v);  // æ ‡è®°ä¸º upvalue
            return VLOCAL;
        }
        else {  // åœ¨å¤–å±‚å‡½æ•°æŸ¥æ‰¾
            if (singlevaraux(fs->prev, n, var, 0) == VGLOBAL)
                return VGLOBAL;
            
            var->u.s.info = indexupvalue(fs, n, var);
            var->k = VUPVAL;
            return VUPVAL;
        }
    }
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šè·³è½¬è¯­å¥å¤„ç†

### 6.1 break è¯­å¥

#### è¯­æ³•è§„åˆ™

```bnf
breakstat ::= 'break'
```

#### å®ç°ä»£ç 

```c
static void breakstat(LexState *ls) {
    FuncState *fs = ls->fs;
    BlockCnt *bl = fs->bl;
    int upval = 0;
    
    // ========== ç¬¬ä¸€æ­¥ï¼šæŸ¥æ‰¾å¯ break çš„å— ==========
    while (bl && !bl->isbreakable) {
        upval |= bl->upval;  // è®°å½•æ˜¯å¦æœ‰ upvalue
        bl = bl->previous;
    }
    
    // ========== ç¬¬äºŒæ­¥ï¼šæ£€æŸ¥åˆæ³•æ€§ ==========
    if (!bl)
        luaX_syntaxerror(ls, "no loop to break");
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šå…³é—­ upvalueï¼ˆå¦‚æœéœ€è¦ï¼‰==========
    if (upval)
        luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
    
    // ========== ç¬¬å››æ­¥ï¼šç”Ÿæˆè·³è½¬å¹¶åŠ å…¥é“¾è¡¨ ==========
    luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
}
```

#### å…³é”®ç‚¹

**1. æŸ¥æ‰¾ç›®æ ‡å—**

break å¿…é¡»åœ¨å¾ªç¯å†…ï¼š

```lua
if x then
    break  -- é”™è¯¯ï¼šä¸åœ¨å¾ªç¯å†…
end

while true do
    if x then
        break  -- æ­£ç¡®
    end
end
```

**2. upvalue å¤„ç†**

å¦‚æœ break è·¨è¶Šäº†æœ‰ upvalue çš„å—ï¼Œéœ€è¦å…³é—­ï¼š

```lua
while true do
    local x = 1
    local function f()
        return x  -- x æ˜¯ upvalue
    end
    if condition then
        break  -- éœ€è¦å…³é—­ x
    end
end
```

### 6.2 return è¯­å¥

#### è¯­æ³•è§„åˆ™

```bnf
retstat ::= 'return' [explist] [';']
```

#### å®ç°ä»£ç 

```c
static void retstat(LexState *ls) {
    FuncState *fs = ls->fs;
    expdesc e;
    int first, nret;  // ç¬¬ä¸€ä¸ªè¿”å›å€¼çš„å¯„å­˜å™¨ï¼Œè¿”å›å€¼æ•°é‡
    
    luaX_next(ls);  // è·³è¿‡ 'return'
    
    // ========== ç¬¬ä¸€æ­¥ï¼šè§£æè¿”å›å€¼è¡¨è¾¾å¼ ==========
    if (block_follow(ls->t.token) || ls->t.token == ';')
        first = nret = 0;  // æ— è¿”å›å€¼
    else {
        nret = explist1(ls, &e);  // è§£æè¡¨è¾¾å¼åˆ—è¡¨
        
        if (hasmultret(e.k)) {
            // æœ€åä¸€ä¸ªè¡¨è¾¾å¼è¿”å›å¤šå€¼
            luaK_setmultret(fs, &e);
            
            if (e.k == VCALL && nret == 1) {
                // å°¾è°ƒç”¨ä¼˜åŒ–
                SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
                lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
            }
            
            first = fs->nactvar;
            nret = LUA_MULTRET;
        }
        else {
            if (nret == 1)
                first = luaK_exp2anyreg(fs, &e);
            else {
                luaK_exp2nextreg(fs, &e);
                first = fs->nactvar;
                lua_assert(nret == fs->freereg - first);
            }
        }
    }
    
    // ========== ç¬¬äºŒæ­¥ï¼šç”Ÿæˆ RETURN æŒ‡ä»¤ ==========
    luaK_ret(fs, first, nret);
}
```

#### å°¾è°ƒç”¨ä¼˜åŒ–

**æ¡ä»¶**ï¼š
- return è¯­å¥çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å‡½æ•°è°ƒç”¨
- æ²¡æœ‰å…¶ä»–è¿”å›å€¼
- å‡½æ•°è°ƒç”¨çš„ç»“æœç›´æ¥è¿”å›

**ç¤ºä¾‹**ï¼š

```lua
function f(n)
    if n == 0 then
        return 1
    else
        return f(n-1)  -- å°¾è°ƒç”¨
    end
end
```

**å­—èŠ‚ç **ï¼š

```assembly
; return f(n-1)
TAILCALL R(0) 2 0   ; è€Œä¸æ˜¯ CALL + RETURN
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šé”™è¯¯æ¢å¤æœºåˆ¶

### 7.1 é”™è¯¯æ£€æµ‹

Lua è§£æå™¨é‡‡ç”¨**å¿«é€Ÿå¤±è´¥**ç­–ç•¥ï¼š

```c
static void check(LexState *ls, int c) {
    if (ls->t.token != c)
        error_expected(ls, c);
    luaX_next(ls);
}

static void check_match(LexState *ls, int what, int who, int where) {
    if (!testnext(ls, what)) {
        if (where == ls->linenumber)
            error_expected(ls, what);
        else {
            luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
                "%s expected (to close %s at line %d)",
                luaX_token2str(ls, what),
                luaX_token2str(ls, who),
                where));
        }
    }
}
```

### 7.2 é”™è¯¯ä¿¡æ¯

#### ç±»å‹

1. **æœŸæœ› token é”™è¯¯**
2. **é…å¯¹é”™è¯¯**
3. **è¯­ä¹‰é”™è¯¯**

#### ç¤ºä¾‹

```lua
if x then
    print("hello")
esle  -- æ‹¼å†™é”™è¯¯
    print("world")
end
```

**è¾“å‡º**ï¼š

```
lua: test.lua:3: 'end' expected (to close 'if' at line 1) near 'esle'
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šå®è·µä¸è°ƒè¯•

### 8.1 è°ƒè¯•æŠ€å·§

#### æ·»åŠ è·Ÿè¸ªæ—¥å¿—

```c
#define DEBUG_STATEMENT 1

#if DEBUG_STATEMENT
#define TRACE_STMT(msg) \
    fprintf(stderr, "[%d] %s\n", ls->linenumber, msg)
#else
#define TRACE_STMT(msg)
#endif

static void ifstat(LexState *ls, int line) {
    TRACE_STMT("Enter ifstat");
    // ...
    TRACE_STMT("Leave ifstat");
}
```

#### ä½¿ç”¨ GDB

```bash
# è®¾ç½®æ–­ç‚¹
(gdb) break ifstat
(gdb) break whilestat

# è¿è¡Œ
(gdb) run test.lua

# æŸ¥çœ‹è·³è½¬é“¾è¡¨
(gdb) print fs->bl->breaklist
(gdb) print escapelist

# æŸ¥çœ‹å­—èŠ‚ç 
(gdb) call luaU_print(fs->f, 1)
```

### 8.2 å¸¸è§é—®é¢˜

**é—®é¢˜1ï¼šbreak åœ¨é”™è¯¯ä½ç½®**

```lua
for i = 1, 10 do
    if x then
        do
            break  -- åº”è¯¥è·³å‡º forï¼Œä¸æ˜¯ do
        end
    end
end
```

**è§£å†³**ï¼šç¡®ä¿ break æ‰¾åˆ°æ­£ç¡®çš„ breakable å—ã€‚

**é—®é¢˜2ï¼šå˜é‡ä½œç”¨åŸŸé”™è¯¯**

```lua
repeat
    local x = 1
until x > 0  -- x åº”è¯¥å¯è§
```

**è§£å†³**ï¼šä½¿ç”¨åŒå±‚å—ç»“æ„ã€‚

---

## é™„å½•

### A. è¯­å¥ç±»å‹é€ŸæŸ¥è¡¨

| è¯­å¥ | å…³é”®å­— | å—ç±»å‹ | Breakable | ç‰¹æ®Šæ€§ |
|------|--------|--------|-----------|--------|
| if | if/elseif/else | æ™®é€š | âœ— | å¤šåˆ†æ”¯ |
| while | while/do | å¾ªç¯ | âœ“ | å‰æµ‹è¯• |
| repeat | repeat/until | å¾ªç¯ | âœ“ | åæµ‹è¯•ï¼ŒåŒå±‚å— |
| for(æ•°å€¼) | for/do | å¾ªç¯ | âœ“ | å†…éƒ¨å˜é‡ |
| for(é€šç”¨) | for/in/do | å¾ªç¯ | âœ“ | è¿­ä»£å™¨ |
| do | do/end | æ™®é€š | âœ— | æ˜¾å¼ä½œç”¨åŸŸ |

### B. å­—èŠ‚ç æŒ‡ä»¤å‚è€ƒ

| æŒ‡ä»¤ | å‚æ•° | è¯´æ˜ |
|------|------|------|
| JMP | sBx | æ— æ¡ä»¶è·³è½¬ |
| TEST | A, C | æµ‹è¯• R(A)ï¼ŒC=1 ä¸ºçœŸè·³è½¬ |
| FORPREP | A, sBx | æ•°å€¼ for åˆå§‹åŒ– |
| FORLOOP | A, sBx | æ•°å€¼ for å¾ªç¯ |
| TFORLOOP | A, C | é€šç”¨ for å¾ªç¯ |
| CALL | A, B, C | å‡½æ•°è°ƒç”¨ |
| TAILCALL | A, B, C | å°¾è°ƒç”¨ |
| RETURN | A, B | è¿”å› |
| CLOSE | A | å…³é—­ upvalue |

### C. å‚è€ƒèµ„æº

- [Lua 5.1 å‚è€ƒæ‰‹å†Œ](https://www.lua.org/manual/5.1/)
- [Lua æºç ](https://www.lua.org/source/5.1/)
- [The Implementation of Lua 5.0](https://www.lua.org/doc/jucs05.pdf)

### D. æœ¯è¯­è¡¨

| æœ¯è¯­ | è‹±æ–‡ | è¯´æ˜ |
|------|------|------|
| å— | Block | ä½œç”¨åŸŸå•ä½ |
| è·³è½¬é“¾è¡¨ | Jump List | å¾…å›å¡«çš„è·³è½¬ |
| å›å¡« | Backpatching | ä¿®æ­£è·³è½¬ç›®æ ‡ |
| upvalue | - | è¢«æ•è·çš„å¤–å±‚å˜é‡ |
| å°¾è°ƒç”¨ | Tail Call | ä¼˜åŒ–çš„é€’å½’è°ƒç”¨ |

---

## æ€»ç»“

æœ¬æ–‡æ¡£æ·±å…¥å‰–æäº† Lua 5.1.5 çš„è¯­å¥è§£æç³»ç»Ÿï¼Œæ¶µç›–äº†ï¼š

âœ… **æ¶æ„è®¾è®¡**ï¼šè¯­å¥åˆ†å‘ã€å—ç®¡ç†ã€è·³è½¬é“¾è¡¨  
âœ… **æ§åˆ¶æµ**ï¼šifã€whileã€repeatã€for çš„å®Œæ•´å®ç°  
âœ… **èµ‹å€¼ç³»ç»Ÿ**ï¼šå¤šé‡èµ‹å€¼ã€å·¦å€¼è¯†åˆ«ã€æ•°é‡è°ƒæ•´  
âœ… **ä½œç”¨åŸŸ**ï¼šå±€éƒ¨å˜é‡ã€upvalueã€åµŒå¥—ä½œç”¨åŸŸ  
âœ… **è·³è½¬è¯­å¥**ï¼šbreakã€returnã€å°¾è°ƒç”¨ä¼˜åŒ–  
âœ… **å®è·µæŠ€å·§**ï¼šè°ƒè¯•æ–¹æ³•ã€å¸¸è§é—®é¢˜  

é€šè¿‡æœ¬æ–‡æ¡£ï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿï¼š

1. ç†è§£ Lua è¯­å¥è§£æçš„æ•´ä½“æ¶æ„
2. æŒæ¡å„ç±»è¯­å¥çš„è§£ææµç¨‹å’Œä»£ç ç”Ÿæˆ
3. ç†è§£è·³è½¬é“¾è¡¨å’Œå›å¡«æœºåˆ¶
4. è°ƒè¯•å’Œæ‰©å±• Lua è§£æå™¨

**ä¸‹ä¸€æ­¥å­¦ä¹ **ï¼š

- æ·±å…¥ç ”ç©¶ä»£ç ç”Ÿæˆå™¨ï¼ˆlcode.cï¼‰
- å­¦ä¹ è™šæ‹ŸæœºæŒ‡ä»¤æ‰§è¡Œï¼ˆlvm.cï¼‰
- ç ”ç©¶ä¼˜åŒ–æŠ€æœ¯å’Œæ€§èƒ½è°ƒä¼˜

æ„Ÿè°¢é˜…è¯»ï¼